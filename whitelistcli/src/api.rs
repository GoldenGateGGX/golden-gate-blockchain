# [allow (dead_code , unused_imports , non_camel_case_types)] # [allow (clippy :: all)] pub mod api { # [allow (unused_imports)] mod root_mod { pub use super :: * ; } pub static PALLETS : [& str ; 31usize] = ["System" , "Timestamp" , "RuntimeSpecification" , "Balances" , "Aura" , "ImOnline" , "TransactionPayment" , "Authorship" , "Offences" , "Session" , "Grandpa" , "Treasury" , "Bounties" , "Vesting" , "Indices" , "Proxy" , "Multisig" , "Identity" , "Sudo" , "Historical" , "RandomnessCollectiveFlip" , "ValidatorManager" , "Ethereum" , "EVM" , "EVMChainId" , "DynamicFee" , "BaseFee" , "HotfixSufficients" , "AccountFilter" , "Contracts" , "Xvm" ,] ; # [doc = r" The error type returned when there is a runtime issue."] pub type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum Event { # [codec (index = 0)] System (system :: Event) , # [codec (index = 3)] Balances (balances :: Event) , # [codec (index = 5)] ImOnline (im_online :: Event) , # [codec (index = 6)] TransactionPayment (transaction_payment :: Event) , # [codec (index = 8)] Offences (offences :: Event) , # [codec (index = 9)] Session (session :: Event) , # [codec (index = 10)] Grandpa (grandpa :: Event) , # [codec (index = 11)] Treasury (treasury :: Event) , # [codec (index = 12)] Bounties (bounties :: Event) , # [codec (index = 13)] Vesting (vesting :: Event) , # [codec (index = 14)] Indices (indices :: Event) , # [codec (index = 15)] Proxy (proxy :: Event) , # [codec (index = 16)] Multisig (multisig :: Event) , # [codec (index = 17)] Identity (identity :: Event) , # [codec (index = 18)] Sudo (sudo :: Event) , # [codec (index = 21)] ValidatorManager (validator_manager :: Event) , # [codec (index = 22)] Ethereum (ethereum :: Event) , # [codec (index = 23)] EVM (evm :: Event) , # [codec (index = 26)] BaseFee (base_fee :: Event) , # [codec (index = 28)] AccountFilter (account_filter :: Event) , # [codec (index = 29)] Contracts (contracts :: Event) , # [codec (index = 30)] Xvm (xvm :: Event) , } impl :: subxt :: events :: RootEvent for Event { fn root_event (pallet_bytes : & [u8] , pallet_name : & str , pallet_ty : u32 , metadata : & :: subxt :: Metadata) -> Result < Self , :: subxt :: Error > { use :: subxt :: metadata :: DecodeWithMetadata ; if pallet_name == "System" { return Ok (Event :: System (system :: Event :: decode_with_metadata (& mut & * pallet_bytes , pallet_ty , metadata) ?)) ; } if pallet_name == "Balances" { return Ok (Event :: Balances (balances :: Event :: decode_with_metadata (& mut & * pallet_bytes , pallet_ty , metadata) ?)) ; } if pallet_name == "ImOnline" { return Ok (Event :: ImOnline (im_online :: Event :: decode_with_metadata (& mut & * pallet_bytes , pallet_ty , metadata) ?)) ; } if pallet_name == "TransactionPayment" { return Ok (Event :: TransactionPayment (transaction_payment :: Event :: decode_with_metadata (& mut & * pallet_bytes , pallet_ty , metadata) ?)) ; } if pallet_name == "Offences" { return Ok (Event :: Offences (offences :: Event :: decode_with_metadata (& mut & * pallet_bytes , pallet_ty , metadata) ?)) ; } if pallet_name == "Session" { return Ok (Event :: Session (session :: Event :: decode_with_metadata (& mut & * pallet_bytes , pallet_ty , metadata) ?)) ; } if pallet_name == "Grandpa" { return Ok (Event :: Grandpa (grandpa :: Event :: decode_with_metadata (& mut & * pallet_bytes , pallet_ty , metadata) ?)) ; } if pallet_name == "Treasury" { return Ok (Event :: Treasury (treasury :: Event :: decode_with_metadata (& mut & * pallet_bytes , pallet_ty , metadata) ?)) ; } if pallet_name == "Bounties" { return Ok (Event :: Bounties (bounties :: Event :: decode_with_metadata (& mut & * pallet_bytes , pallet_ty , metadata) ?)) ; } if pallet_name == "Vesting" { return Ok (Event :: Vesting (vesting :: Event :: decode_with_metadata (& mut & * pallet_bytes , pallet_ty , metadata) ?)) ; } if pallet_name == "Indices" { return Ok (Event :: Indices (indices :: Event :: decode_with_metadata (& mut & * pallet_bytes , pallet_ty , metadata) ?)) ; } if pallet_name == "Proxy" { return Ok (Event :: Proxy (proxy :: Event :: decode_with_metadata (& mut & * pallet_bytes , pallet_ty , metadata) ?)) ; } if pallet_name == "Multisig" { return Ok (Event :: Multisig (multisig :: Event :: decode_with_metadata (& mut & * pallet_bytes , pallet_ty , metadata) ?)) ; } if pallet_name == "Identity" { return Ok (Event :: Identity (identity :: Event :: decode_with_metadata (& mut & * pallet_bytes , pallet_ty , metadata) ?)) ; } if pallet_name == "Sudo" { return Ok (Event :: Sudo (sudo :: Event :: decode_with_metadata (& mut & * pallet_bytes , pallet_ty , metadata) ?)) ; } if pallet_name == "ValidatorManager" { return Ok (Event :: ValidatorManager (validator_manager :: Event :: decode_with_metadata (& mut & * pallet_bytes , pallet_ty , metadata) ?)) ; } if pallet_name == "Ethereum" { return Ok (Event :: Ethereum (ethereum :: Event :: decode_with_metadata (& mut & * pallet_bytes , pallet_ty , metadata) ?)) ; } if pallet_name == "EVM" { return Ok (Event :: EVM (evm :: Event :: decode_with_metadata (& mut & * pallet_bytes , pallet_ty , metadata) ?)) ; } if pallet_name == "BaseFee" { return Ok (Event :: BaseFee (base_fee :: Event :: decode_with_metadata (& mut & * pallet_bytes , pallet_ty , metadata) ?)) ; } if pallet_name == "AccountFilter" { return Ok (Event :: AccountFilter (account_filter :: Event :: decode_with_metadata (& mut & * pallet_bytes , pallet_ty , metadata) ?)) ; } if pallet_name == "Contracts" { return Ok (Event :: Contracts (contracts :: Event :: decode_with_metadata (& mut & * pallet_bytes , pallet_ty , metadata) ?)) ; } if pallet_name == "Xvm" { return Ok (Event :: Xvm (xvm :: Event :: decode_with_metadata (& mut & * pallet_bytes , pallet_ty , metadata) ?)) ; } Err (:: subxt :: ext :: scale_decode :: Error :: custom (format ! ("Pallet name '{}' not found in root Event enum" , pallet_name)) . into ()) } } pub fn constants () -> ConstantsApi { ConstantsApi } pub fn storage () -> StorageApi { StorageApi } pub fn tx () -> TransactionApi { TransactionApi } pub struct ConstantsApi ; impl ConstantsApi { pub fn system (& self) -> system :: constants :: ConstantsApi { system :: constants :: ConstantsApi } pub fn timestamp (& self) -> timestamp :: constants :: ConstantsApi { timestamp :: constants :: ConstantsApi } pub fn balances (& self) -> balances :: constants :: ConstantsApi { balances :: constants :: ConstantsApi } pub fn im_online (& self) -> im_online :: constants :: ConstantsApi { im_online :: constants :: ConstantsApi } pub fn transaction_payment (& self) -> transaction_payment :: constants :: ConstantsApi { transaction_payment :: constants :: ConstantsApi } pub fn grandpa (& self) -> grandpa :: constants :: ConstantsApi { grandpa :: constants :: ConstantsApi } pub fn treasury (& self) -> treasury :: constants :: ConstantsApi { treasury :: constants :: ConstantsApi } pub fn bounties (& self) -> bounties :: constants :: ConstantsApi { bounties :: constants :: ConstantsApi } pub fn vesting (& self) -> vesting :: constants :: ConstantsApi { vesting :: constants :: ConstantsApi } pub fn indices (& self) -> indices :: constants :: ConstantsApi { indices :: constants :: ConstantsApi } pub fn proxy (& self) -> proxy :: constants :: ConstantsApi { proxy :: constants :: ConstantsApi } pub fn multisig (& self) -> multisig :: constants :: ConstantsApi { multisig :: constants :: ConstantsApi } pub fn identity (& self) -> identity :: constants :: ConstantsApi { identity :: constants :: ConstantsApi } pub fn contracts (& self) -> contracts :: constants :: ConstantsApi { contracts :: constants :: ConstantsApi } } pub struct StorageApi ; impl StorageApi { pub fn system (& self) -> system :: storage :: StorageApi { system :: storage :: StorageApi } pub fn timestamp (& self) -> timestamp :: storage :: StorageApi { timestamp :: storage :: StorageApi } pub fn runtime_specification (& self) -> runtime_specification :: storage :: StorageApi { runtime_specification :: storage :: StorageApi } pub fn balances (& self) -> balances :: storage :: StorageApi { balances :: storage :: StorageApi } pub fn aura (& self) -> aura :: storage :: StorageApi { aura :: storage :: StorageApi } pub fn im_online (& self) -> im_online :: storage :: StorageApi { im_online :: storage :: StorageApi } pub fn transaction_payment (& self) -> transaction_payment :: storage :: StorageApi { transaction_payment :: storage :: StorageApi } pub fn authorship (& self) -> authorship :: storage :: StorageApi { authorship :: storage :: StorageApi } pub fn offences (& self) -> offences :: storage :: StorageApi { offences :: storage :: StorageApi } pub fn session (& self) -> session :: storage :: StorageApi { session :: storage :: StorageApi } pub fn grandpa (& self) -> grandpa :: storage :: StorageApi { grandpa :: storage :: StorageApi } pub fn treasury (& self) -> treasury :: storage :: StorageApi { treasury :: storage :: StorageApi } pub fn bounties (& self) -> bounties :: storage :: StorageApi { bounties :: storage :: StorageApi } pub fn vesting (& self) -> vesting :: storage :: StorageApi { vesting :: storage :: StorageApi } pub fn indices (& self) -> indices :: storage :: StorageApi { indices :: storage :: StorageApi } pub fn proxy (& self) -> proxy :: storage :: StorageApi { proxy :: storage :: StorageApi } pub fn multisig (& self) -> multisig :: storage :: StorageApi { multisig :: storage :: StorageApi } pub fn identity (& self) -> identity :: storage :: StorageApi { identity :: storage :: StorageApi } pub fn sudo (& self) -> sudo :: storage :: StorageApi { sudo :: storage :: StorageApi } pub fn historical (& self) -> historical :: storage :: StorageApi { historical :: storage :: StorageApi } pub fn randomness_collective_flip (& self) -> randomness_collective_flip :: storage :: StorageApi { randomness_collective_flip :: storage :: StorageApi } pub fn validator_manager (& self) -> validator_manager :: storage :: StorageApi { validator_manager :: storage :: StorageApi } pub fn ethereum (& self) -> ethereum :: storage :: StorageApi { ethereum :: storage :: StorageApi } pub fn evm (& self) -> evm :: storage :: StorageApi { evm :: storage :: StorageApi } pub fn evm_chain_id (& self) -> evm_chain_id :: storage :: StorageApi { evm_chain_id :: storage :: StorageApi } pub fn dynamic_fee (& self) -> dynamic_fee :: storage :: StorageApi { dynamic_fee :: storage :: StorageApi } pub fn base_fee (& self) -> base_fee :: storage :: StorageApi { base_fee :: storage :: StorageApi } pub fn account_filter (& self) -> account_filter :: storage :: StorageApi { account_filter :: storage :: StorageApi } pub fn contracts (& self) -> contracts :: storage :: StorageApi { contracts :: storage :: StorageApi } } pub struct TransactionApi ; impl TransactionApi { pub fn system (& self) -> system :: calls :: TransactionApi { system :: calls :: TransactionApi } pub fn timestamp (& self) -> timestamp :: calls :: TransactionApi { timestamp :: calls :: TransactionApi } pub fn balances (& self) -> balances :: calls :: TransactionApi { balances :: calls :: TransactionApi } pub fn im_online (& self) -> im_online :: calls :: TransactionApi { im_online :: calls :: TransactionApi } pub fn session (& self) -> session :: calls :: TransactionApi { session :: calls :: TransactionApi } pub fn grandpa (& self) -> grandpa :: calls :: TransactionApi { grandpa :: calls :: TransactionApi } pub fn treasury (& self) -> treasury :: calls :: TransactionApi { treasury :: calls :: TransactionApi } pub fn bounties (& self) -> bounties :: calls :: TransactionApi { bounties :: calls :: TransactionApi } pub fn vesting (& self) -> vesting :: calls :: TransactionApi { vesting :: calls :: TransactionApi } pub fn indices (& self) -> indices :: calls :: TransactionApi { indices :: calls :: TransactionApi } pub fn proxy (& self) -> proxy :: calls :: TransactionApi { proxy :: calls :: TransactionApi } pub fn multisig (& self) -> multisig :: calls :: TransactionApi { multisig :: calls :: TransactionApi } pub fn identity (& self) -> identity :: calls :: TransactionApi { identity :: calls :: TransactionApi } pub fn sudo (& self) -> sudo :: calls :: TransactionApi { sudo :: calls :: TransactionApi } pub fn validator_manager (& self) -> validator_manager :: calls :: TransactionApi { validator_manager :: calls :: TransactionApi } pub fn ethereum (& self) -> ethereum :: calls :: TransactionApi { ethereum :: calls :: TransactionApi } pub fn evm (& self) -> evm :: calls :: TransactionApi { evm :: calls :: TransactionApi } pub fn dynamic_fee (& self) -> dynamic_fee :: calls :: TransactionApi { dynamic_fee :: calls :: TransactionApi } pub fn base_fee (& self) -> base_fee :: calls :: TransactionApi { base_fee :: calls :: TransactionApi } pub fn hotfix_sufficients (& self) -> hotfix_sufficients :: calls :: TransactionApi { hotfix_sufficients :: calls :: TransactionApi } pub fn account_filter (& self) -> account_filter :: calls :: TransactionApi { account_filter :: calls :: TransactionApi } pub fn contracts (& self) -> contracts :: calls :: TransactionApi { contracts :: calls :: TransactionApi } pub fn xvm (& self) -> xvm :: calls :: TransactionApi { xvm :: calls :: TransactionApi } } # [doc = r" check whether the Client you are using is aligned with the statically generated codegen."] pub fn validate_codegen < T : :: subxt :: Config , C : :: subxt :: client :: OfflineClientT < T >> (client : & C) -> Result < () , :: subxt :: error :: MetadataError > { let runtime_metadata_hash = client . metadata () . metadata_hash (& PALLETS) ; if runtime_metadata_hash != [87u8 , 11u8 , 100u8 , 212u8 , 63u8 , 221u8 , 248u8 , 71u8 , 146u8 , 122u8 , 154u8 , 188u8 , 221u8 , 241u8 , 40u8 , 1u8 , 50u8 , 207u8 , 72u8 , 28u8 , 134u8 , 232u8 , 221u8 , 250u8 , 216u8 , 240u8 , 194u8 , 74u8 , 158u8 , 252u8 , 2u8 , 48u8 ,] { Err (:: subxt :: error :: MetadataError :: IncompatibleMetadata) } else { Ok (()) } } pub mod system { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Remark { pub remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct SetHeapPages { pub pages : :: core :: primitive :: u64 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct SetCode { pub code : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct SetCodeWithoutChecks { pub code : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct SetStorage { pub items : :: std :: vec :: Vec < (:: std :: vec :: Vec < :: core :: primitive :: u8 > , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct KillStorage { pub keys : :: std :: vec :: Vec < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct KillPrefix { pub prefix : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub subkeys : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct RemarkWithEvent { pub remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Make some on-chain remark."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)`"] pub fn remark (& self , remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: tx :: Payload < Remark > { :: subxt :: tx :: Payload :: new_static ("System" , "remark" , Remark { remark , } , [101u8 , 80u8 , 195u8 , 226u8 , 224u8 , 247u8 , 60u8 , 128u8 , 3u8 , 101u8 , 51u8 , 147u8 , 96u8 , 126u8 , 76u8 , 230u8 , 194u8 , 227u8 , 191u8 , 73u8 , 160u8 , 146u8 , 87u8 , 147u8 , 243u8 , 28u8 , 228u8 , 116u8 , 224u8 , 181u8 , 129u8 , 160u8 ,]) } # [doc = "Set the number of pages in the WebAssembly environment's heap."] pub fn set_heap_pages (& self , pages : :: core :: primitive :: u64 ,) -> :: subxt :: tx :: Payload < SetHeapPages > { :: subxt :: tx :: Payload :: new_static ("System" , "set_heap_pages" , SetHeapPages { pages , } , [43u8 , 103u8 , 128u8 , 49u8 , 156u8 , 136u8 , 11u8 , 204u8 , 80u8 , 6u8 , 244u8 , 86u8 , 171u8 , 44u8 , 140u8 , 225u8 , 142u8 , 198u8 , 43u8 , 87u8 , 26u8 , 45u8 , 125u8 , 222u8 , 165u8 , 254u8 , 172u8 , 158u8 , 39u8 , 178u8 , 86u8 , 87u8 ,]) } # [doc = "Set the new runtime code."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`"] pub fn set_code (& self , code : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: tx :: Payload < SetCode > { :: subxt :: tx :: Payload :: new_static ("System" , "set_code" , SetCode { code , } , [27u8 , 104u8 , 244u8 , 205u8 , 188u8 , 254u8 , 121u8 , 13u8 , 106u8 , 120u8 , 244u8 , 108u8 , 97u8 , 84u8 , 100u8 , 68u8 , 26u8 , 69u8 , 93u8 , 128u8 , 107u8 , 4u8 , 3u8 , 142u8 , 13u8 , 134u8 , 196u8 , 62u8 , 113u8 , 181u8 , 14u8 , 40u8 ,]) } # [doc = "Set the new runtime code without doing any checks of the given `code`."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(C)` where `C` length of `code`"] pub fn set_code_without_checks (& self , code : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: tx :: Payload < SetCodeWithoutChecks > { :: subxt :: tx :: Payload :: new_static ("System" , "set_code_without_checks" , SetCodeWithoutChecks { code , } , [102u8 , 160u8 , 125u8 , 235u8 , 30u8 , 23u8 , 45u8 , 239u8 , 112u8 , 148u8 , 159u8 , 158u8 , 42u8 , 93u8 , 206u8 , 94u8 , 80u8 , 250u8 , 66u8 , 195u8 , 60u8 , 40u8 , 142u8 , 169u8 , 183u8 , 80u8 , 80u8 , 96u8 , 3u8 , 231u8 , 99u8 , 216u8 ,]) } # [doc = "Set some items of storage."] pub fn set_storage (& self , items : :: std :: vec :: Vec < (:: std :: vec :: Vec < :: core :: primitive :: u8 > , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) > ,) -> :: subxt :: tx :: Payload < SetStorage > { :: subxt :: tx :: Payload :: new_static ("System" , "set_storage" , SetStorage { items , } , [74u8 , 43u8 , 106u8 , 255u8 , 50u8 , 151u8 , 192u8 , 155u8 , 14u8 , 90u8 , 19u8 , 45u8 , 165u8 , 16u8 , 235u8 , 242u8 , 21u8 , 131u8 , 33u8 , 172u8 , 119u8 , 78u8 , 140u8 , 10u8 , 107u8 , 202u8 , 122u8 , 235u8 , 181u8 , 191u8 , 22u8 , 116u8 ,]) } # [doc = "Kill some items from storage."] pub fn kill_storage (& self , keys : :: std :: vec :: Vec < :: std :: vec :: Vec < :: core :: primitive :: u8 > > ,) -> :: subxt :: tx :: Payload < KillStorage > { :: subxt :: tx :: Payload :: new_static ("System" , "kill_storage" , KillStorage { keys , } , [174u8 , 174u8 , 13u8 , 174u8 , 75u8 , 138u8 , 128u8 , 235u8 , 222u8 , 216u8 , 85u8 , 18u8 , 198u8 , 1u8 , 138u8 , 70u8 , 19u8 , 108u8 , 209u8 , 41u8 , 228u8 , 67u8 , 130u8 , 230u8 , 160u8 , 207u8 , 11u8 , 180u8 , 139u8 , 242u8 , 41u8 , 15u8 ,]) } # [doc = "Kill all storage items with a key that starts with the given prefix."] # [doc = ""] # [doc = "**NOTE:** We rely on the Root origin to provide us the number of subkeys under"] # [doc = "the prefix we are removing to accurately calculate the weight of this function."] pub fn kill_prefix (& self , prefix : :: std :: vec :: Vec < :: core :: primitive :: u8 > , subkeys : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: Payload < KillPrefix > { :: subxt :: tx :: Payload :: new_static ("System" , "kill_prefix" , KillPrefix { prefix , subkeys , } , [203u8 , 116u8 , 217u8 , 42u8 , 154u8 , 215u8 , 77u8 , 217u8 , 13u8 , 22u8 , 193u8 , 2u8 , 128u8 , 115u8 , 179u8 , 115u8 , 187u8 , 218u8 , 129u8 , 34u8 , 80u8 , 4u8 , 173u8 , 120u8 , 92u8 , 35u8 , 237u8 , 112u8 , 201u8 , 207u8 , 200u8 , 48u8 ,]) } # [doc = "Make some on-chain remark and emit event."] pub fn remark_with_event (& self , remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: tx :: Payload < RemarkWithEvent > { :: subxt :: tx :: Payload :: new_static ("System" , "remark_with_event" , RemarkWithEvent { remark , } , [123u8 , 225u8 , 180u8 , 179u8 , 144u8 , 74u8 , 27u8 , 85u8 , 101u8 , 75u8 , 134u8 , 44u8 , 181u8 , 25u8 , 183u8 , 158u8 , 14u8 , 213u8 , 56u8 , 225u8 , 136u8 , 88u8 , 26u8 , 114u8 , 178u8 , 43u8 , 176u8 , 43u8 , 240u8 , 84u8 , 116u8 , 46u8 ,]) } } } # [doc = "Event for the System pallet."] pub type Event = runtime_types :: frame_system :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "An extrinsic completed successfully."] pub struct ExtrinsicSuccess { pub dispatch_info : runtime_types :: frame_support :: dispatch :: DispatchInfo , } impl :: subxt :: events :: StaticEvent for ExtrinsicSuccess { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "ExtrinsicSuccess" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "An extrinsic failed."] pub struct ExtrinsicFailed { pub dispatch_error : runtime_types :: sp_runtime :: DispatchError , pub dispatch_info : runtime_types :: frame_support :: dispatch :: DispatchInfo , } impl :: subxt :: events :: StaticEvent for ExtrinsicFailed { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "ExtrinsicFailed" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "`:code` was updated."] pub struct CodeUpdated ; impl :: subxt :: events :: StaticEvent for CodeUpdated { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "CodeUpdated" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A new account was created."] pub struct NewAccount { pub account : :: subxt :: utils :: AccountId32 , } impl :: subxt :: events :: StaticEvent for NewAccount { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "NewAccount" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "An account was reaped."] pub struct KilledAccount { pub account : :: subxt :: utils :: AccountId32 , } impl :: subxt :: events :: StaticEvent for KilledAccount { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "KilledAccount" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "On on-chain remark happened."] pub struct Remarked { pub sender : :: subxt :: utils :: AccountId32 , pub hash : :: subxt :: utils :: H256 , } impl :: subxt :: events :: StaticEvent for Remarked { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "Remarked" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " The full account information for a particular account ID."] pub fn account (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: utils :: AccountId32 > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: frame_system :: AccountInfo < :: core :: primitive :: u32 , runtime_types :: pallet_balances :: AccountData < :: core :: primitive :: u128 > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("System" , "Account" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ())] , [176u8 , 187u8 , 21u8 , 220u8 , 159u8 , 204u8 , 127u8 , 14u8 , 21u8 , 69u8 , 77u8 , 114u8 , 230u8 , 141u8 , 107u8 , 79u8 , 23u8 , 16u8 , 174u8 , 243u8 , 252u8 , 42u8 , 65u8 , 120u8 , 229u8 , 38u8 , 210u8 , 255u8 , 22u8 , 40u8 , 109u8 , 223u8 ,]) } # [doc = " The full account information for a particular account ID."] pub fn account_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: frame_system :: AccountInfo < :: core :: primitive :: u32 , runtime_types :: pallet_balances :: AccountData < :: core :: primitive :: u128 > > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("System" , "Account" , Vec :: new () , [176u8 , 187u8 , 21u8 , 220u8 , 159u8 , 204u8 , 127u8 , 14u8 , 21u8 , 69u8 , 77u8 , 114u8 , 230u8 , 141u8 , 107u8 , 79u8 , 23u8 , 16u8 , 174u8 , 243u8 , 252u8 , 42u8 , 65u8 , 120u8 , 229u8 , 38u8 , 210u8 , 255u8 , 22u8 , 40u8 , 109u8 , 223u8 ,]) } # [doc = " Total extrinsics count for the current block."] pub fn extrinsic_count (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: core :: primitive :: u32 , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: Address :: new_static ("System" , "ExtrinsicCount" , vec ! [] , [223u8 , 60u8 , 201u8 , 120u8 , 36u8 , 44u8 , 180u8 , 210u8 , 242u8 , 53u8 , 222u8 , 154u8 , 123u8 , 176u8 , 249u8 , 8u8 , 225u8 , 28u8 , 232u8 , 4u8 , 136u8 , 41u8 , 151u8 , 82u8 , 189u8 , 149u8 , 49u8 , 166u8 , 139u8 , 9u8 , 163u8 , 231u8 ,]) } # [doc = " The current weight for the block."] pub fn block_weight (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: frame_support :: dispatch :: PerDispatchClass < runtime_types :: sp_weights :: weight_v2 :: Weight > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("System" , "BlockWeight" , vec ! [] , [120u8 , 67u8 , 71u8 , 163u8 , 36u8 , 202u8 , 52u8 , 106u8 , 143u8 , 155u8 , 144u8 , 87u8 , 142u8 , 241u8 , 232u8 , 183u8 , 56u8 , 235u8 , 27u8 , 237u8 , 20u8 , 202u8 , 33u8 , 85u8 , 189u8 , 0u8 , 28u8 , 52u8 , 198u8 , 40u8 , 219u8 , 54u8 ,]) } # [doc = " Total length (in bytes) for all extrinsics put together, for the current block."] pub fn all_extrinsics_len (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: core :: primitive :: u32 , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: Address :: new_static ("System" , "AllExtrinsicsLen" , vec ! [] , [202u8 , 145u8 , 209u8 , 225u8 , 40u8 , 220u8 , 174u8 , 74u8 , 93u8 , 164u8 , 254u8 , 248u8 , 254u8 , 192u8 , 32u8 , 117u8 , 96u8 , 149u8 , 53u8 , 145u8 , 219u8 , 64u8 , 234u8 , 18u8 , 217u8 , 200u8 , 203u8 , 141u8 , 145u8 , 28u8 , 134u8 , 60u8 ,]) } # [doc = " Map of block numbers to block hashes."] pub fn block_hash (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: subxt :: utils :: H256 , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("System" , "BlockHash" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ())] , [50u8 , 112u8 , 176u8 , 239u8 , 175u8 , 18u8 , 205u8 , 20u8 , 241u8 , 195u8 , 21u8 , 228u8 , 186u8 , 57u8 , 200u8 , 25u8 , 38u8 , 44u8 , 106u8 , 20u8 , 168u8 , 80u8 , 76u8 , 235u8 , 12u8 , 51u8 , 137u8 , 149u8 , 200u8 , 4u8 , 220u8 , 237u8 ,]) } # [doc = " Map of block numbers to block hashes."] pub fn block_hash_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: subxt :: utils :: H256 , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("System" , "BlockHash" , Vec :: new () , [50u8 , 112u8 , 176u8 , 239u8 , 175u8 , 18u8 , 205u8 , 20u8 , 241u8 , 195u8 , 21u8 , 228u8 , 186u8 , 57u8 , 200u8 , 25u8 , 38u8 , 44u8 , 106u8 , 20u8 , 168u8 , 80u8 , 76u8 , 235u8 , 12u8 , 51u8 , 137u8 , 149u8 , 200u8 , 4u8 , 220u8 , 237u8 ,]) } # [doc = " Extrinsics data for the current block (maps an extrinsic's index to its data)."] pub fn extrinsic_data (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: std :: vec :: Vec < :: core :: primitive :: u8 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("System" , "ExtrinsicData" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ())] , [210u8 , 224u8 , 211u8 , 186u8 , 118u8 , 210u8 , 185u8 , 194u8 , 238u8 , 211u8 , 254u8 , 73u8 , 67u8 , 184u8 , 31u8 , 229u8 , 168u8 , 125u8 , 98u8 , 23u8 , 241u8 , 59u8 , 49u8 , 86u8 , 126u8 , 9u8 , 114u8 , 163u8 , 160u8 , 62u8 , 50u8 , 67u8 ,]) } # [doc = " Extrinsics data for the current block (maps an extrinsic's index to its data)."] pub fn extrinsic_data_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: std :: vec :: Vec < :: core :: primitive :: u8 > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("System" , "ExtrinsicData" , Vec :: new () , [210u8 , 224u8 , 211u8 , 186u8 , 118u8 , 210u8 , 185u8 , 194u8 , 238u8 , 211u8 , 254u8 , 73u8 , 67u8 , 184u8 , 31u8 , 229u8 , 168u8 , 125u8 , 98u8 , 23u8 , 241u8 , 59u8 , 49u8 , 86u8 , 126u8 , 9u8 , 114u8 , 163u8 , 160u8 , 62u8 , 50u8 , 67u8 ,]) } # [doc = " The current block number being processed. Set by `execute_block`."] pub fn number (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: core :: primitive :: u32 , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("System" , "Number" , vec ! [] , [228u8 , 96u8 , 102u8 , 190u8 , 252u8 , 130u8 , 239u8 , 172u8 , 126u8 , 235u8 , 246u8 , 139u8 , 208u8 , 15u8 , 88u8 , 245u8 , 141u8 , 232u8 , 43u8 , 204u8 , 36u8 , 87u8 , 211u8 , 141u8 , 187u8 , 68u8 , 236u8 , 70u8 , 193u8 , 235u8 , 164u8 , 191u8 ,]) } # [doc = " Hash of the previous block."] pub fn parent_hash (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: subxt :: utils :: H256 , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("System" , "ParentHash" , vec ! [] , [232u8 , 206u8 , 177u8 , 119u8 , 38u8 , 57u8 , 233u8 , 50u8 , 225u8 , 49u8 , 169u8 , 176u8 , 210u8 , 51u8 , 231u8 , 176u8 , 234u8 , 186u8 , 188u8 , 112u8 , 15u8 , 152u8 , 195u8 , 232u8 , 201u8 , 97u8 , 208u8 , 249u8 , 9u8 , 163u8 , 69u8 , 36u8 ,]) } # [doc = " Digest of the current block, also part of the block header."] pub fn digest (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: sp_runtime :: generic :: digest :: Digest , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("System" , "Digest" , vec ! [] , [83u8 , 141u8 , 200u8 , 132u8 , 182u8 , 55u8 , 197u8 , 122u8 , 13u8 , 159u8 , 31u8 , 42u8 , 60u8 , 191u8 , 89u8 , 221u8 , 242u8 , 47u8 , 199u8 , 213u8 , 48u8 , 216u8 , 131u8 , 168u8 , 245u8 , 82u8 , 56u8 , 190u8 , 62u8 , 69u8 , 96u8 , 37u8 ,]) } # [doc = " Events deposited for the current block."] # [doc = ""] # [doc = " NOTE: The item is unbound and should therefore never be read on chain."] # [doc = " It could otherwise inflate the PoV size of a block."] # [doc = ""] # [doc = " Events have a large in-memory size. Box the events to not go out-of-memory"] # [doc = " just in case someone still reads them from within the runtime."] pub fn events (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: std :: vec :: Vec < runtime_types :: frame_system :: EventRecord < runtime_types :: golden_gate_runtime_testnet :: RuntimeEvent , :: subxt :: utils :: H256 > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("System" , "Events" , vec ! [] , [107u8 , 133u8 , 248u8 , 12u8 , 121u8 , 199u8 , 74u8 , 78u8 , 96u8 , 154u8 , 213u8 , 234u8 , 140u8 , 218u8 , 59u8 , 136u8 , 194u8 , 55u8 , 120u8 , 199u8 , 189u8 , 22u8 , 31u8 , 161u8 , 208u8 , 206u8 , 253u8 , 194u8 , 253u8 , 7u8 , 166u8 , 38u8 ,]) } # [doc = " The number of events in the `Events<T>` list."] pub fn event_count (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: core :: primitive :: u32 , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("System" , "EventCount" , vec ! [] , [236u8 , 93u8 , 90u8 , 177u8 , 250u8 , 211u8 , 138u8 , 187u8 , 26u8 , 208u8 , 203u8 , 113u8 , 221u8 , 233u8 , 227u8 , 9u8 , 249u8 , 25u8 , 202u8 , 185u8 , 161u8 , 144u8 , 167u8 , 104u8 , 127u8 , 187u8 , 38u8 , 18u8 , 52u8 , 61u8 , 66u8 , 112u8 ,]) } # [doc = " Mapping between a topic (represented by T::Hash) and a vector of indexes"] # [doc = " of events in the `<Events<T>>` list."] # [doc = ""] # [doc = " All topic vectors have deterministic storage locations depending on the topic. This"] # [doc = " allows light-clients to leverage the changes trie storage tracking mechanism and"] # [doc = " in case of changes fetch the list of events of interest."] # [doc = ""] # [doc = " The value has the type `(T::BlockNumber, EventIndex)` because if we used only just"] # [doc = " the `EventIndex` then in case if the topic has the same contents on the next block"] # [doc = " no notification will be triggered thus the event might be lost."] pub fn event_topics (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: utils :: H256 > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: std :: vec :: Vec < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("System" , "EventTopics" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ())] , [205u8 , 90u8 , 142u8 , 190u8 , 176u8 , 37u8 , 94u8 , 82u8 , 98u8 , 1u8 , 129u8 , 63u8 , 246u8 , 101u8 , 130u8 , 58u8 , 216u8 , 16u8 , 139u8 , 196u8 , 154u8 , 111u8 , 110u8 , 178u8 , 24u8 , 44u8 , 183u8 , 176u8 , 232u8 , 82u8 , 223u8 , 38u8 ,]) } # [doc = " Mapping between a topic (represented by T::Hash) and a vector of indexes"] # [doc = " of events in the `<Events<T>>` list."] # [doc = ""] # [doc = " All topic vectors have deterministic storage locations depending on the topic. This"] # [doc = " allows light-clients to leverage the changes trie storage tracking mechanism and"] # [doc = " in case of changes fetch the list of events of interest."] # [doc = ""] # [doc = " The value has the type `(T::BlockNumber, EventIndex)` because if we used only just"] # [doc = " the `EventIndex` then in case if the topic has the same contents on the next block"] # [doc = " no notification will be triggered thus the event might be lost."] pub fn event_topics_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: std :: vec :: Vec < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("System" , "EventTopics" , Vec :: new () , [205u8 , 90u8 , 142u8 , 190u8 , 176u8 , 37u8 , 94u8 , 82u8 , 98u8 , 1u8 , 129u8 , 63u8 , 246u8 , 101u8 , 130u8 , 58u8 , 216u8 , 16u8 , 139u8 , 196u8 , 154u8 , 111u8 , 110u8 , 178u8 , 24u8 , 44u8 , 183u8 , 176u8 , 232u8 , 82u8 , 223u8 , 38u8 ,]) } # [doc = " Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened."] pub fn last_runtime_upgrade (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: frame_system :: LastRuntimeUpgradeInfo , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: Address :: new_static ("System" , "LastRuntimeUpgrade" , vec ! [] , [52u8 , 37u8 , 117u8 , 111u8 , 57u8 , 130u8 , 196u8 , 14u8 , 99u8 , 77u8 , 91u8 , 126u8 , 178u8 , 249u8 , 78u8 , 34u8 , 9u8 , 194u8 , 92u8 , 105u8 , 113u8 , 81u8 , 185u8 , 127u8 , 245u8 , 184u8 , 60u8 , 29u8 , 234u8 , 182u8 , 96u8 , 196u8 ,]) } # [doc = " True if we have upgraded so that `type RefCount` is `u32`. False (default) if not."] pub fn upgraded_to_u32_ref_count (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: core :: primitive :: bool , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("System" , "UpgradedToU32RefCount" , vec ! [] , [171u8 , 88u8 , 244u8 , 92u8 , 122u8 , 67u8 , 27u8 , 18u8 , 59u8 , 175u8 , 175u8 , 178u8 , 20u8 , 150u8 , 213u8 , 59u8 , 222u8 , 141u8 , 32u8 , 107u8 , 3u8 , 114u8 , 83u8 , 250u8 , 180u8 , 233u8 , 152u8 , 54u8 , 187u8 , 99u8 , 131u8 , 204u8 ,]) } # [doc = " True if we have upgraded so that AccountInfo contains three types of `RefCount`. False"] # [doc = " (default) if not."] pub fn upgraded_to_triple_ref_count (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: core :: primitive :: bool , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("System" , "UpgradedToTripleRefCount" , vec ! [] , [90u8 , 33u8 , 56u8 , 86u8 , 90u8 , 101u8 , 89u8 , 133u8 , 203u8 , 56u8 , 201u8 , 210u8 , 244u8 , 232u8 , 150u8 , 18u8 , 51u8 , 105u8 , 14u8 , 230u8 , 103u8 , 155u8 , 246u8 , 99u8 , 53u8 , 207u8 , 225u8 , 128u8 , 186u8 , 76u8 , 40u8 , 185u8 ,]) } # [doc = " The execution phase of the block."] pub fn execution_phase (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: frame_system :: Phase , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: Address :: new_static ("System" , "ExecutionPhase" , vec ! [] , [230u8 , 183u8 , 221u8 , 135u8 , 226u8 , 223u8 , 55u8 , 104u8 , 138u8 , 224u8 , 103u8 , 156u8 , 222u8 , 99u8 , 203u8 , 199u8 , 164u8 , 168u8 , 193u8 , 133u8 , 201u8 , 155u8 , 63u8 , 95u8 , 17u8 , 206u8 , 165u8 , 123u8 , 161u8 , 33u8 , 172u8 , 93u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " Block & extrinsics weights: base values and limits."] pub fn block_weights (& self) -> :: subxt :: constants :: Address < runtime_types :: frame_system :: limits :: BlockWeights > { :: subxt :: constants :: Address :: new_static ("System" , "BlockWeights" , [118u8 , 253u8 , 239u8 , 217u8 , 145u8 , 115u8 , 85u8 , 86u8 , 172u8 , 248u8 , 139u8 , 32u8 , 158u8 , 126u8 , 172u8 , 188u8 , 197u8 , 105u8 , 145u8 , 235u8 , 171u8 , 50u8 , 31u8 , 225u8 , 167u8 , 187u8 , 241u8 , 87u8 , 6u8 , 17u8 , 234u8 , 185u8 ,]) } # [doc = " The maximum length of a block (in bytes)."] pub fn block_length (& self) -> :: subxt :: constants :: Address < runtime_types :: frame_system :: limits :: BlockLength > { :: subxt :: constants :: Address :: new_static ("System" , "BlockLength" , [116u8 , 184u8 , 225u8 , 228u8 , 207u8 , 203u8 , 4u8 , 220u8 , 234u8 , 198u8 , 150u8 , 108u8 , 205u8 , 87u8 , 194u8 , 131u8 , 229u8 , 51u8 , 140u8 , 4u8 , 47u8 , 12u8 , 200u8 , 144u8 , 153u8 , 62u8 , 51u8 , 39u8 , 138u8 , 205u8 , 203u8 , 236u8 ,]) } # [doc = " Maximum number of block number to block hash mappings to keep (oldest pruned first)."] pub fn block_hash_count (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u32 > { :: subxt :: constants :: Address :: new_static ("System" , "BlockHashCount" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The weight of runtime database operations the runtime can invoke."] pub fn db_weight (& self) -> :: subxt :: constants :: Address < runtime_types :: sp_weights :: RuntimeDbWeight > { :: subxt :: constants :: Address :: new_static ("System" , "DbWeight" , [124u8 , 162u8 , 190u8 , 149u8 , 49u8 , 177u8 , 162u8 , 231u8 , 62u8 , 167u8 , 199u8 , 181u8 , 43u8 , 232u8 , 185u8 , 116u8 , 195u8 , 51u8 , 233u8 , 223u8 , 20u8 , 129u8 , 246u8 , 13u8 , 65u8 , 180u8 , 64u8 , 9u8 , 157u8 , 59u8 , 245u8 , 118u8 ,]) } # [doc = " Get the chain's current version."] pub fn version (& self) -> :: subxt :: constants :: Address < runtime_types :: sp_version :: RuntimeVersion > { :: subxt :: constants :: Address :: new_static ("System" , "Version" , [93u8 , 98u8 , 57u8 , 243u8 , 229u8 , 8u8 , 234u8 , 231u8 , 72u8 , 230u8 , 139u8 , 47u8 , 63u8 , 181u8 , 17u8 , 2u8 , 220u8 , 231u8 , 104u8 , 237u8 , 185u8 , 143u8 , 165u8 , 253u8 , 188u8 , 76u8 , 147u8 , 12u8 , 170u8 , 26u8 , 74u8 , 200u8 ,]) } # [doc = " The designated SS58 prefix of this chain."] # [doc = ""] # [doc = " This replaces the \"ss58Format\" property declared in the chain spec. Reason is"] # [doc = " that the runtime should know about the prefix in order to make use of it as"] # [doc = " an identifier of the chain."] pub fn ss58_prefix (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u16 > { :: subxt :: constants :: Address :: new_static ("System" , "SS58Prefix" , [116u8 , 33u8 , 2u8 , 170u8 , 181u8 , 147u8 , 171u8 , 169u8 , 167u8 , 227u8 , 41u8 , 144u8 , 11u8 , 236u8 , 82u8 , 100u8 , 74u8 , 60u8 , 184u8 , 72u8 , 169u8 , 90u8 , 208u8 , 135u8 , 15u8 , 117u8 , 10u8 , 123u8 , 128u8 , 193u8 , 29u8 , 70u8 ,]) } } } } pub mod timestamp { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Set { # [codec (compact)] pub now : :: core :: primitive :: u64 , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Set the current time."] # [doc = ""] # [doc = "This call should be invoked exactly once per block. It will panic at the finalization"] # [doc = "phase, if this call hasn't been invoked by that time."] # [doc = ""] # [doc = "The timestamp should be greater than the previous one by the amount specified by"] # [doc = "`MinimumPeriod`."] # [doc = ""] # [doc = "The dispatch origin for this call must be `Inherent`."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)"] # [doc = "- 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in"] # [doc = "  `on_finalize`)"] # [doc = "- 1 event handler `on_timestamp_set`. Must be `O(1)`."] pub fn set (& self , now : :: core :: primitive :: u64 ,) -> :: subxt :: tx :: Payload < Set > { :: subxt :: tx :: Payload :: new_static ("Timestamp" , "set" , Set { now , } , [6u8 , 97u8 , 172u8 , 236u8 , 118u8 , 238u8 , 228u8 , 114u8 , 15u8 , 115u8 , 102u8 , 85u8 , 66u8 , 151u8 , 16u8 , 33u8 , 187u8 , 17u8 , 166u8 , 88u8 , 127u8 , 214u8 , 182u8 , 51u8 , 168u8 , 88u8 , 43u8 , 101u8 , 185u8 , 8u8 , 1u8 , 28u8 ,]) } } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " Current time for the current block."] pub fn now (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: core :: primitive :: u64 , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("Timestamp" , "Now" , vec ! [] , [148u8 , 53u8 , 50u8 , 54u8 , 13u8 , 161u8 , 57u8 , 150u8 , 16u8 , 83u8 , 144u8 , 221u8 , 59u8 , 75u8 , 158u8 , 130u8 , 39u8 , 123u8 , 106u8 , 134u8 , 202u8 , 185u8 , 83u8 , 85u8 , 60u8 , 41u8 , 120u8 , 96u8 , 210u8 , 34u8 , 2u8 , 250u8 ,]) } # [doc = " Did the timestamp get updated in this block?"] pub fn did_update (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: core :: primitive :: bool , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("Timestamp" , "DidUpdate" , vec ! [] , [70u8 , 13u8 , 92u8 , 186u8 , 80u8 , 151u8 , 167u8 , 90u8 , 158u8 , 232u8 , 175u8 , 13u8 , 103u8 , 135u8 , 2u8 , 78u8 , 16u8 , 6u8 , 39u8 , 158u8 , 167u8 , 85u8 , 27u8 , 47u8 , 122u8 , 73u8 , 127u8 , 26u8 , 35u8 , 168u8 , 72u8 , 204u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The minimum period between blocks. Beware that this is different to the *expected*"] # [doc = " period that the block production apparatus provides. Your chosen consensus system will"] # [doc = " generally work with this to determine a sensible block time. e.g. For Aura, it will be"] # [doc = " double this period on default settings."] pub fn minimum_period (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u64 > { :: subxt :: constants :: Address :: new_static ("Timestamp" , "MinimumPeriod" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } } } } pub mod runtime_specification { use super :: root_mod ; use super :: runtime_types ; pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { pub fn specification (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: runtime_common :: chain_spec :: RuntimeConfig , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("RuntimeSpecification" , "Specification" , vec ! [] , [160u8 , 87u8 , 138u8 , 145u8 , 155u8 , 163u8 , 20u8 , 73u8 , 220u8 , 102u8 , 166u8 , 65u8 , 198u8 , 150u8 , 61u8 , 56u8 , 107u8 , 253u8 , 253u8 , 157u8 , 239u8 , 224u8 , 167u8 , 7u8 , 20u8 , 41u8 , 135u8 , 92u8 , 220u8 , 143u8 , 79u8 , 255u8 ,]) } } } } pub mod balances { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Transfer { pub dest : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pub value : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct SetBalance { pub who : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pub new_free : :: core :: primitive :: u128 , # [codec (compact)] pub new_reserved : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct ForceTransfer { pub source : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , pub dest : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pub value : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct TransferKeepAlive { pub dest : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pub value : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct TransferAll { pub dest : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , pub keep_alive : :: core :: primitive :: bool , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct ForceUnreserve { pub who : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , pub amount : :: core :: primitive :: u128 , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Transfer some liquid free balance to another account."] # [doc = ""] # [doc = "`transfer` will set the `FreeBalance` of the sender and receiver."] # [doc = "If the sender's account is below the existential deposit as a result"] # [doc = "of the transfer, the account will be reaped."] # [doc = ""] # [doc = "The dispatch origin for this call must be `Signed` by the transactor."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- Dependent on arguments but not critical, given proper implementations for input config"] # [doc = "  types. See related functions below."] # [doc = "- It contains a limited number of reads and writes internally and no complex"] # [doc = "  computation."] # [doc = ""] # [doc = "Related functions:"] # [doc = ""] # [doc = "  - `ensure_can_withdraw` is always called internally but has a bounded complexity."] # [doc = "  - Transferring balances to accounts that did not exist before will cause"] # [doc = "    `T::OnNewAccount::on_new_account` to be called."] # [doc = "  - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`."] # [doc = "  - `transfer_keep_alive` works the same way as `transfer`, but has an additional check"] # [doc = "    that the transfer will not kill the origin account."] pub fn transfer (& self , dest : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , value : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: Payload < Transfer > { :: subxt :: tx :: Payload :: new_static ("Balances" , "transfer" , Transfer { dest , value , } , [255u8 , 181u8 , 144u8 , 248u8 , 64u8 , 167u8 , 5u8 , 134u8 , 208u8 , 20u8 , 223u8 , 103u8 , 235u8 , 35u8 , 66u8 , 184u8 , 27u8 , 94u8 , 176u8 , 60u8 , 233u8 , 236u8 , 145u8 , 218u8 , 44u8 , 138u8 , 240u8 , 224u8 , 16u8 , 193u8 , 220u8 , 95u8 ,]) } # [doc = "Set the balances of a given account."] # [doc = ""] # [doc = "This will alter `FreeBalance` and `ReservedBalance` in storage. it will"] # [doc = "also alter the total issuance of the system (`TotalIssuance`) appropriately."] # [doc = "If the new free or reserved balance is below the existential deposit,"] # [doc = "it will reset the account nonce (`frame_system::AccountNonce`)."] # [doc = ""] # [doc = "The dispatch origin for this call is `root`."] pub fn set_balance (& self , who : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , new_free : :: core :: primitive :: u128 , new_reserved : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: Payload < SetBalance > { :: subxt :: tx :: Payload :: new_static ("Balances" , "set_balance" , SetBalance { who , new_free , new_reserved , } , [174u8 , 34u8 , 80u8 , 252u8 , 193u8 , 51u8 , 228u8 , 236u8 , 234u8 , 16u8 , 173u8 , 214u8 , 122u8 , 21u8 , 254u8 , 7u8 , 49u8 , 176u8 , 18u8 , 128u8 , 122u8 , 68u8 , 72u8 , 181u8 , 119u8 , 90u8 , 167u8 , 46u8 , 203u8 , 220u8 , 109u8 , 110u8 ,]) } # [doc = "Exactly as `transfer`, except the origin must be root and the source account may be"] # [doc = "specified."] # [doc = "## Complexity"] # [doc = "- Same as transfer, but additional read and write because the source account is not"] # [doc = "  assumed to be in the overlay."] pub fn force_transfer (& self , source : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , dest : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , value : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: Payload < ForceTransfer > { :: subxt :: tx :: Payload :: new_static ("Balances" , "force_transfer" , ForceTransfer { source , dest , value , } , [56u8 , 80u8 , 186u8 , 45u8 , 134u8 , 147u8 , 200u8 , 19u8 , 53u8 , 221u8 , 213u8 , 32u8 , 13u8 , 51u8 , 130u8 , 42u8 , 244u8 , 85u8 , 50u8 , 246u8 , 189u8 , 51u8 , 93u8 , 1u8 , 108u8 , 142u8 , 112u8 , 245u8 , 104u8 , 255u8 , 15u8 , 62u8 ,]) } # [doc = "Same as the [`transfer`] call, but with a check that the transfer will not kill the"] # [doc = "origin account."] # [doc = ""] # [doc = "99% of the time you want [`transfer`] instead."] # [doc = ""] # [doc = "[`transfer`]: struct.Pallet.html#method.transfer"] pub fn transfer_keep_alive (& self , dest : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , value : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: Payload < TransferKeepAlive > { :: subxt :: tx :: Payload :: new_static ("Balances" , "transfer_keep_alive" , TransferKeepAlive { dest , value , } , [202u8 , 239u8 , 204u8 , 0u8 , 52u8 , 57u8 , 158u8 , 8u8 , 252u8 , 178u8 , 91u8 , 197u8 , 238u8 , 186u8 , 205u8 , 56u8 , 217u8 , 250u8 , 21u8 , 44u8 , 239u8 , 66u8 , 79u8 , 99u8 , 25u8 , 106u8 , 70u8 , 226u8 , 50u8 , 255u8 , 176u8 , 71u8 ,]) } # [doc = "Transfer the entire transferable balance from the caller account."] # [doc = ""] # [doc = "NOTE: This function only attempts to transfer _transferable_ balances. This means that"] # [doc = "any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be"] # [doc = "transferred by this function. To ensure that this function results in a killed account,"] # [doc = "you might need to prepare the account by removing any reference counters, storage"] # [doc = "deposits, etc..."] # [doc = ""] # [doc = "The dispatch origin of this call must be Signed."] # [doc = ""] # [doc = "- `dest`: The recipient of the transfer."] # [doc = "- `keep_alive`: A boolean to determine if the `transfer_all` operation should send all"] # [doc = "  of the funds the account has, causing the sender account to be killed (false), or"] # [doc = "  transfer everything except at least the existential deposit, which will guarantee to"] # [doc = "  keep the sender account alive (true). ## Complexity"] # [doc = "- O(1). Just like transfer, but reading the user's transferable balance first."] pub fn transfer_all (& self , dest : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , keep_alive : :: core :: primitive :: bool ,) -> :: subxt :: tx :: Payload < TransferAll > { :: subxt :: tx :: Payload :: new_static ("Balances" , "transfer_all" , TransferAll { dest , keep_alive , } , [118u8 , 215u8 , 198u8 , 243u8 , 4u8 , 173u8 , 108u8 , 224u8 , 113u8 , 203u8 , 149u8 , 23u8 , 130u8 , 176u8 , 53u8 , 205u8 , 112u8 , 147u8 , 88u8 , 167u8 , 197u8 , 32u8 , 104u8 , 117u8 , 201u8 , 168u8 , 144u8 , 230u8 , 120u8 , 29u8 , 122u8 , 159u8 ,]) } # [doc = "Unreserve some balance from a user by force."] # [doc = ""] # [doc = "Can only be called by ROOT."] pub fn force_unreserve (& self , who : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , amount : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: Payload < ForceUnreserve > { :: subxt :: tx :: Payload :: new_static ("Balances" , "force_unreserve" , ForceUnreserve { who , amount , } , [39u8 , 229u8 , 111u8 , 44u8 , 147u8 , 80u8 , 7u8 , 26u8 , 185u8 , 121u8 , 149u8 , 25u8 , 151u8 , 37u8 , 124u8 , 46u8 , 108u8 , 136u8 , 167u8 , 145u8 , 103u8 , 65u8 , 33u8 , 168u8 , 36u8 , 214u8 , 126u8 , 237u8 , 180u8 , 61u8 , 108u8 , 110u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_balances :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "An account was created with some free balance."] pub struct Endowed { pub account : :: subxt :: utils :: AccountId32 , pub free_balance : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Endowed { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Endowed" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "An account was removed whose balance was non-zero but below ExistentialDeposit,"] # [doc = "resulting in an outright loss."] pub struct DustLost { pub account : :: subxt :: utils :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for DustLost { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "DustLost" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Transfer succeeded."] pub struct Transfer { pub from : :: subxt :: utils :: AccountId32 , pub to : :: subxt :: utils :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Transfer { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Transfer" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A balance was set by root."] pub struct BalanceSet { pub who : :: subxt :: utils :: AccountId32 , pub free : :: core :: primitive :: u128 , pub reserved : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for BalanceSet { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "BalanceSet" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Some balance was reserved (moved from free to reserved)."] pub struct Reserved { pub who : :: subxt :: utils :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Reserved { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Reserved" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Some balance was unreserved (moved from reserved to free)."] pub struct Unreserved { pub who : :: subxt :: utils :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Unreserved { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Unreserved" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Some balance was moved from the reserve of the first account to the second account."] # [doc = "Final argument indicates the destination balance type."] pub struct ReserveRepatriated { pub from : :: subxt :: utils :: AccountId32 , pub to : :: subxt :: utils :: AccountId32 , pub amount : :: core :: primitive :: u128 , pub destination_status : runtime_types :: frame_support :: traits :: tokens :: misc :: BalanceStatus , } impl :: subxt :: events :: StaticEvent for ReserveRepatriated { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "ReserveRepatriated" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Some amount was deposited (e.g. for transaction fees)."] pub struct Deposit { pub who : :: subxt :: utils :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Deposit { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Deposit" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Some amount was withdrawn from the account (e.g. for transaction fees)."] pub struct Withdraw { pub who : :: subxt :: utils :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Withdraw { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Withdraw" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Some amount was removed from the account (e.g. for misbehavior)."] pub struct Slashed { pub who : :: subxt :: utils :: AccountId32 , pub amount : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Slashed { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Slashed" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " The total units issued in the system."] pub fn total_issuance (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: core :: primitive :: u128 , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("Balances" , "TotalIssuance" , vec ! [] , [1u8 , 206u8 , 252u8 , 237u8 , 6u8 , 30u8 , 20u8 , 232u8 , 164u8 , 115u8 , 51u8 , 156u8 , 156u8 , 206u8 , 241u8 , 187u8 , 44u8 , 84u8 , 25u8 , 164u8 , 235u8 , 20u8 , 86u8 , 242u8 , 124u8 , 23u8 , 28u8 , 140u8 , 26u8 , 73u8 , 231u8 , 51u8 ,]) } # [doc = " The total units of outstanding deactivated balance in the system."] pub fn inactive_issuance (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: core :: primitive :: u128 , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("Balances" , "InactiveIssuance" , vec ! [] , [74u8 , 203u8 , 111u8 , 142u8 , 225u8 , 104u8 , 173u8 , 51u8 , 226u8 , 12u8 , 85u8 , 135u8 , 41u8 , 206u8 , 177u8 , 238u8 , 94u8 , 246u8 , 184u8 , 250u8 , 140u8 , 213u8 , 91u8 , 118u8 , 163u8 , 111u8 , 211u8 , 46u8 , 204u8 , 160u8 , 154u8 , 21u8 ,]) } # [doc = " The Balances pallet example of storing the balance of an account."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```nocompile"] # [doc = "  impl pallet_balances::Config for Runtime {"] # [doc = "    type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>"] # [doc = "  }"] # [doc = " ```"] # [doc = ""] # [doc = " You can also store the balance of an account in the `System` pallet."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```nocompile"] # [doc = "  impl pallet_balances::Config for Runtime {"] # [doc = "   type AccountStore = System"] # [doc = "  }"] # [doc = " ```"] # [doc = ""] # [doc = " But this comes with tradeoffs, storing account balances in the system pallet stores"] # [doc = " `frame_system` data alongside the account data contrary to storing account balances in the"] # [doc = " `Balances` pallet, which uses a `StorageMap` to store balances data only."] # [doc = " NOTE: This is only used in the case that this pallet is used to store balances."] pub fn account (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: utils :: AccountId32 > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: pallet_balances :: AccountData < :: core :: primitive :: u128 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Balances" , "Account" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ())] , [246u8 , 154u8 , 253u8 , 71u8 , 192u8 , 192u8 , 192u8 , 236u8 , 128u8 , 80u8 , 40u8 , 252u8 , 201u8 , 43u8 , 3u8 , 131u8 , 19u8 , 49u8 , 141u8 , 240u8 , 172u8 , 217u8 , 215u8 , 109u8 , 87u8 , 135u8 , 248u8 , 57u8 , 98u8 , 185u8 , 22u8 , 4u8 ,]) } # [doc = " The Balances pallet example of storing the balance of an account."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```nocompile"] # [doc = "  impl pallet_balances::Config for Runtime {"] # [doc = "    type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>"] # [doc = "  }"] # [doc = " ```"] # [doc = ""] # [doc = " You can also store the balance of an account in the `System` pallet."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```nocompile"] # [doc = "  impl pallet_balances::Config for Runtime {"] # [doc = "   type AccountStore = System"] # [doc = "  }"] # [doc = " ```"] # [doc = ""] # [doc = " But this comes with tradeoffs, storing account balances in the system pallet stores"] # [doc = " `frame_system` data alongside the account data contrary to storing account balances in the"] # [doc = " `Balances` pallet, which uses a `StorageMap` to store balances data only."] # [doc = " NOTE: This is only used in the case that this pallet is used to store balances."] pub fn account_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: pallet_balances :: AccountData < :: core :: primitive :: u128 > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Balances" , "Account" , Vec :: new () , [246u8 , 154u8 , 253u8 , 71u8 , 192u8 , 192u8 , 192u8 , 236u8 , 128u8 , 80u8 , 40u8 , 252u8 , 201u8 , 43u8 , 3u8 , 131u8 , 19u8 , 49u8 , 141u8 , 240u8 , 172u8 , 217u8 , 215u8 , 109u8 , 87u8 , 135u8 , 248u8 , 57u8 , 98u8 , 185u8 , 22u8 , 4u8 ,]) } # [doc = " Any liquidity locks on some account balances."] # [doc = " NOTE: Should only be accessed when setting, changing and freeing a lock."] pub fn locks (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: utils :: AccountId32 > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: bounded_collections :: weak_bounded_vec :: WeakBoundedVec < runtime_types :: pallet_balances :: BalanceLock < :: core :: primitive :: u128 > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Balances" , "Locks" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ())] , [216u8 , 253u8 , 87u8 , 73u8 , 24u8 , 218u8 , 35u8 , 0u8 , 244u8 , 134u8 , 195u8 , 58u8 , 255u8 , 64u8 , 153u8 , 212u8 , 210u8 , 232u8 , 4u8 , 122u8 , 90u8 , 212u8 , 136u8 , 14u8 , 127u8 , 232u8 , 8u8 , 192u8 , 40u8 , 233u8 , 18u8 , 250u8 ,]) } # [doc = " Any liquidity locks on some account balances."] # [doc = " NOTE: Should only be accessed when setting, changing and freeing a lock."] pub fn locks_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: bounded_collections :: weak_bounded_vec :: WeakBoundedVec < runtime_types :: pallet_balances :: BalanceLock < :: core :: primitive :: u128 > > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Balances" , "Locks" , Vec :: new () , [216u8 , 253u8 , 87u8 , 73u8 , 24u8 , 218u8 , 35u8 , 0u8 , 244u8 , 134u8 , 195u8 , 58u8 , 255u8 , 64u8 , 153u8 , 212u8 , 210u8 , 232u8 , 4u8 , 122u8 , 90u8 , 212u8 , 136u8 , 14u8 , 127u8 , 232u8 , 8u8 , 192u8 , 40u8 , 233u8 , 18u8 , 250u8 ,]) } # [doc = " Named reserves on some account balances."] pub fn reserves (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: utils :: AccountId32 > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < runtime_types :: pallet_balances :: ReserveData < [:: core :: primitive :: u8 ; 8usize] , :: core :: primitive :: u128 > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Balances" , "Reserves" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ())] , [17u8 , 32u8 , 191u8 , 46u8 , 76u8 , 220u8 , 101u8 , 100u8 , 42u8 , 250u8 , 128u8 , 167u8 , 117u8 , 44u8 , 85u8 , 96u8 , 105u8 , 216u8 , 16u8 , 147u8 , 74u8 , 55u8 , 183u8 , 94u8 , 160u8 , 177u8 , 26u8 , 187u8 , 71u8 , 197u8 , 187u8 , 163u8 ,]) } # [doc = " Named reserves on some account balances."] pub fn reserves_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < runtime_types :: pallet_balances :: ReserveData < [:: core :: primitive :: u8 ; 8usize] , :: core :: primitive :: u128 > > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Balances" , "Reserves" , Vec :: new () , [17u8 , 32u8 , 191u8 , 46u8 , 76u8 , 220u8 , 101u8 , 100u8 , 42u8 , 250u8 , 128u8 , 167u8 , 117u8 , 44u8 , 85u8 , 96u8 , 105u8 , 216u8 , 16u8 , 147u8 , 74u8 , 55u8 , 183u8 , 94u8 , 160u8 , 177u8 , 26u8 , 187u8 , 71u8 , 197u8 , 187u8 , 163u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The minimum amount required to keep an account open."] pub fn existential_deposit (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u128 > { :: subxt :: constants :: Address :: new_static ("Balances" , "ExistentialDeposit" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The maximum number of locks that should exist on an account."] # [doc = " Not strictly enforced, but used for weight estimation."] pub fn max_locks (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u32 > { :: subxt :: constants :: Address :: new_static ("Balances" , "MaxLocks" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The maximum number of named reserves that can exist on an account."] pub fn max_reserves (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u32 > { :: subxt :: constants :: Address :: new_static ("Balances" , "MaxReserves" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod aura { use super :: root_mod ; use super :: runtime_types ; pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " The current authority set."] pub fn authorities (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < runtime_types :: sp_consensus_aura :: sr25519 :: app_sr25519 :: Public > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("Aura" , "Authorities" , vec ! [] , [199u8 , 89u8 , 94u8 , 48u8 , 249u8 , 35u8 , 105u8 , 90u8 , 15u8 , 86u8 , 218u8 , 85u8 , 22u8 , 236u8 , 228u8 , 36u8 , 137u8 , 64u8 , 236u8 , 171u8 , 242u8 , 217u8 , 91u8 , 240u8 , 205u8 , 205u8 , 226u8 , 16u8 , 147u8 , 235u8 , 181u8 , 41u8 ,]) } # [doc = " The current slot of this block."] # [doc = ""] # [doc = " This will be set in `on_initialize`."] pub fn current_slot (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: sp_consensus_slots :: Slot , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("Aura" , "CurrentSlot" , vec ! [] , [139u8 , 237u8 , 185u8 , 137u8 , 251u8 , 179u8 , 69u8 , 167u8 , 133u8 , 168u8 , 204u8 , 64u8 , 178u8 , 123u8 , 92u8 , 250u8 , 119u8 , 190u8 , 208u8 , 178u8 , 208u8 , 176u8 , 124u8 , 187u8 , 74u8 , 165u8 , 33u8 , 78u8 , 161u8 , 206u8 , 8u8 , 108u8 ,]) } } } } pub mod im_online { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Heartbeat { pub heartbeat : runtime_types :: pallet_im_online :: Heartbeat < :: core :: primitive :: u32 > , pub signature : runtime_types :: pallet_im_online :: sr25519 :: app_sr25519 :: Signature , } pub struct TransactionApi ; impl TransactionApi { # [doc = "## Complexity:"] # [doc = "- `O(K + E)` where K is length of `Keys` (heartbeat.validators_len) and E is length of"] # [doc = "  `heartbeat.network_state.external_address`"] # [doc = "  - `O(K)`: decoding of length `K`"] # [doc = "  - `O(E)`: decoding/encoding of length `E`"] pub fn heartbeat (& self , heartbeat : runtime_types :: pallet_im_online :: Heartbeat < :: core :: primitive :: u32 > , signature : runtime_types :: pallet_im_online :: sr25519 :: app_sr25519 :: Signature ,) -> :: subxt :: tx :: Payload < Heartbeat > { :: subxt :: tx :: Payload :: new_static ("ImOnline" , "heartbeat" , Heartbeat { heartbeat , signature , } , [212u8 , 23u8 , 174u8 , 246u8 , 60u8 , 220u8 , 178u8 , 137u8 , 53u8 , 146u8 , 165u8 , 225u8 , 179u8 , 209u8 , 233u8 , 152u8 , 129u8 , 210u8 , 126u8 , 32u8 , 216u8 , 22u8 , 76u8 , 196u8 , 255u8 , 128u8 , 246u8 , 161u8 , 30u8 , 186u8 , 249u8 , 34u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_im_online :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A new heartbeat was received from `AuthorityId`."] pub struct HeartbeatReceived { pub authority_id : runtime_types :: pallet_im_online :: sr25519 :: app_sr25519 :: Public , } impl :: subxt :: events :: StaticEvent for HeartbeatReceived { const PALLET : & 'static str = "ImOnline" ; const EVENT : & 'static str = "HeartbeatReceived" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "At the end of the session, no offence was committed."] pub struct AllGood ; impl :: subxt :: events :: StaticEvent for AllGood { const PALLET : & 'static str = "ImOnline" ; const EVENT : & 'static str = "AllGood" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "At the end of the session, at least one validator was found to be offline."] pub struct SomeOffline { pub offline : :: std :: vec :: Vec < (:: subxt :: utils :: AccountId32 , () ,) > , } impl :: subxt :: events :: StaticEvent for SomeOffline { const PALLET : & 'static str = "ImOnline" ; const EVENT : & 'static str = "SomeOffline" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " The block number after which it's ok to send heartbeats in the current"] # [doc = " session."] # [doc = ""] # [doc = " At the beginning of each session we set this to a value that should fall"] # [doc = " roughly in the middle of the session duration. The idea is to first wait for"] # [doc = " the validators to produce a block in the current session, so that the"] # [doc = " heartbeat later on will not be necessary."] # [doc = ""] # [doc = " This value will only be used as a fallback if we fail to get a proper session"] # [doc = " progress estimate from `NextSessionRotation`, as those estimates should be"] # [doc = " more accurate then the value we calculate for `HeartbeatAfter`."] pub fn heartbeat_after (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: core :: primitive :: u32 , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("ImOnline" , "HeartbeatAfter" , vec ! [] , [108u8 , 100u8 , 85u8 , 198u8 , 226u8 , 122u8 , 94u8 , 225u8 , 97u8 , 154u8 , 135u8 , 95u8 , 106u8 , 28u8 , 185u8 , 78u8 , 192u8 , 196u8 , 35u8 , 191u8 , 12u8 , 19u8 , 163u8 , 46u8 , 232u8 , 235u8 , 193u8 , 81u8 , 126u8 , 204u8 , 25u8 , 228u8 ,]) } # [doc = " The current set of keys that may issue a heartbeat."] pub fn keys (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: bounded_collections :: weak_bounded_vec :: WeakBoundedVec < runtime_types :: pallet_im_online :: sr25519 :: app_sr25519 :: Public > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("ImOnline" , "Keys" , vec ! [] , [6u8 , 198u8 , 221u8 , 58u8 , 14u8 , 166u8 , 245u8 , 103u8 , 191u8 , 20u8 , 69u8 , 233u8 , 147u8 , 245u8 , 24u8 , 64u8 , 207u8 , 180u8 , 39u8 , 208u8 , 252u8 , 236u8 , 247u8 , 112u8 , 187u8 , 97u8 , 70u8 , 11u8 , 248u8 , 148u8 , 208u8 , 106u8 ,]) } # [doc = " For each session index, we keep a mapping of `SessionIndex` and `AuthIndex` to"] # [doc = " `WrapperOpaque<BoundedOpaqueNetworkState>`."] pub fn received_heartbeats (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > , _1 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: frame_support :: traits :: misc :: WrapperOpaque < runtime_types :: pallet_im_online :: BoundedOpaqueNetworkState > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("ImOnline" , "ReceivedHeartbeats" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ()) , :: subxt :: storage :: address :: make_static_storage_map_key (_1 . borrow ())] , [233u8 , 128u8 , 140u8 , 233u8 , 55u8 , 146u8 , 172u8 , 54u8 , 54u8 , 57u8 , 141u8 , 106u8 , 168u8 , 59u8 , 147u8 , 253u8 , 119u8 , 48u8 , 50u8 , 251u8 , 242u8 , 109u8 , 251u8 , 2u8 , 136u8 , 80u8 , 146u8 , 121u8 , 180u8 , 219u8 , 245u8 , 37u8 ,]) } # [doc = " For each session index, we keep a mapping of `SessionIndex` and `AuthIndex` to"] # [doc = " `WrapperOpaque<BoundedOpaqueNetworkState>`."] pub fn received_heartbeats_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: frame_support :: traits :: misc :: WrapperOpaque < runtime_types :: pallet_im_online :: BoundedOpaqueNetworkState > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("ImOnline" , "ReceivedHeartbeats" , Vec :: new () , [233u8 , 128u8 , 140u8 , 233u8 , 55u8 , 146u8 , 172u8 , 54u8 , 54u8 , 57u8 , 141u8 , 106u8 , 168u8 , 59u8 , 147u8 , 253u8 , 119u8 , 48u8 , 50u8 , 251u8 , 242u8 , 109u8 , 251u8 , 2u8 , 136u8 , 80u8 , 146u8 , 121u8 , 180u8 , 219u8 , 245u8 , 37u8 ,]) } # [doc = " For each session index, we keep a mapping of `ValidatorId<T>` to the"] # [doc = " number of blocks authored by the given authority."] pub fn authored_blocks (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > , _1 : impl :: std :: borrow :: Borrow < :: subxt :: utils :: AccountId32 > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: core :: primitive :: u32 , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("ImOnline" , "AuthoredBlocks" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ()) , :: subxt :: storage :: address :: make_static_storage_map_key (_1 . borrow ())] , [50u8 , 4u8 , 242u8 , 240u8 , 247u8 , 184u8 , 114u8 , 245u8 , 233u8 , 170u8 , 24u8 , 197u8 , 18u8 , 245u8 , 8u8 , 28u8 , 33u8 , 115u8 , 166u8 , 245u8 , 221u8 , 223u8 , 56u8 , 144u8 , 33u8 , 139u8 , 10u8 , 227u8 , 228u8 , 223u8 , 103u8 , 151u8 ,]) } # [doc = " For each session index, we keep a mapping of `ValidatorId<T>` to the"] # [doc = " number of blocks authored by the given authority."] pub fn authored_blocks_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: core :: primitive :: u32 , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("ImOnline" , "AuthoredBlocks" , Vec :: new () , [50u8 , 4u8 , 242u8 , 240u8 , 247u8 , 184u8 , 114u8 , 245u8 , 233u8 , 170u8 , 24u8 , 197u8 , 18u8 , 245u8 , 8u8 , 28u8 , 33u8 , 115u8 , 166u8 , 245u8 , 221u8 , 223u8 , 56u8 , 144u8 , 33u8 , 139u8 , 10u8 , 227u8 , 228u8 , 223u8 , 103u8 , 151u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " A configuration for base priority of unsigned transactions."] # [doc = ""] # [doc = " This is exposed so that it can be tuned for particular runtime, when"] # [doc = " multiple pallets send unsigned transactions."] pub fn unsigned_priority (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u64 > { :: subxt :: constants :: Address :: new_static ("ImOnline" , "UnsignedPriority" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } } } } pub mod transaction_payment { use super :: root_mod ; use super :: runtime_types ; # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_transaction_payment :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,"] # [doc = "has been paid by `who`."] pub struct TransactionFeePaid { pub who : :: subxt :: utils :: AccountId32 , pub actual_fee : :: core :: primitive :: u128 , pub tip : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for TransactionFeePaid { const PALLET : & 'static str = "TransactionPayment" ; const EVENT : & 'static str = "TransactionFeePaid" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { pub fn next_fee_multiplier (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: sp_arithmetic :: fixed_point :: FixedU128 , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("TransactionPayment" , "NextFeeMultiplier" , vec ! [] , [210u8 , 0u8 , 206u8 , 165u8 , 183u8 , 10u8 , 206u8 , 52u8 , 14u8 , 90u8 , 218u8 , 197u8 , 189u8 , 125u8 , 113u8 , 216u8 , 52u8 , 161u8 , 45u8 , 24u8 , 245u8 , 237u8 , 121u8 , 41u8 , 106u8 , 29u8 , 45u8 , 129u8 , 250u8 , 203u8 , 206u8 , 180u8 ,]) } pub fn storage_version (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: pallet_transaction_payment :: Releases , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("TransactionPayment" , "StorageVersion" , vec ! [] , [219u8 , 243u8 , 82u8 , 176u8 , 65u8 , 5u8 , 132u8 , 114u8 , 8u8 , 82u8 , 176u8 , 200u8 , 97u8 , 150u8 , 177u8 , 164u8 , 166u8 , 11u8 , 34u8 , 12u8 , 12u8 , 198u8 , 58u8 , 191u8 , 186u8 , 221u8 , 221u8 , 119u8 , 181u8 , 253u8 , 154u8 , 228u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " A fee mulitplier for `Operational` extrinsics to compute \"virtual tip\" to boost their"] # [doc = " `priority`"] # [doc = ""] # [doc = " This value is multipled by the `final_fee` to obtain a \"virtual tip\" that is later"] # [doc = " added to a tip component in regular `priority` calculations."] # [doc = " It means that a `Normal` transaction can front-run a similarly-sized `Operational`"] # [doc = " extrinsic (with no tip), by including a tip value greater than the virtual tip."] # [doc = ""] # [doc = " ```rust,ignore"] # [doc = " // For `Normal`"] # [doc = " let priority = priority_calc(tip);"] # [doc = ""] # [doc = " // For `Operational`"] # [doc = " let virtual_tip = (inclusion_fee + tip) * OperationalFeeMultiplier;"] # [doc = " let priority = priority_calc(tip + virtual_tip);"] # [doc = " ```"] # [doc = ""] # [doc = " Note that since we use `final_fee` the multiplier applies also to the regular `tip`"] # [doc = " sent with the transaction. So, not only does the transaction get a priority bump based"] # [doc = " on the `inclusion_fee`, but we also amplify the impact of tips applied to `Operational`"] # [doc = " transactions."] pub fn operational_fee_multiplier (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u8 > { :: subxt :: constants :: Address :: new_static ("TransactionPayment" , "OperationalFeeMultiplier" , [141u8 , 130u8 , 11u8 , 35u8 , 226u8 , 114u8 , 92u8 , 179u8 , 168u8 , 110u8 , 28u8 , 91u8 , 221u8 , 64u8 , 4u8 , 148u8 , 201u8 , 193u8 , 185u8 , 66u8 , 226u8 , 114u8 , 97u8 , 79u8 , 62u8 , 212u8 , 202u8 , 114u8 , 237u8 , 228u8 , 183u8 , 165u8 ,]) } } } } pub mod authorship { use super :: root_mod ; use super :: runtime_types ; pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " Author of current block."] pub fn author (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: subxt :: utils :: AccountId32 , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: Address :: new_static ("Authorship" , "Author" , vec ! [] , [149u8 , 42u8 , 33u8 , 147u8 , 190u8 , 207u8 , 174u8 , 227u8 , 190u8 , 110u8 , 25u8 , 131u8 , 5u8 , 167u8 , 237u8 , 188u8 , 188u8 , 33u8 , 177u8 , 126u8 , 181u8 , 49u8 , 126u8 , 118u8 , 46u8 , 128u8 , 154u8 , 95u8 , 15u8 , 91u8 , 103u8 , 113u8 ,]) } } } } pub mod offences { use super :: root_mod ; use super :: runtime_types ; # [doc = "Events type."] pub type Event = runtime_types :: pallet_offences :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "There is an offence reported of the given `kind` happened at the `session_index` and"] # [doc = "(kind-specific) time slot. This event is not deposited for duplicate slashes."] # [doc = "\\[kind, timeslot\\]."] pub struct Offence { pub kind : [:: core :: primitive :: u8 ; 16usize] , pub timeslot : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: events :: StaticEvent for Offence { const PALLET : & 'static str = "Offences" ; const EVENT : & 'static str = "Offence" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " The primary structure that holds all offence records keyed by report identifiers."] pub fn reports (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: utils :: H256 > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: sp_staking :: offence :: OffenceDetails < :: subxt :: utils :: AccountId32 , (:: subxt :: utils :: AccountId32 , () ,) > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Offences" , "Reports" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ())] , [168u8 , 5u8 , 232u8 , 75u8 , 28u8 , 231u8 , 107u8 , 52u8 , 186u8 , 140u8 , 79u8 , 242u8 , 15u8 , 201u8 , 83u8 , 78u8 , 146u8 , 109u8 , 192u8 , 106u8 , 253u8 , 106u8 , 91u8 , 67u8 , 224u8 , 69u8 , 176u8 , 189u8 , 243u8 , 46u8 , 12u8 , 211u8 ,]) } # [doc = " The primary structure that holds all offence records keyed by report identifiers."] pub fn reports_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: sp_staking :: offence :: OffenceDetails < :: subxt :: utils :: AccountId32 , (:: subxt :: utils :: AccountId32 , () ,) > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Offences" , "Reports" , Vec :: new () , [168u8 , 5u8 , 232u8 , 75u8 , 28u8 , 231u8 , 107u8 , 52u8 , 186u8 , 140u8 , 79u8 , 242u8 , 15u8 , 201u8 , 83u8 , 78u8 , 146u8 , 109u8 , 192u8 , 106u8 , 253u8 , 106u8 , 91u8 , 67u8 , 224u8 , 69u8 , 176u8 , 189u8 , 243u8 , 46u8 , 12u8 , 211u8 ,]) } # [doc = " A vector of reports of the same kind that happened at the same time slot."] pub fn concurrent_reports_index (& self , _0 : impl :: std :: borrow :: Borrow < [:: core :: primitive :: u8 ; 16usize] > , _1 : impl :: std :: borrow :: Borrow < [:: core :: primitive :: u8] > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: std :: vec :: Vec < :: subxt :: utils :: H256 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Offences" , "ConcurrentReportsIndex" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ()) , :: subxt :: storage :: address :: make_static_storage_map_key (_1 . borrow ())] , [106u8 , 21u8 , 104u8 , 5u8 , 4u8 , 66u8 , 28u8 , 70u8 , 161u8 , 195u8 , 238u8 , 28u8 , 69u8 , 241u8 , 221u8 , 113u8 , 140u8 , 103u8 , 181u8 , 143u8 , 60u8 , 177u8 , 13u8 , 129u8 , 224u8 , 149u8 , 77u8 , 32u8 , 75u8 , 74u8 , 101u8 , 65u8 ,]) } # [doc = " A vector of reports of the same kind that happened at the same time slot."] pub fn concurrent_reports_index_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: std :: vec :: Vec < :: subxt :: utils :: H256 > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Offences" , "ConcurrentReportsIndex" , Vec :: new () , [106u8 , 21u8 , 104u8 , 5u8 , 4u8 , 66u8 , 28u8 , 70u8 , 161u8 , 195u8 , 238u8 , 28u8 , 69u8 , 241u8 , 221u8 , 113u8 , 140u8 , 103u8 , 181u8 , 143u8 , 60u8 , 177u8 , 13u8 , 129u8 , 224u8 , 149u8 , 77u8 , 32u8 , 75u8 , 74u8 , 101u8 , 65u8 ,]) } # [doc = " Enumerates all reports of a kind along with the time they happened."] # [doc = ""] # [doc = " All reports are sorted by the time of offence."] # [doc = ""] # [doc = " Note that the actual type of this mapping is `Vec<u8>`, this is because values of"] # [doc = " different types are not supported at the moment so we are doing the manual serialization."] pub fn reports_by_kind_index (& self , _0 : impl :: std :: borrow :: Borrow < [:: core :: primitive :: u8 ; 16usize] > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: std :: vec :: Vec < :: core :: primitive :: u8 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Offences" , "ReportsByKindIndex" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ())] , [162u8 , 66u8 , 131u8 , 48u8 , 250u8 , 237u8 , 179u8 , 214u8 , 36u8 , 137u8 , 226u8 , 136u8 , 120u8 , 61u8 , 215u8 , 43u8 , 164u8 , 50u8 , 91u8 , 164u8 , 20u8 , 96u8 , 189u8 , 100u8 , 242u8 , 106u8 , 21u8 , 136u8 , 98u8 , 215u8 , 180u8 , 145u8 ,]) } # [doc = " Enumerates all reports of a kind along with the time they happened."] # [doc = ""] # [doc = " All reports are sorted by the time of offence."] # [doc = ""] # [doc = " Note that the actual type of this mapping is `Vec<u8>`, this is because values of"] # [doc = " different types are not supported at the moment so we are doing the manual serialization."] pub fn reports_by_kind_index_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: std :: vec :: Vec < :: core :: primitive :: u8 > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Offences" , "ReportsByKindIndex" , Vec :: new () , [162u8 , 66u8 , 131u8 , 48u8 , 250u8 , 237u8 , 179u8 , 214u8 , 36u8 , 137u8 , 226u8 , 136u8 , 120u8 , 61u8 , 215u8 , 43u8 , 164u8 , 50u8 , 91u8 , 164u8 , 20u8 , 96u8 , 189u8 , 100u8 , 242u8 , 106u8 , 21u8 , 136u8 , 98u8 , 215u8 , 180u8 , 145u8 ,]) } } } } pub mod session { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct SetKeys { pub keys : runtime_types :: golden_gate_runtime_testnet :: opaque :: SessionKeys , pub proof : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct PurgeKeys ; pub struct TransactionApi ; impl TransactionApi { # [doc = "Sets the session key(s) of the function caller to `keys`."] # [doc = "Allows an account to set its session key prior to becoming a validator."] # [doc = "This doesn't take effect until the next session."] # [doc = ""] # [doc = "The dispatch origin of this function must be signed."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is"] # [doc = "  fixed."] pub fn set_keys (& self , keys : runtime_types :: golden_gate_runtime_testnet :: opaque :: SessionKeys , proof : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: tx :: Payload < SetKeys > { :: subxt :: tx :: Payload :: new_static ("Session" , "set_keys" , SetKeys { keys , proof , } , [234u8 , 233u8 , 94u8 , 115u8 , 55u8 , 32u8 , 218u8 , 51u8 , 88u8 , 247u8 , 193u8 , 218u8 , 74u8 , 144u8 , 50u8 , 212u8 , 196u8 , 213u8 , 44u8 , 116u8 , 153u8 , 101u8 , 78u8 , 85u8 , 108u8 , 45u8 , 9u8 , 137u8 , 212u8 , 77u8 , 16u8 , 14u8 ,]) } # [doc = "Removes any session key(s) of the function caller."] # [doc = ""] # [doc = "This doesn't take effect until the next session."] # [doc = ""] # [doc = "The dispatch origin of this function must be Signed and the account must be either be"] # [doc = "convertible to a validator ID using the chain's typical addressing system (this usually"] # [doc = "means being a controller account) or directly convertible into a validator ID (which"] # [doc = "usually means being a stash account)."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)` in number of key types. Actual cost depends on the number of length of"] # [doc = "  `T::Keys::key_ids()` which is fixed."] pub fn purge_keys (& self ,) -> :: subxt :: tx :: Payload < PurgeKeys > { :: subxt :: tx :: Payload :: new_static ("Session" , "purge_keys" , PurgeKeys { } , [200u8 , 255u8 , 4u8 , 213u8 , 188u8 , 92u8 , 99u8 , 116u8 , 163u8 , 152u8 , 29u8 , 35u8 , 133u8 , 119u8 , 246u8 , 44u8 , 91u8 , 31u8 , 145u8 , 23u8 , 213u8 , 64u8 , 71u8 , 242u8 , 207u8 , 239u8 , 231u8 , 37u8 , 61u8 , 63u8 , 190u8 , 35u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_session :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "New session has happened. Note that the argument is the session index, not the"] # [doc = "block number as the type might suggest."] pub struct NewSession { pub session_index : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for NewSession { const PALLET : & 'static str = "Session" ; const EVENT : & 'static str = "NewSession" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " The current set of validators."] pub fn validators (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: std :: vec :: Vec < :: subxt :: utils :: AccountId32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("Session" , "Validators" , vec ! [] , [144u8 , 235u8 , 200u8 , 43u8 , 151u8 , 57u8 , 147u8 , 172u8 , 201u8 , 202u8 , 242u8 , 96u8 , 57u8 , 76u8 , 124u8 , 77u8 , 42u8 , 113u8 , 218u8 , 220u8 , 230u8 , 32u8 , 151u8 , 152u8 , 172u8 , 106u8 , 60u8 , 227u8 , 122u8 , 118u8 , 137u8 , 68u8 ,]) } # [doc = " Current index of the session."] pub fn current_index (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: core :: primitive :: u32 , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("Session" , "CurrentIndex" , vec ! [] , [148u8 , 179u8 , 159u8 , 15u8 , 197u8 , 95u8 , 214u8 , 30u8 , 209u8 , 251u8 , 183u8 , 231u8 , 91u8 , 25u8 , 181u8 , 191u8 , 143u8 , 252u8 , 227u8 , 80u8 , 159u8 , 66u8 , 194u8 , 67u8 , 113u8 , 74u8 , 111u8 , 91u8 , 218u8 , 187u8 , 130u8 , 40u8 ,]) } # [doc = " True if the underlying economic identities or weighting behind the validators"] # [doc = " has changed in the queued validator set."] pub fn queued_changed (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: core :: primitive :: bool , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("Session" , "QueuedChanged" , vec ! [] , [105u8 , 140u8 , 235u8 , 218u8 , 96u8 , 100u8 , 252u8 , 10u8 , 58u8 , 221u8 , 244u8 , 251u8 , 67u8 , 91u8 , 80u8 , 202u8 , 152u8 , 42u8 , 50u8 , 113u8 , 200u8 , 247u8 , 59u8 , 213u8 , 77u8 , 195u8 , 1u8 , 150u8 , 220u8 , 18u8 , 245u8 , 46u8 ,]) } # [doc = " The queued keys for the next session. When the next session begins, these keys"] # [doc = " will be used to determine the validator's session keys."] pub fn queued_keys (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: std :: vec :: Vec < (:: subxt :: utils :: AccountId32 , runtime_types :: golden_gate_runtime_testnet :: opaque :: SessionKeys ,) > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("Session" , "QueuedKeys" , vec ! [] , [66u8 , 57u8 , 122u8 , 202u8 , 147u8 , 77u8 , 25u8 , 182u8 , 113u8 , 110u8 , 52u8 , 116u8 , 157u8 , 179u8 , 28u8 , 86u8 , 134u8 , 243u8 , 106u8 , 204u8 , 114u8 , 190u8 , 56u8 , 181u8 , 1u8 , 110u8 , 249u8 , 105u8 , 147u8 , 54u8 , 17u8 , 225u8 ,]) } # [doc = " Indices of disabled validators."] # [doc = ""] # [doc = " The vec is always kept sorted so that we can find whether a given validator is"] # [doc = " disabled using binary search. It gets cleared when `on_session_ending` returns"] # [doc = " a new set of identities."] pub fn disabled_validators (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: std :: vec :: Vec < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("Session" , "DisabledValidators" , vec ! [] , [135u8 , 22u8 , 22u8 , 97u8 , 82u8 , 217u8 , 144u8 , 141u8 , 121u8 , 240u8 , 189u8 , 16u8 , 176u8 , 88u8 , 177u8 , 31u8 , 20u8 , 242u8 , 73u8 , 104u8 , 11u8 , 110u8 , 214u8 , 34u8 , 52u8 , 217u8 , 106u8 , 33u8 , 174u8 , 174u8 , 198u8 , 84u8 ,]) } # [doc = " The next session keys for a validator."] pub fn next_keys (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: utils :: AccountId32 > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: golden_gate_runtime_testnet :: opaque :: SessionKeys , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Session" , "NextKeys" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ())] , [191u8 , 177u8 , 251u8 , 127u8 , 169u8 , 231u8 , 44u8 , 99u8 , 95u8 , 215u8 , 86u8 , 30u8 , 89u8 , 201u8 , 247u8 , 100u8 , 253u8 , 75u8 , 57u8 , 224u8 , 164u8 , 123u8 , 159u8 , 106u8 , 2u8 , 230u8 , 199u8 , 223u8 , 140u8 , 140u8 , 108u8 , 145u8 ,]) } # [doc = " The next session keys for a validator."] pub fn next_keys_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: golden_gate_runtime_testnet :: opaque :: SessionKeys , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Session" , "NextKeys" , Vec :: new () , [191u8 , 177u8 , 251u8 , 127u8 , 169u8 , 231u8 , 44u8 , 99u8 , 95u8 , 215u8 , 86u8 , 30u8 , 89u8 , 201u8 , 247u8 , 100u8 , 253u8 , 75u8 , 57u8 , 224u8 , 164u8 , 123u8 , 159u8 , 106u8 , 2u8 , 230u8 , 199u8 , 223u8 , 140u8 , 140u8 , 108u8 , 145u8 ,]) } # [doc = " The owner of a key. The key is the `KeyTypeId` + the encoded key."] pub fn key_owner (& self , _0 : impl :: std :: borrow :: Borrow < runtime_types :: sp_core :: crypto :: KeyTypeId > , _1 : impl :: std :: borrow :: Borrow < [:: core :: primitive :: u8] > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: subxt :: utils :: AccountId32 , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Session" , "KeyOwner" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ()) , :: subxt :: storage :: address :: make_static_storage_map_key (_1 . borrow ())] , [4u8 , 91u8 , 25u8 , 84u8 , 250u8 , 201u8 , 174u8 , 129u8 , 201u8 , 58u8 , 197u8 , 199u8 , 137u8 , 240u8 , 118u8 , 33u8 , 99u8 , 2u8 , 195u8 , 57u8 , 53u8 , 172u8 , 0u8 , 148u8 , 203u8 , 144u8 , 149u8 , 64u8 , 135u8 , 254u8 , 242u8 , 215u8 ,]) } # [doc = " The owner of a key. The key is the `KeyTypeId` + the encoded key."] pub fn key_owner_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: subxt :: utils :: AccountId32 , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Session" , "KeyOwner" , Vec :: new () , [4u8 , 91u8 , 25u8 , 84u8 , 250u8 , 201u8 , 174u8 , 129u8 , 201u8 , 58u8 , 197u8 , 199u8 , 137u8 , 240u8 , 118u8 , 33u8 , 99u8 , 2u8 , 195u8 , 57u8 , 53u8 , 172u8 , 0u8 , 148u8 , 203u8 , 144u8 , 149u8 , 64u8 , 135u8 , 254u8 , 242u8 , 215u8 ,]) } } } } pub mod grandpa { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct ReportEquivocation { pub equivocation_proof : :: std :: boxed :: Box < runtime_types :: sp_finality_grandpa :: EquivocationProof < :: subxt :: utils :: H256 , :: core :: primitive :: u32 > > , pub key_owner_proof : runtime_types :: sp_session :: MembershipProof , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct ReportEquivocationUnsigned { pub equivocation_proof : :: std :: boxed :: Box < runtime_types :: sp_finality_grandpa :: EquivocationProof < :: subxt :: utils :: H256 , :: core :: primitive :: u32 > > , pub key_owner_proof : runtime_types :: sp_session :: MembershipProof , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct NoteStalled { pub delay : :: core :: primitive :: u32 , pub best_finalized_block_number : :: core :: primitive :: u32 , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Report voter equivocation/misbehavior. This method will verify the"] # [doc = "equivocation proof and validate the given key ownership proof"] # [doc = "against the extracted offender. If both are valid, the offence"] # [doc = "will be reported."] pub fn report_equivocation (& self , equivocation_proof : runtime_types :: sp_finality_grandpa :: EquivocationProof < :: subxt :: utils :: H256 , :: core :: primitive :: u32 > , key_owner_proof : runtime_types :: sp_session :: MembershipProof ,) -> :: subxt :: tx :: Payload < ReportEquivocation > { :: subxt :: tx :: Payload :: new_static ("Grandpa" , "report_equivocation" , ReportEquivocation { equivocation_proof : :: std :: boxed :: Box :: new (equivocation_proof) , key_owner_proof , } , [156u8 , 162u8 , 189u8 , 89u8 , 60u8 , 156u8 , 129u8 , 176u8 , 62u8 , 35u8 , 214u8 , 7u8 , 68u8 , 245u8 , 130u8 , 117u8 , 30u8 , 3u8 , 73u8 , 218u8 , 142u8 , 82u8 , 13u8 , 141u8 , 124u8 , 19u8 , 53u8 , 138u8 , 70u8 , 4u8 , 40u8 , 32u8 ,]) } # [doc = "Report voter equivocation/misbehavior. This method will verify the"] # [doc = "equivocation proof and validate the given key ownership proof"] # [doc = "against the extracted offender. If both are valid, the offence"] # [doc = "will be reported."] # [doc = ""] # [doc = "This extrinsic must be called unsigned and it is expected that only"] # [doc = "block authors will call it (validated in `ValidateUnsigned`), as such"] # [doc = "if the block author is defined it will be defined as the equivocation"] # [doc = "reporter."] pub fn report_equivocation_unsigned (& self , equivocation_proof : runtime_types :: sp_finality_grandpa :: EquivocationProof < :: subxt :: utils :: H256 , :: core :: primitive :: u32 > , key_owner_proof : runtime_types :: sp_session :: MembershipProof ,) -> :: subxt :: tx :: Payload < ReportEquivocationUnsigned > { :: subxt :: tx :: Payload :: new_static ("Grandpa" , "report_equivocation_unsigned" , ReportEquivocationUnsigned { equivocation_proof : :: std :: boxed :: Box :: new (equivocation_proof) , key_owner_proof , } , [166u8 , 26u8 , 217u8 , 185u8 , 215u8 , 37u8 , 174u8 , 170u8 , 137u8 , 160u8 , 151u8 , 43u8 , 246u8 , 86u8 , 58u8 , 18u8 , 248u8 , 73u8 , 99u8 , 161u8 , 158u8 , 93u8 , 212u8 , 186u8 , 224u8 , 253u8 , 234u8 , 18u8 , 151u8 , 111u8 , 227u8 , 249u8 ,]) } # [doc = "Note that the current authority set of the GRANDPA finality gadget has stalled."] # [doc = ""] # [doc = "This will trigger a forced authority set change at the beginning of the next session, to"] # [doc = "be enacted `delay` blocks after that. The `delay` should be high enough to safely assume"] # [doc = "that the block signalling the forced change will not be re-orged e.g. 1000 blocks."] # [doc = "The block production rate (which may be slowed down because of finality lagging) should"] # [doc = "be taken into account when choosing the `delay`. The GRANDPA voters based on the new"] # [doc = "authority will start voting on top of `best_finalized_block_number` for new finalized"] # [doc = "blocks. `best_finalized_block_number` should be the highest of the latest finalized"] # [doc = "block of all validators of the new authority set."] # [doc = ""] # [doc = "Only callable by root."] pub fn note_stalled (& self , delay : :: core :: primitive :: u32 , best_finalized_block_number : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: Payload < NoteStalled > { :: subxt :: tx :: Payload :: new_static ("Grandpa" , "note_stalled" , NoteStalled { delay , best_finalized_block_number , } , [197u8 , 236u8 , 137u8 , 32u8 , 46u8 , 200u8 , 144u8 , 13u8 , 89u8 , 181u8 , 235u8 , 73u8 , 167u8 , 131u8 , 174u8 , 93u8 , 42u8 , 136u8 , 238u8 , 59u8 , 129u8 , 60u8 , 83u8 , 100u8 , 5u8 , 182u8 , 99u8 , 250u8 , 145u8 , 180u8 , 1u8 , 199u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_grandpa :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "New authority set has been applied."] pub struct NewAuthorities { pub authority_set : :: std :: vec :: Vec < (runtime_types :: sp_finality_grandpa :: app :: Public , :: core :: primitive :: u64 ,) > , } impl :: subxt :: events :: StaticEvent for NewAuthorities { const PALLET : & 'static str = "Grandpa" ; const EVENT : & 'static str = "NewAuthorities" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Current authority set has been paused."] pub struct Paused ; impl :: subxt :: events :: StaticEvent for Paused { const PALLET : & 'static str = "Grandpa" ; const EVENT : & 'static str = "Paused" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Current authority set has been resumed."] pub struct Resumed ; impl :: subxt :: events :: StaticEvent for Resumed { const PALLET : & 'static str = "Grandpa" ; const EVENT : & 'static str = "Resumed" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " State of the current authority set."] pub fn state (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: pallet_grandpa :: StoredState < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("Grandpa" , "State" , vec ! [] , [211u8 , 149u8 , 114u8 , 217u8 , 206u8 , 194u8 , 115u8 , 67u8 , 12u8 , 218u8 , 246u8 , 213u8 , 208u8 , 29u8 , 216u8 , 104u8 , 2u8 , 39u8 , 123u8 , 172u8 , 252u8 , 210u8 , 52u8 , 129u8 , 147u8 , 237u8 , 244u8 , 68u8 , 252u8 , 169u8 , 97u8 , 148u8 ,]) } # [doc = " Pending change: (signaled at, scheduled change)."] pub fn pending_change (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: pallet_grandpa :: StoredPendingChange < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: Address :: new_static ("Grandpa" , "PendingChange" , vec ! [] , [178u8 , 24u8 , 140u8 , 7u8 , 8u8 , 196u8 , 18u8 , 58u8 , 3u8 , 226u8 , 181u8 , 47u8 , 155u8 , 160u8 , 70u8 , 12u8 , 75u8 , 189u8 , 38u8 , 255u8 , 104u8 , 141u8 , 64u8 , 34u8 , 134u8 , 201u8 , 102u8 , 21u8 , 75u8 , 81u8 , 218u8 , 60u8 ,]) } # [doc = " next block number where we can force a change."] pub fn next_forced (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: core :: primitive :: u32 , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: Address :: new_static ("Grandpa" , "NextForced" , vec ! [] , [99u8 , 43u8 , 245u8 , 201u8 , 60u8 , 9u8 , 122u8 , 99u8 , 188u8 , 29u8 , 67u8 , 6u8 , 193u8 , 133u8 , 179u8 , 67u8 , 202u8 , 208u8 , 62u8 , 179u8 , 19u8 , 169u8 , 196u8 , 119u8 , 107u8 , 75u8 , 100u8 , 3u8 , 121u8 , 18u8 , 80u8 , 156u8 ,]) } # [doc = " `true` if we are currently stalled."] pub fn stalled (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: Address :: new_static ("Grandpa" , "Stalled" , vec ! [] , [219u8 , 8u8 , 37u8 , 78u8 , 150u8 , 55u8 , 0u8 , 57u8 , 201u8 , 170u8 , 186u8 , 189u8 , 56u8 , 161u8 , 44u8 , 15u8 , 53u8 , 178u8 , 224u8 , 208u8 , 231u8 , 109u8 , 14u8 , 209u8 , 57u8 , 205u8 , 237u8 , 153u8 , 231u8 , 156u8 , 24u8 , 185u8 ,]) } # [doc = " The number of changes (both in terms of keys and underlying economic responsibilities)"] # [doc = " in the \"set\" of Grandpa validators from genesis."] pub fn current_set_id (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: core :: primitive :: u64 , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("Grandpa" , "CurrentSetId" , vec ! [] , [129u8 , 7u8 , 62u8 , 101u8 , 199u8 , 60u8 , 56u8 , 33u8 , 54u8 , 158u8 , 20u8 , 178u8 , 244u8 , 145u8 , 189u8 , 197u8 , 157u8 , 163u8 , 116u8 , 36u8 , 105u8 , 52u8 , 149u8 , 244u8 , 108u8 , 94u8 , 109u8 , 111u8 , 244u8 , 137u8 , 7u8 , 108u8 ,]) } # [doc = " A mapping from grandpa set ID to the index of the *most recent* session for which its"] # [doc = " members were responsible."] # [doc = ""] # [doc = " This is only used for validating equivocation proofs. An equivocation proof must"] # [doc = " contains a key-ownership proof for a given session, therefore we need a way to tie"] # [doc = " together sessions and GRANDPA set ids, i.e. we need to validate that a validator"] # [doc = " was the owner of a given key on a given session, and what the active set ID was"] # [doc = " during that session."] # [doc = ""] # [doc = " TWOX-NOTE: `SetId` is not under user control."] pub fn set_id_session (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u64 > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: core :: primitive :: u32 , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Grandpa" , "SetIdSession" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ())] , [91u8 , 175u8 , 145u8 , 127u8 , 242u8 , 81u8 , 13u8 , 231u8 , 110u8 , 11u8 , 166u8 , 169u8 , 103u8 , 146u8 , 123u8 , 133u8 , 157u8 , 15u8 , 33u8 , 234u8 , 108u8 , 13u8 , 88u8 , 115u8 , 254u8 , 9u8 , 145u8 , 199u8 , 102u8 , 47u8 , 53u8 , 134u8 ,]) } # [doc = " A mapping from grandpa set ID to the index of the *most recent* session for which its"] # [doc = " members were responsible."] # [doc = ""] # [doc = " This is only used for validating equivocation proofs. An equivocation proof must"] # [doc = " contains a key-ownership proof for a given session, therefore we need a way to tie"] # [doc = " together sessions and GRANDPA set ids, i.e. we need to validate that a validator"] # [doc = " was the owner of a given key on a given session, and what the active set ID was"] # [doc = " during that session."] # [doc = ""] # [doc = " TWOX-NOTE: `SetId` is not under user control."] pub fn set_id_session_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: core :: primitive :: u32 , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Grandpa" , "SetIdSession" , Vec :: new () , [91u8 , 175u8 , 145u8 , 127u8 , 242u8 , 81u8 , 13u8 , 231u8 , 110u8 , 11u8 , 166u8 , 169u8 , 103u8 , 146u8 , 123u8 , 133u8 , 157u8 , 15u8 , 33u8 , 234u8 , 108u8 , 13u8 , 88u8 , 115u8 , 254u8 , 9u8 , 145u8 , 199u8 , 102u8 , 47u8 , 53u8 , 134u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " Max Authorities in use"] pub fn max_authorities (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u32 > { :: subxt :: constants :: Address :: new_static ("Grandpa" , "MaxAuthorities" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The maximum number of entries to keep in the set id to session index mapping."] # [doc = ""] # [doc = " Since the `SetIdSession` map is only used for validating equivocations this"] # [doc = " value should relate to the bonding duration of whatever staking system is"] # [doc = " being used (if any). If equivocation handling is not enabled then this value"] # [doc = " can be zero."] pub fn max_set_id_session_entries (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u64 > { :: subxt :: constants :: Address :: new_static ("Grandpa" , "MaxSetIdSessionEntries" , [128u8 , 214u8 , 205u8 , 242u8 , 181u8 , 142u8 , 124u8 , 231u8 , 190u8 , 146u8 , 59u8 , 226u8 , 157u8 , 101u8 , 103u8 , 117u8 , 249u8 , 65u8 , 18u8 , 191u8 , 103u8 , 119u8 , 53u8 , 85u8 , 81u8 , 96u8 , 220u8 , 42u8 , 184u8 , 239u8 , 42u8 , 246u8 ,]) } } } } pub mod treasury { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct ProposeSpend { # [codec (compact)] pub value : :: core :: primitive :: u128 , pub beneficiary : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct RejectProposal { # [codec (compact)] pub proposal_id : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct ApproveProposal { # [codec (compact)] pub proposal_id : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Spend { # [codec (compact)] pub amount : :: core :: primitive :: u128 , pub beneficiary : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct RemoveApproval { # [codec (compact)] pub proposal_id : :: core :: primitive :: u32 , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Put forward a suggestion for spending. A deposit proportional to the value"] # [doc = "is reserved and slashed if the proposal is rejected. It is returned once the"] # [doc = "proposal is awarded."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)"] pub fn propose_spend (& self , value : :: core :: primitive :: u128 , beneficiary : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > ,) -> :: subxt :: tx :: Payload < ProposeSpend > { :: subxt :: tx :: Payload :: new_static ("Treasury" , "propose_spend" , ProposeSpend { value , beneficiary , } , [124u8 , 32u8 , 83u8 , 127u8 , 240u8 , 169u8 , 3u8 , 190u8 , 235u8 , 163u8 , 23u8 , 29u8 , 88u8 , 242u8 , 238u8 , 187u8 , 136u8 , 75u8 , 193u8 , 192u8 , 239u8 , 2u8 , 54u8 , 238u8 , 147u8 , 42u8 , 91u8 , 14u8 , 244u8 , 175u8 , 41u8 , 14u8 ,]) } # [doc = "Reject a proposed spend. The original deposit will be slashed."] # [doc = ""] # [doc = "May only be called from `T::RejectOrigin`."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)"] pub fn reject_proposal (& self , proposal_id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: Payload < RejectProposal > { :: subxt :: tx :: Payload :: new_static ("Treasury" , "reject_proposal" , RejectProposal { proposal_id , } , [106u8 , 223u8 , 97u8 , 22u8 , 111u8 , 208u8 , 128u8 , 26u8 , 198u8 , 140u8 , 118u8 , 126u8 , 187u8 , 51u8 , 193u8 , 50u8 , 193u8 , 68u8 , 143u8 , 144u8 , 34u8 , 132u8 , 44u8 , 244u8 , 105u8 , 186u8 , 223u8 , 234u8 , 17u8 , 145u8 , 209u8 , 145u8 ,]) } # [doc = "Approve a proposal. At a later time, the proposal will be allocated to the beneficiary"] # [doc = "and the original deposit will be returned."] # [doc = ""] # [doc = "May only be called from `T::ApproveOrigin`."] # [doc = ""] # [doc = "## Complexity"] # [doc = " - O(1)."] pub fn approve_proposal (& self , proposal_id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: Payload < ApproveProposal > { :: subxt :: tx :: Payload :: new_static ("Treasury" , "approve_proposal" , ApproveProposal { proposal_id , } , [164u8 , 229u8 , 172u8 , 98u8 , 129u8 , 62u8 , 84u8 , 128u8 , 47u8 , 108u8 , 33u8 , 120u8 , 89u8 , 79u8 , 57u8 , 121u8 , 4u8 , 197u8 , 170u8 , 153u8 , 156u8 , 17u8 , 59u8 , 164u8 , 123u8 , 227u8 , 175u8 , 195u8 , 220u8 , 160u8 , 60u8 , 186u8 ,]) } # [doc = "Propose and approve a spend of treasury funds."] # [doc = ""] # [doc = "- `origin`: Must be `SpendOrigin` with the `Success` value being at least `amount`."] # [doc = "- `amount`: The amount to be transferred from the treasury to the `beneficiary`."] # [doc = "- `beneficiary`: The destination account for the transfer."] # [doc = ""] # [doc = "NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the"] # [doc = "beneficiary."] pub fn spend (& self , amount : :: core :: primitive :: u128 , beneficiary : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > ,) -> :: subxt :: tx :: Payload < Spend > { :: subxt :: tx :: Payload :: new_static ("Treasury" , "spend" , Spend { amount , beneficiary , } , [208u8 , 79u8 , 96u8 , 218u8 , 205u8 , 209u8 , 165u8 , 119u8 , 92u8 , 208u8 , 54u8 , 168u8 , 83u8 , 190u8 , 98u8 , 97u8 , 6u8 , 2u8 , 35u8 , 249u8 , 18u8 , 88u8 , 193u8 , 51u8 , 130u8 , 33u8 , 28u8 , 99u8 , 49u8 , 194u8 , 34u8 , 77u8 ,]) } # [doc = "Force a previously approved proposal to be removed from the approval queue."] # [doc = "The original deposit will no longer be returned."] # [doc = ""] # [doc = "May only be called from `T::RejectOrigin`."] # [doc = "- `proposal_id`: The index of a proposal"] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(A) where `A` is the number of approvals"] # [doc = ""] # [doc = "Errors:"] # [doc = "- `ProposalNotApproved`: The `proposal_id` supplied was not found in the approval queue,"] # [doc = "i.e., the proposal has not been approved. This could also mean the proposal does not"] # [doc = "exist altogether, thus there is no way it would have been approved in the first place."] pub fn remove_approval (& self , proposal_id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: Payload < RemoveApproval > { :: subxt :: tx :: Payload :: new_static ("Treasury" , "remove_approval" , RemoveApproval { proposal_id , } , [133u8 , 126u8 , 181u8 , 47u8 , 196u8 , 243u8 , 7u8 , 46u8 , 25u8 , 251u8 , 154u8 , 125u8 , 217u8 , 77u8 , 54u8 , 245u8 , 240u8 , 180u8 , 97u8 , 34u8 , 186u8 , 53u8 , 225u8 , 144u8 , 155u8 , 107u8 , 172u8 , 54u8 , 250u8 , 184u8 , 178u8 , 86u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_treasury :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "New proposal."] pub struct Proposed { pub proposal_index : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for Proposed { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "Proposed" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "We have ended a spend period and will now allocate funds."] pub struct Spending { pub budget_remaining : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Spending { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "Spending" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Some funds have been allocated."] pub struct Awarded { pub proposal_index : :: core :: primitive :: u32 , pub award : :: core :: primitive :: u128 , pub account : :: subxt :: utils :: AccountId32 , } impl :: subxt :: events :: StaticEvent for Awarded { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "Awarded" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A proposal was rejected; funds were slashed."] pub struct Rejected { pub proposal_index : :: core :: primitive :: u32 , pub slashed : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Rejected { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "Rejected" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Some of our funds have been burnt."] pub struct Burnt { pub burnt_funds : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Burnt { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "Burnt" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Spending has finished; this is the amount that rolls over until next spend."] pub struct Rollover { pub rollover_balance : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Rollover { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "Rollover" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Some funds have been deposited."] pub struct Deposit { pub value : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for Deposit { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "Deposit" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A new spend proposal has been approved."] pub struct SpendApproved { pub proposal_index : :: core :: primitive :: u32 , pub amount : :: core :: primitive :: u128 , pub beneficiary : :: subxt :: utils :: AccountId32 , } impl :: subxt :: events :: StaticEvent for SpendApproved { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "SpendApproved" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "The inactive funds of the pallet have been updated."] pub struct UpdatedInactive { pub reactivated : :: core :: primitive :: u128 , pub deactivated : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for UpdatedInactive { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "UpdatedInactive" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " Number of proposals that have been made."] pub fn proposal_count (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: core :: primitive :: u32 , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("Treasury" , "ProposalCount" , vec ! [] , [132u8 , 145u8 , 78u8 , 218u8 , 51u8 , 189u8 , 55u8 , 172u8 , 143u8 , 33u8 , 140u8 , 99u8 , 124u8 , 208u8 , 57u8 , 232u8 , 154u8 , 110u8 , 32u8 , 142u8 , 24u8 , 149u8 , 109u8 , 105u8 , 30u8 , 83u8 , 39u8 , 177u8 , 127u8 , 160u8 , 34u8 , 70u8 ,]) } # [doc = " Proposals that have been made."] pub fn proposals (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: pallet_treasury :: Proposal < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u128 > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Treasury" , "Proposals" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ())] , [62u8 , 223u8 , 55u8 , 209u8 , 151u8 , 134u8 , 122u8 , 65u8 , 207u8 , 38u8 , 113u8 , 213u8 , 237u8 , 48u8 , 129u8 , 32u8 , 91u8 , 228u8 , 108u8 , 91u8 , 37u8 , 49u8 , 94u8 , 4u8 , 75u8 , 122u8 , 25u8 , 34u8 , 198u8 , 224u8 , 246u8 , 160u8 ,]) } # [doc = " Proposals that have been made."] pub fn proposals_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: pallet_treasury :: Proposal < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u128 > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Treasury" , "Proposals" , Vec :: new () , [62u8 , 223u8 , 55u8 , 209u8 , 151u8 , 134u8 , 122u8 , 65u8 , 207u8 , 38u8 , 113u8 , 213u8 , 237u8 , 48u8 , 129u8 , 32u8 , 91u8 , 228u8 , 108u8 , 91u8 , 37u8 , 49u8 , 94u8 , 4u8 , 75u8 , 122u8 , 25u8 , 34u8 , 198u8 , 224u8 , 246u8 , 160u8 ,]) } # [doc = " The amount which has been reported as inactive to Currency."] pub fn deactivated (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: core :: primitive :: u128 , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("Treasury" , "Deactivated" , vec ! [] , [159u8 , 57u8 , 5u8 , 85u8 , 136u8 , 128u8 , 70u8 , 43u8 , 67u8 , 76u8 , 123u8 , 206u8 , 48u8 , 253u8 , 51u8 , 40u8 , 14u8 , 35u8 , 162u8 , 173u8 , 127u8 , 79u8 , 38u8 , 235u8 , 9u8 , 141u8 , 201u8 , 37u8 , 211u8 , 176u8 , 119u8 , 106u8 ,]) } # [doc = " Proposal indices that have been approved but not yet awarded."] pub fn approvals (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("Treasury" , "Approvals" , vec ! [] , [202u8 , 106u8 , 189u8 , 40u8 , 127u8 , 172u8 , 108u8 , 50u8 , 193u8 , 4u8 , 248u8 , 226u8 , 176u8 , 101u8 , 212u8 , 222u8 , 64u8 , 206u8 , 244u8 , 175u8 , 111u8 , 106u8 , 86u8 , 96u8 , 19u8 , 109u8 , 218u8 , 152u8 , 30u8 , 59u8 , 96u8 , 1u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " Fraction of a proposal's value that should be bonded in order to place the proposal."] # [doc = " An accepted proposal gets these back. A rejected proposal does not."] pub fn proposal_bond (& self) -> :: subxt :: constants :: Address < runtime_types :: sp_arithmetic :: per_things :: Permill > { :: subxt :: constants :: Address :: new_static ("Treasury" , "ProposalBond" , [225u8 , 236u8 , 95u8 , 157u8 , 90u8 , 94u8 , 106u8 , 192u8 , 254u8 , 19u8 , 87u8 , 80u8 , 16u8 , 62u8 , 42u8 , 204u8 , 136u8 , 106u8 , 225u8 , 53u8 , 212u8 , 52u8 , 177u8 , 79u8 , 4u8 , 116u8 , 201u8 , 104u8 , 222u8 , 75u8 , 86u8 , 227u8 ,]) } # [doc = " Minimum amount of funds that should be placed in a deposit for making a proposal."] pub fn proposal_bond_minimum (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u128 > { :: subxt :: constants :: Address :: new_static ("Treasury" , "ProposalBondMinimum" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " Maximum amount of funds that should be placed in a deposit for making a proposal."] pub fn proposal_bond_maximum (& self) -> :: subxt :: constants :: Address < :: core :: option :: Option < :: core :: primitive :: u128 > > { :: subxt :: constants :: Address :: new_static ("Treasury" , "ProposalBondMaximum" , [84u8 , 154u8 , 218u8 , 83u8 , 84u8 , 189u8 , 32u8 , 20u8 , 120u8 , 194u8 , 88u8 , 205u8 , 109u8 , 216u8 , 114u8 , 193u8 , 120u8 , 198u8 , 154u8 , 237u8 , 134u8 , 204u8 , 102u8 , 247u8 , 52u8 , 103u8 , 231u8 , 43u8 , 243u8 , 122u8 , 60u8 , 216u8 ,]) } # [doc = " Period between successive spends."] pub fn spend_period (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u32 > { :: subxt :: constants :: Address :: new_static ("Treasury" , "SpendPeriod" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Percentage of spare funds (if any) that are burnt per spend period."] pub fn burn (& self) -> :: subxt :: constants :: Address < runtime_types :: sp_arithmetic :: per_things :: Permill > { :: subxt :: constants :: Address :: new_static ("Treasury" , "Burn" , [225u8 , 236u8 , 95u8 , 157u8 , 90u8 , 94u8 , 106u8 , 192u8 , 254u8 , 19u8 , 87u8 , 80u8 , 16u8 , 62u8 , 42u8 , 204u8 , 136u8 , 106u8 , 225u8 , 53u8 , 212u8 , 52u8 , 177u8 , 79u8 , 4u8 , 116u8 , 201u8 , 104u8 , 222u8 , 75u8 , 86u8 , 227u8 ,]) } # [doc = " The treasury's pallet id, used for deriving its sovereign account ID."] pub fn pallet_id (& self) -> :: subxt :: constants :: Address < runtime_types :: frame_support :: PalletId > { :: subxt :: constants :: Address :: new_static ("Treasury" , "PalletId" , [139u8 , 109u8 , 228u8 , 151u8 , 252u8 , 32u8 , 130u8 , 69u8 , 112u8 , 154u8 , 174u8 , 45u8 , 83u8 , 245u8 , 51u8 , 132u8 , 173u8 , 5u8 , 186u8 , 24u8 , 243u8 , 9u8 , 12u8 , 214u8 , 80u8 , 74u8 , 69u8 , 189u8 , 30u8 , 94u8 , 22u8 , 39u8 ,]) } # [doc = " The maximum number of approvals that can wait in the spending queue."] # [doc = ""] # [doc = " NOTE: This parameter is also used within the Bounties Pallet extension if enabled."] pub fn max_approvals (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u32 > { :: subxt :: constants :: Address :: new_static ("Treasury" , "MaxApprovals" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod bounties { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct ProposeBounty { # [codec (compact)] pub value : :: core :: primitive :: u128 , pub description : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct ApproveBounty { # [codec (compact)] pub bounty_id : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct ProposeCurator { # [codec (compact)] pub bounty_id : :: core :: primitive :: u32 , pub curator : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pub fee : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct UnassignCurator { # [codec (compact)] pub bounty_id : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct AcceptCurator { # [codec (compact)] pub bounty_id : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct AwardBounty { # [codec (compact)] pub bounty_id : :: core :: primitive :: u32 , pub beneficiary : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct ClaimBounty { # [codec (compact)] pub bounty_id : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct CloseBounty { # [codec (compact)] pub bounty_id : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct ExtendBountyExpiry { # [codec (compact)] pub bounty_id : :: core :: primitive :: u32 , pub remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Propose a new bounty."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Payment: `TipReportDepositBase` will be reserved from the origin account, as well as"] # [doc = "`DataDepositPerByte` for each byte in `reason`. It will be unreserved upon approval,"] # [doc = "or slashed when rejected."] # [doc = ""] # [doc = "- `curator`: The curator account whom will manage this bounty."] # [doc = "- `fee`: The curator fee."] # [doc = "- `value`: The total payment amount of this bounty, curator fee included."] # [doc = "- `description`: The description of this bounty."] pub fn propose_bounty (& self , value : :: core :: primitive :: u128 , description : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: tx :: Payload < ProposeBounty > { :: subxt :: tx :: Payload :: new_static ("Bounties" , "propose_bounty" , ProposeBounty { value , description , } , [99u8 , 160u8 , 94u8 , 74u8 , 105u8 , 161u8 , 123u8 , 239u8 , 241u8 , 117u8 , 97u8 , 99u8 , 84u8 , 101u8 , 87u8 , 3u8 , 88u8 , 175u8 , 75u8 , 59u8 , 114u8 , 87u8 , 18u8 , 113u8 , 126u8 , 26u8 , 42u8 , 104u8 , 201u8 , 128u8 , 102u8 , 219u8 ,]) } # [doc = "Approve a bounty proposal. At a later time, the bounty will be funded and become active"] # [doc = "and the original deposit will be returned."] # [doc = ""] # [doc = "May only be called from `T::SpendOrigin`."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] pub fn approve_bounty (& self , bounty_id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: Payload < ApproveBounty > { :: subxt :: tx :: Payload :: new_static ("Bounties" , "approve_bounty" , ApproveBounty { bounty_id , } , [82u8 , 228u8 , 232u8 , 103u8 , 198u8 , 173u8 , 190u8 , 148u8 , 159u8 , 86u8 , 48u8 , 4u8 , 32u8 , 169u8 , 1u8 , 129u8 , 96u8 , 145u8 , 235u8 , 68u8 , 48u8 , 34u8 , 5u8 , 1u8 , 76u8 , 26u8 , 100u8 , 228u8 , 92u8 , 198u8 , 183u8 , 173u8 ,]) } # [doc = "Assign a curator to a funded bounty."] # [doc = ""] # [doc = "May only be called from `T::SpendOrigin`."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] pub fn propose_curator (& self , bounty_id : :: core :: primitive :: u32 , curator : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , fee : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: Payload < ProposeCurator > { :: subxt :: tx :: Payload :: new_static ("Bounties" , "propose_curator" , ProposeCurator { bounty_id , curator , fee , } , [85u8 , 186u8 , 206u8 , 137u8 , 98u8 , 87u8 , 202u8 , 71u8 , 89u8 , 241u8 , 56u8 , 212u8 , 89u8 , 215u8 , 65u8 , 97u8 , 202u8 , 139u8 , 78u8 , 66u8 , 92u8 , 177u8 , 163u8 , 111u8 , 212u8 , 244u8 , 41u8 , 153u8 , 104u8 , 129u8 , 112u8 , 237u8 ,]) } # [doc = "Unassign curator from a bounty."] # [doc = ""] # [doc = "This function can only be called by the `RejectOrigin` a signed origin."] # [doc = ""] # [doc = "If this function is called by the `RejectOrigin`, we assume that the curator is"] # [doc = "malicious or inactive. As a result, we will slash the curator when possible."] # [doc = ""] # [doc = "If the origin is the curator, we take this as a sign they are unable to do their job and"] # [doc = "they willingly give up. We could slash them, but for now we allow them to recover their"] # [doc = "deposit and exit without issue. (We may want to change this if it is abused.)"] # [doc = ""] # [doc = "Finally, the origin can be anyone if and only if the curator is \"inactive\". This allows"] # [doc = "anyone in the community to call out that a curator is not doing their due diligence, and"] # [doc = "we should pick a new curator. In this case the curator should also be slashed."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] pub fn unassign_curator (& self , bounty_id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: Payload < UnassignCurator > { :: subxt :: tx :: Payload :: new_static ("Bounties" , "unassign_curator" , UnassignCurator { bounty_id , } , [218u8 , 241u8 , 247u8 , 89u8 , 95u8 , 120u8 , 93u8 , 18u8 , 85u8 , 114u8 , 158u8 , 254u8 , 68u8 , 77u8 , 230u8 , 186u8 , 230u8 , 201u8 , 63u8 , 223u8 , 28u8 , 173u8 , 244u8 , 82u8 , 113u8 , 177u8 , 99u8 , 27u8 , 207u8 , 247u8 , 207u8 , 213u8 ,]) } # [doc = "Accept the curator role for a bounty."] # [doc = "A deposit will be reserved from curator and refund upon successful payout."] # [doc = ""] # [doc = "May only be called from the curator."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] pub fn accept_curator (& self , bounty_id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: Payload < AcceptCurator > { :: subxt :: tx :: Payload :: new_static ("Bounties" , "accept_curator" , AcceptCurator { bounty_id , } , [106u8 , 96u8 , 22u8 , 67u8 , 52u8 , 109u8 , 180u8 , 225u8 , 122u8 , 253u8 , 209u8 , 214u8 , 132u8 , 131u8 , 247u8 , 131u8 , 162u8 , 51u8 , 144u8 , 30u8 , 12u8 , 126u8 , 50u8 , 152u8 , 229u8 , 119u8 , 54u8 , 116u8 , 112u8 , 235u8 , 34u8 , 166u8 ,]) } # [doc = "Award bounty to a beneficiary account. The beneficiary will be able to claim the funds"] # [doc = "after a delay."] # [doc = ""] # [doc = "The dispatch origin for this call must be the curator of this bounty."] # [doc = ""] # [doc = "- `bounty_id`: Bounty ID to award."] # [doc = "- `beneficiary`: The beneficiary account whom will receive the payout."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] pub fn award_bounty (& self , bounty_id : :: core :: primitive :: u32 , beneficiary : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > ,) -> :: subxt :: tx :: Payload < AwardBounty > { :: subxt :: tx :: Payload :: new_static ("Bounties" , "award_bounty" , AwardBounty { bounty_id , beneficiary , } , [7u8 , 205u8 , 73u8 , 45u8 , 57u8 , 8u8 , 24u8 , 135u8 , 89u8 , 157u8 , 35u8 , 176u8 , 224u8 , 106u8 , 167u8 , 232u8 , 230u8 , 153u8 , 239u8 , 45u8 , 210u8 , 61u8 , 17u8 , 106u8 , 220u8 , 131u8 , 105u8 , 136u8 , 232u8 , 194u8 , 243u8 , 48u8 ,]) } # [doc = "Claim the payout from an awarded bounty after payout delay."] # [doc = ""] # [doc = "The dispatch origin for this call must be the beneficiary of this bounty."] # [doc = ""] # [doc = "- `bounty_id`: Bounty ID to claim."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] pub fn claim_bounty (& self , bounty_id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: Payload < ClaimBounty > { :: subxt :: tx :: Payload :: new_static ("Bounties" , "claim_bounty" , ClaimBounty { bounty_id , } , [102u8 , 95u8 , 8u8 , 89u8 , 4u8 , 126u8 , 189u8 , 28u8 , 241u8 , 16u8 , 125u8 , 218u8 , 42u8 , 92u8 , 177u8 , 91u8 , 8u8 , 235u8 , 33u8 , 48u8 , 64u8 , 115u8 , 177u8 , 95u8 , 242u8 , 97u8 , 181u8 , 50u8 , 68u8 , 37u8 , 59u8 , 85u8 ,]) } # [doc = "Cancel a proposed or active bounty. All the funds will be sent to treasury and"] # [doc = "the curator deposit will be unreserved if possible."] # [doc = ""] # [doc = "Only `T::RejectOrigin` is able to cancel a bounty."] # [doc = ""] # [doc = "- `bounty_id`: Bounty ID to cancel."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] pub fn close_bounty (& self , bounty_id : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: Payload < CloseBounty > { :: subxt :: tx :: Payload :: new_static ("Bounties" , "close_bounty" , CloseBounty { bounty_id , } , [64u8 , 113u8 , 151u8 , 228u8 , 90u8 , 55u8 , 251u8 , 63u8 , 27u8 , 211u8 , 119u8 , 229u8 , 137u8 , 137u8 , 183u8 , 240u8 , 241u8 , 146u8 , 69u8 , 169u8 , 124u8 , 220u8 , 236u8 , 111u8 , 98u8 , 188u8 , 100u8 , 52u8 , 127u8 , 245u8 , 244u8 , 92u8 ,]) } # [doc = "Extend the expiry time of an active bounty."] # [doc = ""] # [doc = "The dispatch origin for this call must be the curator of this bounty."] # [doc = ""] # [doc = "- `bounty_id`: Bounty ID to extend."] # [doc = "- `remark`: additional information."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] pub fn extend_bounty_expiry (& self , bounty_id : :: core :: primitive :: u32 , remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: tx :: Payload < ExtendBountyExpiry > { :: subxt :: tx :: Payload :: new_static ("Bounties" , "extend_bounty_expiry" , ExtendBountyExpiry { bounty_id , remark , } , [97u8 , 69u8 , 157u8 , 39u8 , 59u8 , 72u8 , 79u8 , 88u8 , 104u8 , 119u8 , 91u8 , 26u8 , 73u8 , 216u8 , 174u8 , 95u8 , 254u8 , 214u8 , 63u8 , 138u8 , 100u8 , 112u8 , 185u8 , 81u8 , 159u8 , 247u8 , 221u8 , 60u8 , 87u8 , 40u8 , 80u8 , 202u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_bounties :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "New bounty proposal."] pub struct BountyProposed { pub index : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for BountyProposed { const PALLET : & 'static str = "Bounties" ; const EVENT : & 'static str = "BountyProposed" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A bounty proposal was rejected; funds were slashed."] pub struct BountyRejected { pub index : :: core :: primitive :: u32 , pub bond : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for BountyRejected { const PALLET : & 'static str = "Bounties" ; const EVENT : & 'static str = "BountyRejected" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A bounty proposal is funded and became active."] pub struct BountyBecameActive { pub index : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for BountyBecameActive { const PALLET : & 'static str = "Bounties" ; const EVENT : & 'static str = "BountyBecameActive" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A bounty is awarded to a beneficiary."] pub struct BountyAwarded { pub index : :: core :: primitive :: u32 , pub beneficiary : :: subxt :: utils :: AccountId32 , } impl :: subxt :: events :: StaticEvent for BountyAwarded { const PALLET : & 'static str = "Bounties" ; const EVENT : & 'static str = "BountyAwarded" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A bounty is claimed by beneficiary."] pub struct BountyClaimed { pub index : :: core :: primitive :: u32 , pub payout : :: core :: primitive :: u128 , pub beneficiary : :: subxt :: utils :: AccountId32 , } impl :: subxt :: events :: StaticEvent for BountyClaimed { const PALLET : & 'static str = "Bounties" ; const EVENT : & 'static str = "BountyClaimed" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A bounty is cancelled."] pub struct BountyCanceled { pub index : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for BountyCanceled { const PALLET : & 'static str = "Bounties" ; const EVENT : & 'static str = "BountyCanceled" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A bounty expiry is extended."] pub struct BountyExtended { pub index : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for BountyExtended { const PALLET : & 'static str = "Bounties" ; const EVENT : & 'static str = "BountyExtended" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " Number of bounty proposals that have been made."] pub fn bounty_count (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: core :: primitive :: u32 , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("Bounties" , "BountyCount" , vec ! [] , [5u8 , 188u8 , 134u8 , 220u8 , 64u8 , 49u8 , 188u8 , 98u8 , 185u8 , 186u8 , 230u8 , 65u8 , 247u8 , 199u8 , 28u8 , 178u8 , 202u8 , 193u8 , 41u8 , 83u8 , 115u8 , 253u8 , 182u8 , 123u8 , 92u8 , 138u8 , 12u8 , 31u8 , 31u8 , 213u8 , 23u8 , 118u8 ,]) } # [doc = " Bounties that have been made."] pub fn bounties (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: pallet_bounties :: Bounty < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Bounties" , "Bounties" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ())] , [111u8 , 149u8 , 33u8 , 54u8 , 172u8 , 143u8 , 41u8 , 231u8 , 184u8 , 255u8 , 238u8 , 206u8 , 87u8 , 142u8 , 84u8 , 10u8 , 236u8 , 141u8 , 190u8 , 193u8 , 72u8 , 170u8 , 19u8 , 110u8 , 135u8 , 136u8 , 220u8 , 11u8 , 99u8 , 126u8 , 225u8 , 208u8 ,]) } # [doc = " Bounties that have been made."] pub fn bounties_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: pallet_bounties :: Bounty < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u32 > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Bounties" , "Bounties" , Vec :: new () , [111u8 , 149u8 , 33u8 , 54u8 , 172u8 , 143u8 , 41u8 , 231u8 , 184u8 , 255u8 , 238u8 , 206u8 , 87u8 , 142u8 , 84u8 , 10u8 , 236u8 , 141u8 , 190u8 , 193u8 , 72u8 , 170u8 , 19u8 , 110u8 , 135u8 , 136u8 , 220u8 , 11u8 , 99u8 , 126u8 , 225u8 , 208u8 ,]) } # [doc = " The description of each bounty."] pub fn bounty_descriptions (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Bounties" , "BountyDescriptions" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ())] , [252u8 , 0u8 , 9u8 , 225u8 , 13u8 , 135u8 , 7u8 , 121u8 , 154u8 , 155u8 , 116u8 , 83u8 , 160u8 , 37u8 , 72u8 , 11u8 , 72u8 , 0u8 , 248u8 , 73u8 , 158u8 , 84u8 , 125u8 , 221u8 , 176u8 , 231u8 , 100u8 , 239u8 , 111u8 , 22u8 , 29u8 , 13u8 ,]) } # [doc = " The description of each bounty."] pub fn bounty_descriptions_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Bounties" , "BountyDescriptions" , Vec :: new () , [252u8 , 0u8 , 9u8 , 225u8 , 13u8 , 135u8 , 7u8 , 121u8 , 154u8 , 155u8 , 116u8 , 83u8 , 160u8 , 37u8 , 72u8 , 11u8 , 72u8 , 0u8 , 248u8 , 73u8 , 158u8 , 84u8 , 125u8 , 221u8 , 176u8 , 231u8 , 100u8 , 239u8 , 111u8 , 22u8 , 29u8 , 13u8 ,]) } # [doc = " Bounty indices that have been approved but not yet funded."] pub fn bounty_approvals (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < :: core :: primitive :: u32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("Bounties" , "BountyApprovals" , vec ! [] , [64u8 , 93u8 , 54u8 , 94u8 , 122u8 , 9u8 , 246u8 , 86u8 , 234u8 , 30u8 , 125u8 , 132u8 , 49u8 , 128u8 , 1u8 , 219u8 , 241u8 , 13u8 , 217u8 , 186u8 , 48u8 , 21u8 , 5u8 , 227u8 , 71u8 , 157u8 , 128u8 , 226u8 , 214u8 , 49u8 , 249u8 , 183u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The amount held on deposit for placing a bounty proposal."] pub fn bounty_deposit_base (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u128 > { :: subxt :: constants :: Address :: new_static ("Bounties" , "BountyDepositBase" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The delay period for which a bounty beneficiary need to wait before claim the payout."] pub fn bounty_deposit_payout_delay (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u32 > { :: subxt :: constants :: Address :: new_static ("Bounties" , "BountyDepositPayoutDelay" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Bounty duration in blocks."] pub fn bounty_update_period (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u32 > { :: subxt :: constants :: Address :: new_static ("Bounties" , "BountyUpdatePeriod" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The curator deposit is calculated as a percentage of the curator fee."] # [doc = ""] # [doc = " This deposit has optional upper and lower bounds with `CuratorDepositMax` and"] # [doc = " `CuratorDepositMin`."] pub fn curator_deposit_multiplier (& self) -> :: subxt :: constants :: Address < runtime_types :: sp_arithmetic :: per_things :: Permill > { :: subxt :: constants :: Address :: new_static ("Bounties" , "CuratorDepositMultiplier" , [225u8 , 236u8 , 95u8 , 157u8 , 90u8 , 94u8 , 106u8 , 192u8 , 254u8 , 19u8 , 87u8 , 80u8 , 16u8 , 62u8 , 42u8 , 204u8 , 136u8 , 106u8 , 225u8 , 53u8 , 212u8 , 52u8 , 177u8 , 79u8 , 4u8 , 116u8 , 201u8 , 104u8 , 222u8 , 75u8 , 86u8 , 227u8 ,]) } # [doc = " Maximum amount of funds that should be placed in a deposit for making a proposal."] pub fn curator_deposit_max (& self) -> :: subxt :: constants :: Address < :: core :: option :: Option < :: core :: primitive :: u128 > > { :: subxt :: constants :: Address :: new_static ("Bounties" , "CuratorDepositMax" , [84u8 , 154u8 , 218u8 , 83u8 , 84u8 , 189u8 , 32u8 , 20u8 , 120u8 , 194u8 , 88u8 , 205u8 , 109u8 , 216u8 , 114u8 , 193u8 , 120u8 , 198u8 , 154u8 , 237u8 , 134u8 , 204u8 , 102u8 , 247u8 , 52u8 , 103u8 , 231u8 , 43u8 , 243u8 , 122u8 , 60u8 , 216u8 ,]) } # [doc = " Minimum amount of funds that should be placed in a deposit for making a proposal."] pub fn curator_deposit_min (& self) -> :: subxt :: constants :: Address < :: core :: option :: Option < :: core :: primitive :: u128 > > { :: subxt :: constants :: Address :: new_static ("Bounties" , "CuratorDepositMin" , [84u8 , 154u8 , 218u8 , 83u8 , 84u8 , 189u8 , 32u8 , 20u8 , 120u8 , 194u8 , 88u8 , 205u8 , 109u8 , 216u8 , 114u8 , 193u8 , 120u8 , 198u8 , 154u8 , 237u8 , 134u8 , 204u8 , 102u8 , 247u8 , 52u8 , 103u8 , 231u8 , 43u8 , 243u8 , 122u8 , 60u8 , 216u8 ,]) } # [doc = " Minimum value for a bounty."] pub fn bounty_value_minimum (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u128 > { :: subxt :: constants :: Address :: new_static ("Bounties" , "BountyValueMinimum" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The amount held on deposit per byte within the tip report reason or bounty description."] pub fn data_deposit_per_byte (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u128 > { :: subxt :: constants :: Address :: new_static ("Bounties" , "DataDepositPerByte" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " Maximum acceptable reason length."] # [doc = ""] # [doc = " Benchmarks depend on this value, be sure to update weights file when changing this value"] pub fn maximum_reason_length (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u32 > { :: subxt :: constants :: Address :: new_static ("Bounties" , "MaximumReasonLength" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod vesting { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Vest ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct VestOther { pub target : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct VestedTransfer { pub target : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , pub schedule : runtime_types :: pallet_vesting :: vesting_info :: VestingInfo < :: core :: primitive :: u128 , :: core :: primitive :: u32 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct ForceVestedTransfer { pub source : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , pub target : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , pub schedule : runtime_types :: pallet_vesting :: vesting_info :: VestingInfo < :: core :: primitive :: u128 , :: core :: primitive :: u32 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct MergeSchedules { pub schedule1_index : :: core :: primitive :: u32 , pub schedule2_index : :: core :: primitive :: u32 , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Unlock any vested funds of the sender account."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have funds still"] # [doc = "locked under this pallet."] # [doc = ""] # [doc = "Emits either `VestingCompleted` or `VestingUpdated`."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)`."] pub fn vest (& self ,) -> :: subxt :: tx :: Payload < Vest > { :: subxt :: tx :: Payload :: new_static ("Vesting" , "vest" , Vest { } , [123u8 , 54u8 , 10u8 , 208u8 , 154u8 , 24u8 , 39u8 , 166u8 , 64u8 , 27u8 , 74u8 , 29u8 , 243u8 , 97u8 , 155u8 , 5u8 , 130u8 , 155u8 , 65u8 , 181u8 , 196u8 , 125u8 , 45u8 , 133u8 , 25u8 , 33u8 , 3u8 , 34u8 , 21u8 , 167u8 , 172u8 , 54u8 ,]) } # [doc = "Unlock any vested funds of a `target` account."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `target`: The account whose vested funds should be unlocked. Must have funds still"] # [doc = "locked under this pallet."] # [doc = ""] # [doc = "Emits either `VestingCompleted` or `VestingUpdated`."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)`."] pub fn vest_other (& self , target : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > ,) -> :: subxt :: tx :: Payload < VestOther > { :: subxt :: tx :: Payload :: new_static ("Vesting" , "vest_other" , VestOther { target , } , [243u8 , 97u8 , 222u8 , 101u8 , 143u8 , 17u8 , 184u8 , 191u8 , 208u8 , 162u8 , 31u8 , 121u8 , 22u8 , 88u8 , 2u8 , 36u8 , 9u8 , 22u8 , 27u8 , 117u8 , 236u8 , 82u8 , 83u8 , 218u8 , 166u8 , 154u8 , 49u8 , 141u8 , 95u8 , 127u8 , 63u8 , 13u8 ,]) } # [doc = "Create a vested transfer."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `target`: The account receiving the vested funds."] # [doc = "- `schedule`: The vesting schedule attached to the transfer."] # [doc = ""] # [doc = "Emits `VestingCreated`."] # [doc = ""] # [doc = "NOTE: This will unlock all schedules through the current block."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)`."] pub fn vested_transfer (& self , target : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , schedule : runtime_types :: pallet_vesting :: vesting_info :: VestingInfo < :: core :: primitive :: u128 , :: core :: primitive :: u32 > ,) -> :: subxt :: tx :: Payload < VestedTransfer > { :: subxt :: tx :: Payload :: new_static ("Vesting" , "vested_transfer" , VestedTransfer { target , schedule , } , [157u8 , 78u8 , 209u8 , 131u8 , 29u8 , 102u8 , 180u8 , 61u8 , 212u8 , 154u8 , 28u8 , 3u8 , 150u8 , 236u8 , 22u8 , 116u8 , 8u8 , 142u8 , 174u8 , 35u8 , 37u8 , 167u8 , 5u8 , 200u8 , 189u8 , 227u8 , 122u8 , 55u8 , 188u8 , 213u8 , 59u8 , 206u8 ,]) } # [doc = "Force a vested transfer."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Root_."] # [doc = ""] # [doc = "- `source`: The account whose funds should be transferred."] # [doc = "- `target`: The account that should be transferred the vested funds."] # [doc = "- `schedule`: The vesting schedule attached to the transfer."] # [doc = ""] # [doc = "Emits `VestingCreated`."] # [doc = ""] # [doc = "NOTE: This will unlock all schedules through the current block."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)`."] pub fn force_vested_transfer (& self , source : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , target : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , schedule : runtime_types :: pallet_vesting :: vesting_info :: VestingInfo < :: core :: primitive :: u128 , :: core :: primitive :: u32 > ,) -> :: subxt :: tx :: Payload < ForceVestedTransfer > { :: subxt :: tx :: Payload :: new_static ("Vesting" , "force_vested_transfer" , ForceVestedTransfer { source , target , schedule , } , [181u8 , 47u8 , 44u8 , 166u8 , 243u8 , 122u8 , 51u8 , 81u8 , 136u8 , 192u8 , 248u8 , 150u8 , 149u8 , 49u8 , 208u8 , 203u8 , 156u8 , 100u8 , 56u8 , 133u8 , 22u8 , 53u8 , 241u8 , 237u8 , 145u8 , 210u8 , 25u8 , 48u8 , 61u8 , 184u8 , 112u8 , 253u8 ,]) } # [doc = "Merge two vesting schedules together, creating a new vesting schedule that unlocks over"] # [doc = "the highest possible start and end blocks. If both schedules have already started the"] # [doc = "current block will be used as the schedule start; with the caveat that if one schedule"] # [doc = "is finished by the current block, the other will be treated as the new merged schedule,"] # [doc = "unmodified."] # [doc = ""] # [doc = "NOTE: If `schedule1_index == schedule2_index` this is a no-op."] # [doc = "NOTE: This will unlock all schedules through the current block prior to merging."] # [doc = "NOTE: If both schedules have ended by the current block, no new schedule will be created"] # [doc = "and both will be removed."] # [doc = ""] # [doc = "Merged schedule attributes:"] # [doc = "- `starting_block`: `MAX(schedule1.starting_block, scheduled2.starting_block,"] # [doc = "  current_block)`."] # [doc = "- `ending_block`: `MAX(schedule1.ending_block, schedule2.ending_block)`."] # [doc = "- `locked`: `schedule1.locked_at(current_block) + schedule2.locked_at(current_block)`."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `schedule1_index`: index of the first schedule to merge."] # [doc = "- `schedule2_index`: index of the second schedule to merge."] pub fn merge_schedules (& self , schedule1_index : :: core :: primitive :: u32 , schedule2_index : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: Payload < MergeSchedules > { :: subxt :: tx :: Payload :: new_static ("Vesting" , "merge_schedules" , MergeSchedules { schedule1_index , schedule2_index , } , [95u8 , 255u8 , 147u8 , 12u8 , 49u8 , 25u8 , 70u8 , 112u8 , 55u8 , 154u8 , 183u8 , 97u8 , 56u8 , 244u8 , 148u8 , 61u8 , 107u8 , 163u8 , 220u8 , 31u8 , 153u8 , 25u8 , 193u8 , 251u8 , 131u8 , 26u8 , 166u8 , 157u8 , 75u8 , 4u8 , 110u8 , 125u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_vesting :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "The amount vested has been updated. This could indicate a change in funds available."] # [doc = "The balance given is the amount which is left unvested (and thus locked)."] pub struct VestingUpdated { pub account : :: subxt :: utils :: AccountId32 , pub unvested : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for VestingUpdated { const PALLET : & 'static str = "Vesting" ; const EVENT : & 'static str = "VestingUpdated" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "An \\[account\\] has become fully vested."] pub struct VestingCompleted { pub account : :: subxt :: utils :: AccountId32 , } impl :: subxt :: events :: StaticEvent for VestingCompleted { const PALLET : & 'static str = "Vesting" ; const EVENT : & 'static str = "VestingCompleted" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " Information regarding the vesting of a given account."] pub fn vesting (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: utils :: AccountId32 > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < runtime_types :: pallet_vesting :: vesting_info :: VestingInfo < :: core :: primitive :: u128 , :: core :: primitive :: u32 > > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Vesting" , "Vesting" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ())] , [23u8 , 209u8 , 233u8 , 126u8 , 89u8 , 156u8 , 193u8 , 204u8 , 100u8 , 90u8 , 14u8 , 120u8 , 36u8 , 167u8 , 148u8 , 239u8 , 179u8 , 74u8 , 207u8 , 83u8 , 54u8 , 77u8 , 27u8 , 135u8 , 74u8 , 31u8 , 33u8 , 11u8 , 168u8 , 239u8 , 212u8 , 36u8 ,]) } # [doc = " Information regarding the vesting of a given account."] pub fn vesting_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < runtime_types :: pallet_vesting :: vesting_info :: VestingInfo < :: core :: primitive :: u128 , :: core :: primitive :: u32 > > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Vesting" , "Vesting" , Vec :: new () , [23u8 , 209u8 , 233u8 , 126u8 , 89u8 , 156u8 , 193u8 , 204u8 , 100u8 , 90u8 , 14u8 , 120u8 , 36u8 , 167u8 , 148u8 , 239u8 , 179u8 , 74u8 , 207u8 , 83u8 , 54u8 , 77u8 , 27u8 , 135u8 , 74u8 , 31u8 , 33u8 , 11u8 , 168u8 , 239u8 , 212u8 , 36u8 ,]) } # [doc = " Storage version of the pallet."] # [doc = ""] # [doc = " New networks start with latest version, as determined by the genesis build."] pub fn storage_version (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: pallet_vesting :: Releases , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("Vesting" , "StorageVersion" , vec ! [] , [50u8 , 143u8 , 26u8 , 88u8 , 129u8 , 31u8 , 61u8 , 118u8 , 19u8 , 202u8 , 119u8 , 160u8 , 34u8 , 219u8 , 60u8 , 57u8 , 189u8 , 66u8 , 93u8 , 239u8 , 121u8 , 114u8 , 241u8 , 116u8 , 0u8 , 122u8 , 232u8 , 94u8 , 189u8 , 23u8 , 45u8 , 191u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The minimum amount transferred to call `vested_transfer`."] pub fn min_vested_transfer (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u128 > { :: subxt :: constants :: Address :: new_static ("Vesting" , "MinVestedTransfer" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } pub fn max_vesting_schedules (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u32 > { :: subxt :: constants :: Address :: new_static ("Vesting" , "MaxVestingSchedules" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod indices { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Claim { pub index : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Transfer { pub new : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , pub index : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Free { pub index : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct ForceTransfer { pub new : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , pub index : :: core :: primitive :: u32 , pub freeze : :: core :: primitive :: bool , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Freeze { pub index : :: core :: primitive :: u32 , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Assign an previously unassigned index."] # [doc = ""] # [doc = "Payment: `Deposit` is reserved from the sender account."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `index`: the index to be claimed. This must not be in use."] # [doc = ""] # [doc = "Emits `IndexAssigned` if successful."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)`."] pub fn claim (& self , index : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: Payload < Claim > { :: subxt :: tx :: Payload :: new_static ("Indices" , "claim" , Claim { index , } , [5u8 , 24u8 , 11u8 , 173u8 , 226u8 , 170u8 , 0u8 , 30u8 , 193u8 , 102u8 , 214u8 , 59u8 , 252u8 , 32u8 , 221u8 , 88u8 , 196u8 , 189u8 , 244u8 , 18u8 , 233u8 , 37u8 , 228u8 , 248u8 , 76u8 , 175u8 , 212u8 , 233u8 , 238u8 , 203u8 , 162u8 , 68u8 ,]) } # [doc = "Assign an index already owned by the sender to another account. The balance reservation"] # [doc = "is effectively transferred to the new account."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `index`: the index to be re-assigned. This must be owned by the sender."] # [doc = "- `new`: the new owner of the index. This function is a no-op if it is equal to sender."] # [doc = ""] # [doc = "Emits `IndexAssigned` if successful."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)`."] pub fn transfer (& self , new : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , index : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: Payload < Transfer > { :: subxt :: tx :: Payload :: new_static ("Indices" , "transfer" , Transfer { new , index , } , [1u8 , 83u8 , 197u8 , 184u8 , 8u8 , 96u8 , 48u8 , 146u8 , 116u8 , 76u8 , 229u8 , 115u8 , 226u8 , 215u8 , 41u8 , 154u8 , 27u8 , 34u8 , 205u8 , 188u8 , 10u8 , 169u8 , 203u8 , 39u8 , 2u8 , 236u8 , 181u8 , 162u8 , 115u8 , 254u8 , 42u8 , 28u8 ,]) } # [doc = "Free up an index owned by the sender."] # [doc = ""] # [doc = "Payment: Any previous deposit placed for the index is unreserved in the sender account."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must own the index."] # [doc = ""] # [doc = "- `index`: the index to be freed. This must be owned by the sender."] # [doc = ""] # [doc = "Emits `IndexFreed` if successful."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)`."] pub fn free (& self , index : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: Payload < Free > { :: subxt :: tx :: Payload :: new_static ("Indices" , "free" , Free { index , } , [133u8 , 202u8 , 225u8 , 127u8 , 69u8 , 145u8 , 43u8 , 13u8 , 160u8 , 248u8 , 215u8 , 243u8 , 232u8 , 166u8 , 74u8 , 203u8 , 235u8 , 138u8 , 255u8 , 27u8 , 163u8 , 71u8 , 254u8 , 217u8 , 6u8 , 208u8 , 202u8 , 204u8 , 238u8 , 70u8 , 126u8 , 252u8 ,]) } # [doc = "Force an index to an account. This doesn't require a deposit. If the index is already"] # [doc = "held, then any deposit is reimbursed to its current owner."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Root_."] # [doc = ""] # [doc = "- `index`: the index to be (re-)assigned."] # [doc = "- `new`: the new owner of the index. This function is a no-op if it is equal to sender."] # [doc = "- `freeze`: if set to `true`, will freeze the index so it cannot be transferred."] # [doc = ""] # [doc = "Emits `IndexAssigned` if successful."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)`."] pub fn force_transfer (& self , new : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , index : :: core :: primitive :: u32 , freeze : :: core :: primitive :: bool ,) -> :: subxt :: tx :: Payload < ForceTransfer > { :: subxt :: tx :: Payload :: new_static ("Indices" , "force_transfer" , ForceTransfer { new , index , freeze , } , [126u8 , 8u8 , 145u8 , 175u8 , 177u8 , 153u8 , 131u8 , 123u8 , 184u8 , 53u8 , 72u8 , 207u8 , 21u8 , 140u8 , 87u8 , 181u8 , 172u8 , 64u8 , 37u8 , 165u8 , 121u8 , 111u8 , 173u8 , 224u8 , 181u8 , 79u8 , 76u8 , 134u8 , 93u8 , 169u8 , 65u8 , 131u8 ,]) } # [doc = "Freeze an index so it will always point to the sender account. This consumes the"] # [doc = "deposit."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the signing account must have a"] # [doc = "non-frozen account `index`."] # [doc = ""] # [doc = "- `index`: the index to be frozen in place."] # [doc = ""] # [doc = "Emits `IndexFrozen` if successful."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)`."] pub fn freeze (& self , index : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: Payload < Freeze > { :: subxt :: tx :: Payload :: new_static ("Indices" , "freeze" , Freeze { index , } , [121u8 , 45u8 , 118u8 , 2u8 , 72u8 , 48u8 , 38u8 , 7u8 , 234u8 , 204u8 , 68u8 , 20u8 , 76u8 , 251u8 , 205u8 , 246u8 , 149u8 , 31u8 , 168u8 , 186u8 , 208u8 , 90u8 , 40u8 , 47u8 , 100u8 , 228u8 , 188u8 , 33u8 , 79u8 , 220u8 , 105u8 , 209u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_indices :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A account index was assigned."] pub struct IndexAssigned { pub who : :: subxt :: utils :: AccountId32 , pub index : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for IndexAssigned { const PALLET : & 'static str = "Indices" ; const EVENT : & 'static str = "IndexAssigned" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A account index has been freed up (unassigned)."] pub struct IndexFreed { pub index : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for IndexFreed { const PALLET : & 'static str = "Indices" ; const EVENT : & 'static str = "IndexFreed" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A account index has been frozen to its current account ID."] pub struct IndexFrozen { pub index : :: core :: primitive :: u32 , pub who : :: subxt :: utils :: AccountId32 , } impl :: subxt :: events :: StaticEvent for IndexFrozen { const PALLET : & 'static str = "Indices" ; const EVENT : & 'static str = "IndexFrozen" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " The lookup from index to account."] pub fn accounts (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , (:: subxt :: utils :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: bool ,) , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Indices" , "Accounts" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ())] , [211u8 , 169u8 , 54u8 , 254u8 , 88u8 , 57u8 , 22u8 , 223u8 , 108u8 , 27u8 , 38u8 , 9u8 , 202u8 , 209u8 , 111u8 , 209u8 , 144u8 , 13u8 , 211u8 , 114u8 , 239u8 , 127u8 , 75u8 , 166u8 , 234u8 , 222u8 , 225u8 , 35u8 , 160u8 , 163u8 , 112u8 , 242u8 ,]) } # [doc = " The lookup from index to account."] pub fn accounts_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , (:: subxt :: utils :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: bool ,) , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Indices" , "Accounts" , Vec :: new () , [211u8 , 169u8 , 54u8 , 254u8 , 88u8 , 57u8 , 22u8 , 223u8 , 108u8 , 27u8 , 38u8 , 9u8 , 202u8 , 209u8 , 111u8 , 209u8 , 144u8 , 13u8 , 211u8 , 114u8 , 239u8 , 127u8 , 75u8 , 166u8 , 234u8 , 222u8 , 225u8 , 35u8 , 160u8 , 163u8 , 112u8 , 242u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The deposit needed for reserving an index."] pub fn deposit (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u128 > { :: subxt :: constants :: Address :: new_static ("Indices" , "Deposit" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } } } } pub mod proxy { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Proxy { pub real : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , pub force_proxy_type : :: core :: option :: Option < runtime_types :: golden_gate_runtime_testnet :: poa :: ProxyType > , pub call : :: std :: boxed :: Box < runtime_types :: golden_gate_runtime_testnet :: RuntimeCall > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct AddProxy { pub delegate : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , pub proxy_type : runtime_types :: golden_gate_runtime_testnet :: poa :: ProxyType , pub delay : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct RemoveProxy { pub delegate : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , pub proxy_type : runtime_types :: golden_gate_runtime_testnet :: poa :: ProxyType , pub delay : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct RemoveProxies ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct CreatePure { pub proxy_type : runtime_types :: golden_gate_runtime_testnet :: poa :: ProxyType , pub delay : :: core :: primitive :: u32 , pub index : :: core :: primitive :: u16 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct KillPure { pub spawner : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , pub proxy_type : runtime_types :: golden_gate_runtime_testnet :: poa :: ProxyType , pub index : :: core :: primitive :: u16 , # [codec (compact)] pub height : :: core :: primitive :: u32 , # [codec (compact)] pub ext_index : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Announce { pub real : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , pub call_hash : :: subxt :: utils :: H256 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct RemoveAnnouncement { pub real : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , pub call_hash : :: subxt :: utils :: H256 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct RejectAnnouncement { pub delegate : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , pub call_hash : :: subxt :: utils :: H256 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct ProxyAnnounced { pub delegate : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , pub real : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , pub force_proxy_type : :: core :: option :: Option < runtime_types :: golden_gate_runtime_testnet :: poa :: ProxyType > , pub call : :: std :: boxed :: Box < runtime_types :: golden_gate_runtime_testnet :: RuntimeCall > , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Dispatch the given `call` from an account that the sender is authorised for through"] # [doc = "`add_proxy`."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `real`: The account that the proxy will make a call on behalf of."] # [doc = "- `force_proxy_type`: Specify the exact proxy type to be used and checked for this call."] # [doc = "- `call`: The call to be made by the `real` account."] pub fn proxy (& self , real : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , force_proxy_type : :: core :: option :: Option < runtime_types :: golden_gate_runtime_testnet :: poa :: ProxyType > , call : runtime_types :: golden_gate_runtime_testnet :: RuntimeCall ,) -> :: subxt :: tx :: Payload < Proxy > { :: subxt :: tx :: Payload :: new_static ("Proxy" , "proxy" , Proxy { real , force_proxy_type , call : :: std :: boxed :: Box :: new (call) , } , [56u8 , 70u8 , 79u8 , 139u8 , 248u8 , 216u8 , 132u8 , 99u8 , 126u8 , 117u8 , 173u8 , 157u8 , 29u8 , 72u8 , 162u8 , 157u8 , 59u8 , 255u8 , 32u8 , 79u8 , 179u8 , 227u8 , 236u8 , 121u8 , 217u8 , 97u8 , 176u8 , 155u8 , 132u8 , 177u8 , 8u8 , 7u8 ,]) } # [doc = "Register a proxy account for the sender that is able to make calls on its behalf."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `proxy`: The account that the `caller` would like to make a proxy."] # [doc = "- `proxy_type`: The permissions allowed for this proxy account."] # [doc = "- `delay`: The announcement period required of the initial proxy. Will generally be"] # [doc = "zero."] pub fn add_proxy (& self , delegate : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , proxy_type : runtime_types :: golden_gate_runtime_testnet :: poa :: ProxyType , delay : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: Payload < AddProxy > { :: subxt :: tx :: Payload :: new_static ("Proxy" , "add_proxy" , AddProxy { delegate , proxy_type , delay , } , [211u8 , 200u8 , 7u8 , 113u8 , 209u8 , 137u8 , 32u8 , 156u8 , 238u8 , 6u8 , 215u8 , 238u8 , 193u8 , 242u8 , 44u8 , 115u8 , 200u8 , 78u8 , 226u8 , 41u8 , 169u8 , 151u8 , 149u8 , 172u8 , 37u8 , 107u8 , 115u8 , 78u8 , 113u8 , 65u8 , 140u8 , 23u8 ,]) } # [doc = "Unregister a proxy account for the sender."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `proxy`: The account that the `caller` would like to remove as a proxy."] # [doc = "- `proxy_type`: The permissions currently enabled for the removed proxy account."] pub fn remove_proxy (& self , delegate : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , proxy_type : runtime_types :: golden_gate_runtime_testnet :: poa :: ProxyType , delay : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: Payload < RemoveProxy > { :: subxt :: tx :: Payload :: new_static ("Proxy" , "remove_proxy" , RemoveProxy { delegate , proxy_type , delay , } , [244u8 , 38u8 , 197u8 , 84u8 , 6u8 , 174u8 , 145u8 , 207u8 , 78u8 , 133u8 , 251u8 , 189u8 , 235u8 , 179u8 , 39u8 , 104u8 , 217u8 , 37u8 , 198u8 , 202u8 , 26u8 , 119u8 , 62u8 , 216u8 , 58u8 , 173u8 , 59u8 , 129u8 , 77u8 , 196u8 , 149u8 , 28u8 ,]) } # [doc = "Unregister all proxy accounts for the sender."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "WARNING: This may be called on accounts created by `pure`, however if done, then"] # [doc = "the unreserved fees will be inaccessible. **All access to this account will be lost.**"] pub fn remove_proxies (& self ,) -> :: subxt :: tx :: Payload < RemoveProxies > { :: subxt :: tx :: Payload :: new_static ("Proxy" , "remove_proxies" , RemoveProxies { } , [15u8 , 237u8 , 27u8 , 166u8 , 254u8 , 218u8 , 92u8 , 5u8 , 213u8 , 239u8 , 99u8 , 59u8 , 1u8 , 26u8 , 73u8 , 252u8 , 81u8 , 94u8 , 214u8 , 227u8 , 169u8 , 58u8 , 40u8 , 253u8 , 187u8 , 225u8 , 192u8 , 26u8 , 19u8 , 23u8 , 121u8 , 129u8 ,]) } # [doc = "Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and"] # [doc = "initialize it with a proxy of `proxy_type` for `origin` sender."] # [doc = ""] # [doc = "Requires a `Signed` origin."] # [doc = ""] # [doc = "- `proxy_type`: The type of the proxy that the sender will be registered as over the"] # [doc = "new account. This will almost always be the most permissive `ProxyType` possible to"] # [doc = "allow for maximum flexibility."] # [doc = "- `index`: A disambiguation index, in case this is called multiple times in the same"] # [doc = "transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just"] # [doc = "want to use `0`."] # [doc = "- `delay`: The announcement period required of the initial proxy. Will generally be"] # [doc = "zero."] # [doc = ""] # [doc = "Fails with `Duplicate` if this has already been called in this transaction, from the"] # [doc = "same sender, with the same parameters."] # [doc = ""] # [doc = "Fails if there are insufficient funds to pay for deposit."] pub fn create_pure (& self , proxy_type : runtime_types :: golden_gate_runtime_testnet :: poa :: ProxyType , delay : :: core :: primitive :: u32 , index : :: core :: primitive :: u16 ,) -> :: subxt :: tx :: Payload < CreatePure > { :: subxt :: tx :: Payload :: new_static ("Proxy" , "create_pure" , CreatePure { proxy_type , delay , index , } , [115u8 , 189u8 , 1u8 , 192u8 , 147u8 , 88u8 , 187u8 , 247u8 , 24u8 , 15u8 , 156u8 , 57u8 , 17u8 , 155u8 , 197u8 , 77u8 , 29u8 , 242u8 , 190u8 , 34u8 , 3u8 , 50u8 , 31u8 , 24u8 , 209u8 , 227u8 , 158u8 , 179u8 , 32u8 , 223u8 , 5u8 , 43u8 ,]) } # [doc = "Removes a previously spawned pure proxy."] # [doc = ""] # [doc = "WARNING: **All access to this account will be lost.** Any funds held in it will be"] # [doc = "inaccessible."] # [doc = ""] # [doc = "Requires a `Signed` origin, and the sender account must have been created by a call to"] # [doc = "`pure` with corresponding parameters."] # [doc = ""] # [doc = "- `spawner`: The account that originally called `pure` to create this account."] # [doc = "- `index`: The disambiguation index originally passed to `pure`. Probably `0`."] # [doc = "- `proxy_type`: The proxy type originally passed to `pure`."] # [doc = "- `height`: The height of the chain when the call to `pure` was processed."] # [doc = "- `ext_index`: The extrinsic index in which the call to `pure` was processed."] # [doc = ""] # [doc = "Fails with `NoPermission` in case the caller is not a previously created pure"] # [doc = "account whose `pure` call has corresponding parameters."] pub fn kill_pure (& self , spawner : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , proxy_type : runtime_types :: golden_gate_runtime_testnet :: poa :: ProxyType , index : :: core :: primitive :: u16 , height : :: core :: primitive :: u32 , ext_index : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: Payload < KillPure > { :: subxt :: tx :: Payload :: new_static ("Proxy" , "kill_pure" , KillPure { spawner , proxy_type , index , height , ext_index , } , [223u8 , 178u8 , 166u8 , 156u8 , 40u8 , 219u8 , 186u8 , 194u8 , 184u8 , 8u8 , 39u8 , 222u8 , 238u8 , 193u8 , 13u8 , 120u8 , 94u8 , 118u8 , 215u8 , 112u8 , 102u8 , 155u8 , 151u8 , 63u8 , 46u8 , 72u8 , 101u8 , 88u8 , 14u8 , 245u8 , 219u8 , 244u8 ,]) } # [doc = "Publish the hash of a proxy-call that will be made in the future."] # [doc = ""] # [doc = "This must be called some number of blocks before the corresponding `proxy` is attempted"] # [doc = "if the delay associated with the proxy relationship is greater than zero."] # [doc = ""] # [doc = "No more than `MaxPending` announcements may be made at any one time."] # [doc = ""] # [doc = "This will take a deposit of `AnnouncementDepositFactor` as well as"] # [doc = "`AnnouncementDepositBase` if there are no other pending announcements."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and a proxy of `real`."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `real`: The account that the proxy will make a call on behalf of."] # [doc = "- `call_hash`: The hash of the call to be made by the `real` account."] pub fn announce (& self , real : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , call_hash : :: subxt :: utils :: H256 ,) -> :: subxt :: tx :: Payload < Announce > { :: subxt :: tx :: Payload :: new_static ("Proxy" , "announce" , Announce { real , call_hash , } , [226u8 , 252u8 , 69u8 , 50u8 , 248u8 , 212u8 , 209u8 , 225u8 , 201u8 , 236u8 , 51u8 , 136u8 , 56u8 , 85u8 , 36u8 , 130u8 , 233u8 , 84u8 , 44u8 , 192u8 , 174u8 , 119u8 , 245u8 , 62u8 , 150u8 , 78u8 , 217u8 , 90u8 , 167u8 , 154u8 , 228u8 , 141u8 ,]) } # [doc = "Remove a given announcement."] # [doc = ""] # [doc = "May be called by a proxy account to remove a call they previously announced and return"] # [doc = "the deposit."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `real`: The account that the proxy will make a call on behalf of."] # [doc = "- `call_hash`: The hash of the call to be made by the `real` account."] pub fn remove_announcement (& self , real : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , call_hash : :: subxt :: utils :: H256 ,) -> :: subxt :: tx :: Payload < RemoveAnnouncement > { :: subxt :: tx :: Payload :: new_static ("Proxy" , "remove_announcement" , RemoveAnnouncement { real , call_hash , } , [251u8 , 236u8 , 113u8 , 182u8 , 125u8 , 244u8 , 31u8 , 144u8 , 66u8 , 28u8 , 65u8 , 97u8 , 67u8 , 94u8 , 225u8 , 210u8 , 46u8 , 143u8 , 242u8 , 124u8 , 120u8 , 93u8 , 23u8 , 165u8 , 83u8 , 177u8 , 250u8 , 171u8 , 58u8 , 66u8 , 70u8 , 64u8 ,]) } # [doc = "Remove the given announcement of a delegate."] # [doc = ""] # [doc = "May be called by a target (proxied) account to remove a call that one of their delegates"] # [doc = "(`delegate`) has announced they want to execute. The deposit is returned."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `delegate`: The account that previously announced the call."] # [doc = "- `call_hash`: The hash of the call to be made."] pub fn reject_announcement (& self , delegate : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , call_hash : :: subxt :: utils :: H256 ,) -> :: subxt :: tx :: Payload < RejectAnnouncement > { :: subxt :: tx :: Payload :: new_static ("Proxy" , "reject_announcement" , RejectAnnouncement { delegate , call_hash , } , [122u8 , 165u8 , 114u8 , 85u8 , 209u8 , 197u8 , 11u8 , 96u8 , 211u8 , 93u8 , 201u8 , 42u8 , 1u8 , 131u8 , 254u8 , 177u8 , 191u8 , 212u8 , 229u8 , 13u8 , 28u8 , 163u8 , 133u8 , 200u8 , 113u8 , 28u8 , 132u8 , 45u8 , 105u8 , 177u8 , 82u8 , 206u8 ,]) } # [doc = "Dispatch the given `call` from an account that the sender is authorized for through"] # [doc = "`add_proxy`."] # [doc = ""] # [doc = "Removes any corresponding announcement(s)."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `real`: The account that the proxy will make a call on behalf of."] # [doc = "- `force_proxy_type`: Specify the exact proxy type to be used and checked for this call."] # [doc = "- `call`: The call to be made by the `real` account."] pub fn proxy_announced (& self , delegate : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , real : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , force_proxy_type : :: core :: option :: Option < runtime_types :: golden_gate_runtime_testnet :: poa :: ProxyType > , call : runtime_types :: golden_gate_runtime_testnet :: RuntimeCall ,) -> :: subxt :: tx :: Payload < ProxyAnnounced > { :: subxt :: tx :: Payload :: new_static ("Proxy" , "proxy_announced" , ProxyAnnounced { delegate , real , force_proxy_type , call : :: std :: boxed :: Box :: new (call) , } , [58u8 , 232u8 , 175u8 , 255u8 , 203u8 , 48u8 , 162u8 , 229u8 , 151u8 , 200u8 , 161u8 , 24u8 , 97u8 , 146u8 , 193u8 , 151u8 , 249u8 , 178u8 , 229u8 , 203u8 , 215u8 , 65u8 , 5u8 , 185u8 , 121u8 , 45u8 , 0u8 , 176u8 , 212u8 , 25u8 , 122u8 , 17u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_proxy :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A proxy was executed correctly, with the given."] pub struct ProxyExecuted { pub result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } impl :: subxt :: events :: StaticEvent for ProxyExecuted { const PALLET : & 'static str = "Proxy" ; const EVENT : & 'static str = "ProxyExecuted" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A pure account has been created by new proxy with given"] # [doc = "disambiguation index and proxy type."] pub struct PureCreated { pub pure : :: subxt :: utils :: AccountId32 , pub who : :: subxt :: utils :: AccountId32 , pub proxy_type : runtime_types :: golden_gate_runtime_testnet :: poa :: ProxyType , pub disambiguation_index : :: core :: primitive :: u16 , } impl :: subxt :: events :: StaticEvent for PureCreated { const PALLET : & 'static str = "Proxy" ; const EVENT : & 'static str = "PureCreated" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "An announcement was placed to make a call in the future."] pub struct Announced { pub real : :: subxt :: utils :: AccountId32 , pub proxy : :: subxt :: utils :: AccountId32 , pub call_hash : :: subxt :: utils :: H256 , } impl :: subxt :: events :: StaticEvent for Announced { const PALLET : & 'static str = "Proxy" ; const EVENT : & 'static str = "Announced" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A proxy was added."] pub struct ProxyAdded { pub delegator : :: subxt :: utils :: AccountId32 , pub delegatee : :: subxt :: utils :: AccountId32 , pub proxy_type : runtime_types :: golden_gate_runtime_testnet :: poa :: ProxyType , pub delay : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for ProxyAdded { const PALLET : & 'static str = "Proxy" ; const EVENT : & 'static str = "ProxyAdded" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A proxy was removed."] pub struct ProxyRemoved { pub delegator : :: subxt :: utils :: AccountId32 , pub delegatee : :: subxt :: utils :: AccountId32 , pub proxy_type : runtime_types :: golden_gate_runtime_testnet :: poa :: ProxyType , pub delay : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for ProxyRemoved { const PALLET : & 'static str = "Proxy" ; const EVENT : & 'static str = "ProxyRemoved" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " The set of account proxies. Maps the account which has delegated to the accounts"] # [doc = " which are being delegated to, together with the amount held on deposit."] pub fn proxies (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: utils :: AccountId32 > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , (runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < runtime_types :: pallet_proxy :: ProxyDefinition < :: subxt :: utils :: AccountId32 , runtime_types :: golden_gate_runtime_testnet :: poa :: ProxyType , :: core :: primitive :: u32 > > , :: core :: primitive :: u128 ,) , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Proxy" , "Proxies" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ())] , [181u8 , 189u8 , 44u8 , 185u8 , 73u8 , 255u8 , 159u8 , 130u8 , 145u8 , 85u8 , 21u8 , 199u8 , 199u8 , 110u8 , 253u8 , 23u8 , 207u8 , 102u8 , 213u8 , 184u8 , 171u8 , 250u8 , 170u8 , 104u8 , 231u8 , 187u8 , 67u8 , 61u8 , 9u8 , 241u8 , 75u8 , 38u8 ,]) } # [doc = " The set of account proxies. Maps the account which has delegated to the accounts"] # [doc = " which are being delegated to, together with the amount held on deposit."] pub fn proxies_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , (runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < runtime_types :: pallet_proxy :: ProxyDefinition < :: subxt :: utils :: AccountId32 , runtime_types :: golden_gate_runtime_testnet :: poa :: ProxyType , :: core :: primitive :: u32 > > , :: core :: primitive :: u128 ,) , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Proxy" , "Proxies" , Vec :: new () , [181u8 , 189u8 , 44u8 , 185u8 , 73u8 , 255u8 , 159u8 , 130u8 , 145u8 , 85u8 , 21u8 , 199u8 , 199u8 , 110u8 , 253u8 , 23u8 , 207u8 , 102u8 , 213u8 , 184u8 , 171u8 , 250u8 , 170u8 , 104u8 , 231u8 , 187u8 , 67u8 , 61u8 , 9u8 , 241u8 , 75u8 , 38u8 ,]) } # [doc = " The announcements made by the proxy (key)."] pub fn announcements (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: utils :: AccountId32 > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , (runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < runtime_types :: pallet_proxy :: Announcement < :: subxt :: utils :: AccountId32 , :: subxt :: utils :: H256 , :: core :: primitive :: u32 > > , :: core :: primitive :: u128 ,) , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Proxy" , "Announcements" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ())] , [233u8 , 38u8 , 249u8 , 89u8 , 103u8 , 87u8 , 64u8 , 52u8 , 140u8 , 228u8 , 110u8 , 37u8 , 8u8 , 92u8 , 48u8 , 7u8 , 46u8 , 99u8 , 179u8 , 83u8 , 232u8 , 171u8 , 160u8 , 45u8 , 37u8 , 23u8 , 151u8 , 198u8 , 237u8 , 103u8 , 217u8 , 53u8 ,]) } # [doc = " The announcements made by the proxy (key)."] pub fn announcements_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , (runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < runtime_types :: pallet_proxy :: Announcement < :: subxt :: utils :: AccountId32 , :: subxt :: utils :: H256 , :: core :: primitive :: u32 > > , :: core :: primitive :: u128 ,) , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Proxy" , "Announcements" , Vec :: new () , [233u8 , 38u8 , 249u8 , 89u8 , 103u8 , 87u8 , 64u8 , 52u8 , 140u8 , 228u8 , 110u8 , 37u8 , 8u8 , 92u8 , 48u8 , 7u8 , 46u8 , 99u8 , 179u8 , 83u8 , 232u8 , 171u8 , 160u8 , 45u8 , 37u8 , 23u8 , 151u8 , 198u8 , 237u8 , 103u8 , 217u8 , 53u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The base amount of currency needed to reserve for creating a proxy."] # [doc = ""] # [doc = " This is held for an additional storage item whose value size is"] # [doc = " `sizeof(Balance)` bytes and whose key size is `sizeof(AccountId)` bytes."] pub fn proxy_deposit_base (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u128 > { :: subxt :: constants :: Address :: new_static ("Proxy" , "ProxyDepositBase" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The amount of currency needed per proxy added."] # [doc = ""] # [doc = " This is held for adding 32 bytes plus an instance of `ProxyType` more into a"] # [doc = " pre-existing storage value. Thus, when configuring `ProxyDepositFactor` one should take"] # [doc = " into account `32 + proxy_type.encode().len()` bytes of data."] pub fn proxy_deposit_factor (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u128 > { :: subxt :: constants :: Address :: new_static ("Proxy" , "ProxyDepositFactor" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The maximum amount of proxies allowed for a single account."] pub fn max_proxies (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u32 > { :: subxt :: constants :: Address :: new_static ("Proxy" , "MaxProxies" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The maximum amount of time-delayed announcements that are allowed to be pending."] pub fn max_pending (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u32 > { :: subxt :: constants :: Address :: new_static ("Proxy" , "MaxPending" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The base amount of currency needed to reserve for creating an announcement."] # [doc = ""] # [doc = " This is held when a new storage item holding a `Balance` is created (typically 16"] # [doc = " bytes)."] pub fn announcement_deposit_base (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u128 > { :: subxt :: constants :: Address :: new_static ("Proxy" , "AnnouncementDepositBase" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The amount of currency needed per announcement made."] # [doc = ""] # [doc = " This is held for adding an `AccountId`, `Hash` and `BlockNumber` (typically 68 bytes)"] # [doc = " into a pre-existing storage value."] pub fn announcement_deposit_factor (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u128 > { :: subxt :: constants :: Address :: new_static ("Proxy" , "AnnouncementDepositFactor" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } } } } pub mod multisig { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct AsMultiThreshold1 { pub other_signatories : :: std :: vec :: Vec < :: subxt :: utils :: AccountId32 > , pub call : :: std :: boxed :: Box < runtime_types :: golden_gate_runtime_testnet :: RuntimeCall > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct AsMulti { pub threshold : :: core :: primitive :: u16 , pub other_signatories : :: std :: vec :: Vec < :: subxt :: utils :: AccountId32 > , pub maybe_timepoint : :: core :: option :: Option < runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > > , pub call : :: std :: boxed :: Box < runtime_types :: golden_gate_runtime_testnet :: RuntimeCall > , pub max_weight : runtime_types :: sp_weights :: weight_v2 :: Weight , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct ApproveAsMulti { pub threshold : :: core :: primitive :: u16 , pub other_signatories : :: std :: vec :: Vec < :: subxt :: utils :: AccountId32 > , pub maybe_timepoint : :: core :: option :: Option < runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > > , pub call_hash : [:: core :: primitive :: u8 ; 32usize] , pub max_weight : runtime_types :: sp_weights :: weight_v2 :: Weight , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct CancelAsMulti { pub threshold : :: core :: primitive :: u16 , pub other_signatories : :: std :: vec :: Vec < :: subxt :: utils :: AccountId32 > , pub timepoint : runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , pub call_hash : [:: core :: primitive :: u8 ; 32usize] , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Immediately dispatch a multi-signature call using a single approval from the caller."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `other_signatories`: The accounts (other than the sender) who are part of the"] # [doc = "multi-signature, but do not participate in the approval process."] # [doc = "- `call`: The call to be executed."] # [doc = ""] # [doc = "Result is equivalent to the dispatched result."] # [doc = ""] # [doc = "## Complexity"] # [doc = "O(Z + C) where Z is the length of the call and C its execution weight."] pub fn as_multi_threshold_1 (& self , other_signatories : :: std :: vec :: Vec < :: subxt :: utils :: AccountId32 > , call : runtime_types :: golden_gate_runtime_testnet :: RuntimeCall ,) -> :: subxt :: tx :: Payload < AsMultiThreshold1 > { :: subxt :: tx :: Payload :: new_static ("Multisig" , "as_multi_threshold_1" , AsMultiThreshold1 { other_signatories , call : :: std :: boxed :: Box :: new (call) , } , [199u8 , 249u8 , 72u8 , 255u8 , 198u8 , 120u8 , 214u8 , 196u8 , 62u8 , 32u8 , 2u8 , 216u8 , 60u8 , 215u8 , 17u8 , 217u8 , 233u8 , 65u8 , 231u8 , 209u8 , 194u8 , 192u8 , 252u8 , 201u8 , 23u8 , 134u8 , 173u8 , 127u8 , 84u8 , 242u8 , 184u8 , 75u8 ,]) } # [doc = "Register approval for a dispatch to be made from a deterministic composite account if"] # [doc = "approved by a total of `threshold - 1` of `other_signatories`."] # [doc = ""] # [doc = "If there are enough, then dispatch the call."] # [doc = ""] # [doc = "Payment: `DepositBase` will be reserved if this is the first approval, plus"] # [doc = "`threshold` times `DepositFactor`. It is returned once this dispatch happens or"] # [doc = "is cancelled."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `threshold`: The total number of approvals for this dispatch before it is executed."] # [doc = "- `other_signatories`: The accounts (other than the sender) who can approve this"] # [doc = "dispatch. May not be empty."] # [doc = "- `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is"] # [doc = "not the first approval, then it must be `Some`, with the timepoint (block number and"] # [doc = "transaction index) of the first approval transaction."] # [doc = "- `call`: The call to be executed."] # [doc = ""] # [doc = "NOTE: Unless this is the final approval, you will generally want to use"] # [doc = "`approve_as_multi` instead, since it only requires a hash of the call."] # [doc = ""] # [doc = "Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise"] # [doc = "on success, result is `Ok` and the result from the interior call, if it was executed,"] # [doc = "may be found in the deposited `MultisigExecuted` event."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(S + Z + Call)`."] # [doc = "- Up to one balance-reserve or unreserve operation."] # [doc = "- One passthrough operation, one insert, both `O(S)` where `S` is the number of"] # [doc = "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional."] # [doc = "- One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len."] # [doc = "- One encode & hash, both of complexity `O(S)`."] # [doc = "- Up to one binary search and insert (`O(logS + S)`)."] # [doc = "- I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove."] # [doc = "- One event."] # [doc = "- The weight of the `call`."] # [doc = "- Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit"] # [doc = "  taken for its lifetime of `DepositBase + threshold * DepositFactor`."] pub fn as_multi (& self , threshold : :: core :: primitive :: u16 , other_signatories : :: std :: vec :: Vec < :: subxt :: utils :: AccountId32 > , maybe_timepoint : :: core :: option :: Option < runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > > , call : runtime_types :: golden_gate_runtime_testnet :: RuntimeCall , max_weight : runtime_types :: sp_weights :: weight_v2 :: Weight ,) -> :: subxt :: tx :: Payload < AsMulti > { :: subxt :: tx :: Payload :: new_static ("Multisig" , "as_multi" , AsMulti { threshold , other_signatories , maybe_timepoint , call : :: std :: boxed :: Box :: new (call) , max_weight , } , [31u8 , 51u8 , 80u8 , 253u8 , 54u8 , 23u8 , 102u8 , 51u8 , 169u8 , 204u8 , 110u8 , 169u8 , 33u8 , 236u8 , 124u8 , 153u8 , 126u8 , 223u8 , 86u8 , 141u8 , 127u8 , 98u8 , 99u8 , 114u8 , 168u8 , 114u8 , 45u8 , 104u8 , 215u8 , 103u8 , 142u8 , 143u8 ,]) } # [doc = "Register approval for a dispatch to be made from a deterministic composite account if"] # [doc = "approved by a total of `threshold - 1` of `other_signatories`."] # [doc = ""] # [doc = "Payment: `DepositBase` will be reserved if this is the first approval, plus"] # [doc = "`threshold` times `DepositFactor`. It is returned once this dispatch happens or"] # [doc = "is cancelled."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `threshold`: The total number of approvals for this dispatch before it is executed."] # [doc = "- `other_signatories`: The accounts (other than the sender) who can approve this"] # [doc = "dispatch. May not be empty."] # [doc = "- `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is"] # [doc = "not the first approval, then it must be `Some`, with the timepoint (block number and"] # [doc = "transaction index) of the first approval transaction."] # [doc = "- `call_hash`: The hash of the call to be executed."] # [doc = ""] # [doc = "NOTE: If this is the final approval, you will want to use `as_multi` instead."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(S)`."] # [doc = "- Up to one balance-reserve or unreserve operation."] # [doc = "- One passthrough operation, one insert, both `O(S)` where `S` is the number of"] # [doc = "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional."] # [doc = "- One encode & hash, both of complexity `O(S)`."] # [doc = "- Up to one binary search and insert (`O(logS + S)`)."] # [doc = "- I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove."] # [doc = "- One event."] # [doc = "- Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit"] # [doc = "  taken for its lifetime of `DepositBase + threshold * DepositFactor`."] pub fn approve_as_multi (& self , threshold : :: core :: primitive :: u16 , other_signatories : :: std :: vec :: Vec < :: subxt :: utils :: AccountId32 > , maybe_timepoint : :: core :: option :: Option < runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > > , call_hash : [:: core :: primitive :: u8 ; 32usize] , max_weight : runtime_types :: sp_weights :: weight_v2 :: Weight ,) -> :: subxt :: tx :: Payload < ApproveAsMulti > { :: subxt :: tx :: Payload :: new_static ("Multisig" , "approve_as_multi" , ApproveAsMulti { threshold , other_signatories , maybe_timepoint , call_hash , max_weight , } , [133u8 , 113u8 , 121u8 , 66u8 , 218u8 , 219u8 , 48u8 , 64u8 , 211u8 , 114u8 , 163u8 , 193u8 , 164u8 , 21u8 , 140u8 , 218u8 , 253u8 , 237u8 , 240u8 , 126u8 , 200u8 , 213u8 , 184u8 , 50u8 , 187u8 , 182u8 , 30u8 , 52u8 , 142u8 , 72u8 , 210u8 , 101u8 ,]) } # [doc = "Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously"] # [doc = "for this operation will be unreserved on success."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `threshold`: The total number of approvals for this dispatch before it is executed."] # [doc = "- `other_signatories`: The accounts (other than the sender) who can approve this"] # [doc = "dispatch. May not be empty."] # [doc = "- `timepoint`: The timepoint (block number and transaction index) of the first approval"] # [doc = "transaction for this dispatch."] # [doc = "- `call_hash`: The hash of the call to be executed."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(S)`."] # [doc = "- Up to one balance-reserve or unreserve operation."] # [doc = "- One passthrough operation, one insert, both `O(S)` where `S` is the number of"] # [doc = "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional."] # [doc = "- One encode & hash, both of complexity `O(S)`."] # [doc = "- One event."] # [doc = "- I/O: 1 read `O(S)`, one remove."] # [doc = "- Storage: removes one item."] pub fn cancel_as_multi (& self , threshold : :: core :: primitive :: u16 , other_signatories : :: std :: vec :: Vec < :: subxt :: utils :: AccountId32 > , timepoint : runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , call_hash : [:: core :: primitive :: u8 ; 32usize] ,) -> :: subxt :: tx :: Payload < CancelAsMulti > { :: subxt :: tx :: Payload :: new_static ("Multisig" , "cancel_as_multi" , CancelAsMulti { threshold , other_signatories , timepoint , call_hash , } , [30u8 , 25u8 , 186u8 , 142u8 , 168u8 , 81u8 , 235u8 , 164u8 , 82u8 , 209u8 , 66u8 , 129u8 , 209u8 , 78u8 , 172u8 , 9u8 , 163u8 , 222u8 , 125u8 , 57u8 , 2u8 , 43u8 , 169u8 , 174u8 , 159u8 , 167u8 , 25u8 , 226u8 , 254u8 , 110u8 , 80u8 , 216u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_multisig :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A new multisig operation has begun."] pub struct NewMultisig { pub approving : :: subxt :: utils :: AccountId32 , pub multisig : :: subxt :: utils :: AccountId32 , pub call_hash : [:: core :: primitive :: u8 ; 32usize] , } impl :: subxt :: events :: StaticEvent for NewMultisig { const PALLET : & 'static str = "Multisig" ; const EVENT : & 'static str = "NewMultisig" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A multisig operation has been approved by someone."] pub struct MultisigApproval { pub approving : :: subxt :: utils :: AccountId32 , pub timepoint : runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , pub multisig : :: subxt :: utils :: AccountId32 , pub call_hash : [:: core :: primitive :: u8 ; 32usize] , } impl :: subxt :: events :: StaticEvent for MultisigApproval { const PALLET : & 'static str = "Multisig" ; const EVENT : & 'static str = "MultisigApproval" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A multisig operation has been executed."] pub struct MultisigExecuted { pub approving : :: subxt :: utils :: AccountId32 , pub timepoint : runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , pub multisig : :: subxt :: utils :: AccountId32 , pub call_hash : [:: core :: primitive :: u8 ; 32usize] , pub result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } impl :: subxt :: events :: StaticEvent for MultisigExecuted { const PALLET : & 'static str = "Multisig" ; const EVENT : & 'static str = "MultisigExecuted" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A multisig operation has been cancelled."] pub struct MultisigCancelled { pub cancelling : :: subxt :: utils :: AccountId32 , pub timepoint : runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , pub multisig : :: subxt :: utils :: AccountId32 , pub call_hash : [:: core :: primitive :: u8 ; 32usize] , } impl :: subxt :: events :: StaticEvent for MultisigCancelled { const PALLET : & 'static str = "Multisig" ; const EVENT : & 'static str = "MultisigCancelled" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " The set of open multisig operations."] pub fn multisigs (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: utils :: AccountId32 > , _1 : impl :: std :: borrow :: Borrow < [:: core :: primitive :: u8 ; 32usize] > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: pallet_multisig :: Multisig < :: core :: primitive :: u32 , :: core :: primitive :: u128 , :: subxt :: utils :: AccountId32 > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Multisig" , "Multisigs" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ()) , :: subxt :: storage :: address :: make_static_storage_map_key (_1 . borrow ())] , [69u8 , 153u8 , 186u8 , 204u8 , 117u8 , 95u8 , 119u8 , 182u8 , 220u8 , 87u8 , 8u8 , 15u8 , 123u8 , 83u8 , 5u8 , 188u8 , 115u8 , 121u8 , 163u8 , 96u8 , 218u8 , 3u8 , 106u8 , 44u8 , 44u8 , 187u8 , 46u8 , 238u8 , 80u8 , 203u8 , 175u8 , 155u8 ,]) } # [doc = " The set of open multisig operations."] pub fn multisigs_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: pallet_multisig :: Multisig < :: core :: primitive :: u32 , :: core :: primitive :: u128 , :: subxt :: utils :: AccountId32 > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Multisig" , "Multisigs" , Vec :: new () , [69u8 , 153u8 , 186u8 , 204u8 , 117u8 , 95u8 , 119u8 , 182u8 , 220u8 , 87u8 , 8u8 , 15u8 , 123u8 , 83u8 , 5u8 , 188u8 , 115u8 , 121u8 , 163u8 , 96u8 , 218u8 , 3u8 , 106u8 , 44u8 , 44u8 , 187u8 , 46u8 , 238u8 , 80u8 , 203u8 , 175u8 , 155u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The base amount of currency needed to reserve for creating a multisig execution or to"] # [doc = " store a dispatch call for later."] # [doc = ""] # [doc = " This is held for an additional storage item whose value size is"] # [doc = " `4 + sizeof((BlockNumber, Balance, AccountId))` bytes and whose key size is"] # [doc = " `32 + sizeof(AccountId)` bytes."] pub fn deposit_base (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u128 > { :: subxt :: constants :: Address :: new_static ("Multisig" , "DepositBase" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The amount of currency needed per unit threshold when creating a multisig execution."] # [doc = ""] # [doc = " This is held for adding 32 bytes more into a pre-existing storage value."] pub fn deposit_factor (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u128 > { :: subxt :: constants :: Address :: new_static ("Multisig" , "DepositFactor" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The maximum amount of signatories allowed in the multisig."] pub fn max_signatories (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u32 > { :: subxt :: constants :: Address :: new_static ("Multisig" , "MaxSignatories" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod identity { use super :: root_mod ; use super :: runtime_types ; # [doc = "Identity pallet declaration."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct AddRegistrar { pub account : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct SetIdentity { pub info : :: std :: boxed :: Box < runtime_types :: pallet_identity :: types :: IdentityInfo > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct SetSubs { pub subs : :: std :: vec :: Vec < (:: subxt :: utils :: AccountId32 , runtime_types :: pallet_identity :: types :: Data ,) > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct ClearIdentity ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct RequestJudgement { # [codec (compact)] pub reg_index : :: core :: primitive :: u32 , # [codec (compact)] pub max_fee : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct CancelRequest { pub reg_index : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct SetFee { # [codec (compact)] pub index : :: core :: primitive :: u32 , # [codec (compact)] pub fee : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct SetAccountId { # [codec (compact)] pub index : :: core :: primitive :: u32 , pub new : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct SetFields { # [codec (compact)] pub index : :: core :: primitive :: u32 , pub fields : runtime_types :: pallet_identity :: types :: BitFlags < runtime_types :: pallet_identity :: types :: IdentityField > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct ProvideJudgement { # [codec (compact)] pub reg_index : :: core :: primitive :: u32 , pub target : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , pub judgement : runtime_types :: pallet_identity :: types :: Judgement < :: core :: primitive :: u128 > , pub identity : :: subxt :: utils :: H256 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct KillIdentity { pub target : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct AddSub { pub sub : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , pub data : runtime_types :: pallet_identity :: types :: Data , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct RenameSub { pub sub : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , pub data : runtime_types :: pallet_identity :: types :: Data , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct RemoveSub { pub sub : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct QuitSub ; pub struct TransactionApi ; impl TransactionApi { # [doc = "Add a registrar to the system."] # [doc = ""] # [doc = "The dispatch origin for this call must be `T::RegistrarOrigin`."] # [doc = ""] # [doc = "- `account`: the account of the registrar."] # [doc = ""] # [doc = "Emits `RegistrarAdded` if successful."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(R)` where `R` registrar-count (governance-bounded and code-bounded)."] pub fn add_registrar (& self , account : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > ,) -> :: subxt :: tx :: Payload < AddRegistrar > { :: subxt :: tx :: Payload :: new_static ("Identity" , "add_registrar" , AddRegistrar { account , } , [96u8 , 200u8 , 92u8 , 23u8 , 3u8 , 144u8 , 56u8 , 53u8 , 245u8 , 210u8 , 33u8 , 36u8 , 183u8 , 233u8 , 41u8 , 1u8 , 127u8 , 2u8 , 25u8 , 5u8 , 15u8 , 133u8 , 4u8 , 107u8 , 206u8 , 155u8 , 114u8 , 39u8 , 14u8 , 235u8 , 115u8 , 172u8 ,]) } # [doc = "Set an account's identity information and reserve the appropriate deposit."] # [doc = ""] # [doc = "If the account already has identity information, the deposit is taken as part payment"] # [doc = "for the new deposit."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `info`: The identity information."] # [doc = ""] # [doc = "Emits `IdentitySet` if successful."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(X + X' + R)`"] # [doc = "  - where `X` additional-field-count (deposit-bounded and code-bounded)"] # [doc = "  - where `R` judgements-count (registrar-count-bounded)"] pub fn set_identity (& self , info : runtime_types :: pallet_identity :: types :: IdentityInfo ,) -> :: subxt :: tx :: Payload < SetIdentity > { :: subxt :: tx :: Payload :: new_static ("Identity" , "set_identity" , SetIdentity { info : :: std :: boxed :: Box :: new (info) , } , [130u8 , 89u8 , 118u8 , 6u8 , 134u8 , 166u8 , 35u8 , 192u8 , 73u8 , 6u8 , 171u8 , 20u8 , 225u8 , 255u8 , 152u8 , 142u8 , 111u8 , 8u8 , 206u8 , 200u8 , 64u8 , 52u8 , 110u8 , 123u8 , 42u8 , 101u8 , 191u8 , 242u8 , 133u8 , 139u8 , 154u8 , 205u8 ,]) } # [doc = "Set the sub-accounts of the sender."] # [doc = ""] # [doc = "Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned"] # [doc = "and an amount `SubAccountDeposit` will be reserved for each item in `subs`."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a registered"] # [doc = "identity."] # [doc = ""] # [doc = "- `subs`: The identity's (new) sub-accounts."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(P + S)`"] # [doc = "  - where `P` old-subs-count (hard- and deposit-bounded)."] # [doc = "  - where `S` subs-count (hard- and deposit-bounded)."] pub fn set_subs (& self , subs : :: std :: vec :: Vec < (:: subxt :: utils :: AccountId32 , runtime_types :: pallet_identity :: types :: Data ,) > ,) -> :: subxt :: tx :: Payload < SetSubs > { :: subxt :: tx :: Payload :: new_static ("Identity" , "set_subs" , SetSubs { subs , } , [177u8 , 219u8 , 84u8 , 183u8 , 5u8 , 32u8 , 192u8 , 82u8 , 174u8 , 68u8 , 198u8 , 224u8 , 56u8 , 85u8 , 134u8 , 171u8 , 30u8 , 132u8 , 140u8 , 236u8 , 117u8 , 24u8 , 150u8 , 218u8 , 146u8 , 194u8 , 144u8 , 92u8 , 103u8 , 206u8 , 46u8 , 90u8 ,]) } # [doc = "Clear an account's identity info and all sub-accounts and return all deposits."] # [doc = ""] # [doc = "Payment: All reserved balances on the account are returned."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a registered"] # [doc = "identity."] # [doc = ""] # [doc = "Emits `IdentityCleared` if successful."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(R + S + X)`"] # [doc = "  - where `R` registrar-count (governance-bounded)."] # [doc = "  - where `S` subs-count (hard- and deposit-bounded)."] # [doc = "  - where `X` additional-field-count (deposit-bounded and code-bounded)."] pub fn clear_identity (& self ,) -> :: subxt :: tx :: Payload < ClearIdentity > { :: subxt :: tx :: Payload :: new_static ("Identity" , "clear_identity" , ClearIdentity { } , [75u8 , 44u8 , 74u8 , 122u8 , 149u8 , 202u8 , 114u8 , 230u8 , 0u8 , 255u8 , 140u8 , 122u8 , 14u8 , 196u8 , 205u8 , 249u8 , 220u8 , 94u8 , 216u8 , 34u8 , 63u8 , 14u8 , 8u8 , 205u8 , 74u8 , 23u8 , 181u8 , 129u8 , 252u8 , 110u8 , 231u8 , 114u8 ,]) } # [doc = "Request a judgement from a registrar."] # [doc = ""] # [doc = "Payment: At most `max_fee` will be reserved for payment to the registrar if judgement"] # [doc = "given."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a"] # [doc = "registered identity."] # [doc = ""] # [doc = "- `reg_index`: The index of the registrar whose judgement is requested."] # [doc = "- `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:"] # [doc = ""] # [doc = "```nocompile"] # [doc = "Self::registrars().get(reg_index).unwrap().fee"] # [doc = "```"] # [doc = ""] # [doc = "Emits `JudgementRequested` if successful."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(R + X)`."] # [doc = "  - where `R` registrar-count (governance-bounded)."] # [doc = "  - where `X` additional-field-count (deposit-bounded and code-bounded)."] pub fn request_judgement (& self , reg_index : :: core :: primitive :: u32 , max_fee : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: Payload < RequestJudgement > { :: subxt :: tx :: Payload :: new_static ("Identity" , "request_judgement" , RequestJudgement { reg_index , max_fee , } , [186u8 , 149u8 , 61u8 , 54u8 , 159u8 , 194u8 , 77u8 , 161u8 , 220u8 , 157u8 , 3u8 , 216u8 , 23u8 , 105u8 , 119u8 , 76u8 , 144u8 , 198u8 , 157u8 , 45u8 , 235u8 , 139u8 , 87u8 , 82u8 , 81u8 , 12u8 , 25u8 , 134u8 , 225u8 , 92u8 , 182u8 , 101u8 ,]) } # [doc = "Cancel a previous request."] # [doc = ""] # [doc = "Payment: A previously reserved deposit is returned on success."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a"] # [doc = "registered identity."] # [doc = ""] # [doc = "- `reg_index`: The index of the registrar whose judgement is no longer requested."] # [doc = ""] # [doc = "Emits `JudgementUnrequested` if successful."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(R + X)`."] # [doc = "  - where `R` registrar-count (governance-bounded)."] # [doc = "  - where `X` additional-field-count (deposit-bounded and code-bounded)."] pub fn cancel_request (& self , reg_index : :: core :: primitive :: u32 ,) -> :: subxt :: tx :: Payload < CancelRequest > { :: subxt :: tx :: Payload :: new_static ("Identity" , "cancel_request" , CancelRequest { reg_index , } , [83u8 , 180u8 , 239u8 , 126u8 , 32u8 , 51u8 , 17u8 , 20u8 , 180u8 , 3u8 , 59u8 , 96u8 , 24u8 , 32u8 , 136u8 , 92u8 , 58u8 , 254u8 , 68u8 , 70u8 , 50u8 , 11u8 , 51u8 , 91u8 , 180u8 , 79u8 , 81u8 , 84u8 , 216u8 , 138u8 , 6u8 , 215u8 ,]) } # [doc = "Set the fee required for a judgement to be requested from a registrar."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must be the account"] # [doc = "of the registrar whose index is `index`."] # [doc = ""] # [doc = "- `index`: the index of the registrar whose fee is to be set."] # [doc = "- `fee`: the new fee."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(R)`."] # [doc = "  - where `R` registrar-count (governance-bounded)."] pub fn set_fee (& self , index : :: core :: primitive :: u32 , fee : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: Payload < SetFee > { :: subxt :: tx :: Payload :: new_static ("Identity" , "set_fee" , SetFee { index , fee , } , [21u8 , 157u8 , 123u8 , 182u8 , 160u8 , 190u8 , 117u8 , 37u8 , 136u8 , 133u8 , 104u8 , 234u8 , 31u8 , 145u8 , 115u8 , 154u8 , 125u8 , 40u8 , 2u8 , 87u8 , 118u8 , 56u8 , 247u8 , 73u8 , 89u8 , 0u8 , 251u8 , 3u8 , 58u8 , 105u8 , 239u8 , 211u8 ,]) } # [doc = "Change the account associated with a registrar."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must be the account"] # [doc = "of the registrar whose index is `index`."] # [doc = ""] # [doc = "- `index`: the index of the registrar whose fee is to be set."] # [doc = "- `new`: the new account ID."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(R)`."] # [doc = "  - where `R` registrar-count (governance-bounded)."] pub fn set_account_id (& self , index : :: core :: primitive :: u32 , new : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > ,) -> :: subxt :: tx :: Payload < SetAccountId > { :: subxt :: tx :: Payload :: new_static ("Identity" , "set_account_id" , SetAccountId { index , new , } , [14u8 , 154u8 , 84u8 , 48u8 , 59u8 , 133u8 , 45u8 , 204u8 , 255u8 , 85u8 , 157u8 , 88u8 , 56u8 , 207u8 , 113u8 , 184u8 , 233u8 , 139u8 , 129u8 , 118u8 , 59u8 , 9u8 , 211u8 , 184u8 , 32u8 , 141u8 , 126u8 , 208u8 , 179u8 , 4u8 , 2u8 , 95u8 ,]) } # [doc = "Set the field information for a registrar."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must be the account"] # [doc = "of the registrar whose index is `index`."] # [doc = ""] # [doc = "- `index`: the index of the registrar whose fee is to be set."] # [doc = "- `fields`: the fields that the registrar concerns themselves with."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(R)`."] # [doc = "  - where `R` registrar-count (governance-bounded)."] pub fn set_fields (& self , index : :: core :: primitive :: u32 , fields : runtime_types :: pallet_identity :: types :: BitFlags < runtime_types :: pallet_identity :: types :: IdentityField > ,) -> :: subxt :: tx :: Payload < SetFields > { :: subxt :: tx :: Payload :: new_static ("Identity" , "set_fields" , SetFields { index , fields , } , [50u8 , 196u8 , 179u8 , 71u8 , 66u8 , 65u8 , 235u8 , 7u8 , 51u8 , 14u8 , 81u8 , 173u8 , 201u8 , 58u8 , 6u8 , 151u8 , 174u8 , 245u8 , 102u8 , 184u8 , 28u8 , 84u8 , 125u8 , 93u8 , 126u8 , 134u8 , 92u8 , 203u8 , 200u8 , 129u8 , 240u8 , 252u8 ,]) } # [doc = "Provide a judgement for an account's identity."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must be the account"] # [doc = "of the registrar whose index is `reg_index`."] # [doc = ""] # [doc = "- `reg_index`: the index of the registrar whose judgement is being made."] # [doc = "- `target`: the account whose identity the judgement is upon. This must be an account"] # [doc = "  with a registered identity."] # [doc = "- `judgement`: the judgement of the registrar of index `reg_index` about `target`."] # [doc = "- `identity`: The hash of the [`IdentityInfo`] for that the judgement is provided."] # [doc = ""] # [doc = "Emits `JudgementGiven` if successful."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(R + X)`."] # [doc = "  - where `R` registrar-count (governance-bounded)."] # [doc = "  - where `X` additional-field-count (deposit-bounded and code-bounded)."] pub fn provide_judgement (& self , reg_index : :: core :: primitive :: u32 , target : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , judgement : runtime_types :: pallet_identity :: types :: Judgement < :: core :: primitive :: u128 > , identity : :: subxt :: utils :: H256 ,) -> :: subxt :: tx :: Payload < ProvideJudgement > { :: subxt :: tx :: Payload :: new_static ("Identity" , "provide_judgement" , ProvideJudgement { reg_index , target , judgement , identity , } , [83u8 , 253u8 , 77u8 , 208u8 , 198u8 , 25u8 , 202u8 , 213u8 , 223u8 , 184u8 , 231u8 , 185u8 , 186u8 , 216u8 , 54u8 , 62u8 , 3u8 , 7u8 , 107u8 , 152u8 , 126u8 , 195u8 , 175u8 , 221u8 , 134u8 , 169u8 , 199u8 , 124u8 , 232u8 , 157u8 , 67u8 , 75u8 ,]) } # [doc = "Remove an account's identity and sub-account information and slash the deposits."] # [doc = ""] # [doc = "Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by"] # [doc = "`Slash`. Verification request deposits are not returned; they should be cancelled"] # [doc = "manually using `cancel_request`."] # [doc = ""] # [doc = "The dispatch origin for this call must match `T::ForceOrigin`."] # [doc = ""] # [doc = "- `target`: the account whose identity the judgement is upon. This must be an account"] # [doc = "  with a registered identity."] # [doc = ""] # [doc = "Emits `IdentityKilled` if successful."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(R + S + X)`"] # [doc = "  - where `R` registrar-count (governance-bounded)."] # [doc = "  - where `S` subs-count (hard- and deposit-bounded)."] # [doc = "  - where `X` additional-field-count (deposit-bounded and code-bounded)."] pub fn kill_identity (& self , target : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > ,) -> :: subxt :: tx :: Payload < KillIdentity > { :: subxt :: tx :: Payload :: new_static ("Identity" , "kill_identity" , KillIdentity { target , } , [65u8 , 106u8 , 116u8 , 209u8 , 219u8 , 181u8 , 185u8 , 75u8 , 146u8 , 194u8 , 187u8 , 170u8 , 7u8 , 34u8 , 140u8 , 87u8 , 107u8 , 112u8 , 229u8 , 34u8 , 65u8 , 71u8 , 58u8 , 152u8 , 74u8 , 253u8 , 137u8 , 69u8 , 149u8 , 214u8 , 158u8 , 19u8 ,]) } # [doc = "Add the given account to the sender's subs."] # [doc = ""] # [doc = "Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated"] # [doc = "to the sender."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a registered"] # [doc = "sub identity of `sub`."] pub fn add_sub (& self , sub : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , data : runtime_types :: pallet_identity :: types :: Data ,) -> :: subxt :: tx :: Payload < AddSub > { :: subxt :: tx :: Payload :: new_static ("Identity" , "add_sub" , AddSub { sub , data , } , [206u8 , 112u8 , 143u8 , 96u8 , 152u8 , 12u8 , 174u8 , 226u8 , 23u8 , 27u8 , 154u8 , 188u8 , 195u8 , 233u8 , 185u8 , 180u8 , 246u8 , 218u8 , 154u8 , 129u8 , 138u8 , 52u8 , 212u8 , 109u8 , 54u8 , 211u8 , 219u8 , 255u8 , 39u8 , 79u8 , 154u8 , 123u8 ,]) } # [doc = "Alter the associated name of the given sub-account."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a registered"] # [doc = "sub identity of `sub`."] pub fn rename_sub (& self , sub : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , data : runtime_types :: pallet_identity :: types :: Data ,) -> :: subxt :: tx :: Payload < RenameSub > { :: subxt :: tx :: Payload :: new_static ("Identity" , "rename_sub" , RenameSub { sub , data , } , [110u8 , 28u8 , 134u8 , 225u8 , 44u8 , 242u8 , 20u8 , 22u8 , 197u8 , 49u8 , 173u8 , 178u8 , 106u8 , 181u8 , 103u8 , 90u8 , 27u8 , 73u8 , 102u8 , 130u8 , 2u8 , 216u8 , 172u8 , 186u8 , 124u8 , 244u8 , 128u8 , 6u8 , 112u8 , 128u8 , 25u8 , 245u8 ,]) } # [doc = "Remove the given account from the sender's subs."] # [doc = ""] # [doc = "Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated"] # [doc = "to the sender."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a registered"] # [doc = "sub identity of `sub`."] pub fn remove_sub (& self , sub : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > ,) -> :: subxt :: tx :: Payload < RemoveSub > { :: subxt :: tx :: Payload :: new_static ("Identity" , "remove_sub" , RemoveSub { sub , } , [92u8 , 201u8 , 70u8 , 170u8 , 248u8 , 110u8 , 179u8 , 186u8 , 213u8 , 197u8 , 150u8 , 156u8 , 156u8 , 50u8 , 19u8 , 158u8 , 186u8 , 61u8 , 106u8 , 64u8 , 84u8 , 38u8 , 73u8 , 134u8 , 132u8 , 233u8 , 50u8 , 152u8 , 40u8 , 18u8 , 212u8 , 121u8 ,]) } # [doc = "Remove the sender as a sub-account."] # [doc = ""] # [doc = "Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated"] # [doc = "to the sender (*not* the original depositor)."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a registered"] # [doc = "super-identity."] # [doc = ""] # [doc = "NOTE: This should not normally be used, but is provided in the case that the non-"] # [doc = "controller of an account is maliciously registered as a sub-account."] pub fn quit_sub (& self ,) -> :: subxt :: tx :: Payload < QuitSub > { :: subxt :: tx :: Payload :: new_static ("Identity" , "quit_sub" , QuitSub { } , [62u8 , 57u8 , 73u8 , 72u8 , 119u8 , 216u8 , 250u8 , 155u8 , 57u8 , 169u8 , 157u8 , 44u8 , 87u8 , 51u8 , 63u8 , 231u8 , 77u8 , 7u8 , 0u8 , 119u8 , 244u8 , 42u8 , 179u8 , 51u8 , 254u8 , 240u8 , 55u8 , 25u8 , 142u8 , 38u8 , 87u8 , 44u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_identity :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A name was set or reset (which will remove all judgements)."] pub struct IdentitySet { pub who : :: subxt :: utils :: AccountId32 , } impl :: subxt :: events :: StaticEvent for IdentitySet { const PALLET : & 'static str = "Identity" ; const EVENT : & 'static str = "IdentitySet" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A name was cleared, and the given balance returned."] pub struct IdentityCleared { pub who : :: subxt :: utils :: AccountId32 , pub deposit : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for IdentityCleared { const PALLET : & 'static str = "Identity" ; const EVENT : & 'static str = "IdentityCleared" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A name was removed and the given balance slashed."] pub struct IdentityKilled { pub who : :: subxt :: utils :: AccountId32 , pub deposit : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for IdentityKilled { const PALLET : & 'static str = "Identity" ; const EVENT : & 'static str = "IdentityKilled" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A judgement was asked from a registrar."] pub struct JudgementRequested { pub who : :: subxt :: utils :: AccountId32 , pub registrar_index : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for JudgementRequested { const PALLET : & 'static str = "Identity" ; const EVENT : & 'static str = "JudgementRequested" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A judgement request was retracted."] pub struct JudgementUnrequested { pub who : :: subxt :: utils :: AccountId32 , pub registrar_index : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for JudgementUnrequested { const PALLET : & 'static str = "Identity" ; const EVENT : & 'static str = "JudgementUnrequested" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A judgement was given by a registrar."] pub struct JudgementGiven { pub target : :: subxt :: utils :: AccountId32 , pub registrar_index : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for JudgementGiven { const PALLET : & 'static str = "Identity" ; const EVENT : & 'static str = "JudgementGiven" ; } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A registrar was added."] pub struct RegistrarAdded { pub registrar_index : :: core :: primitive :: u32 , } impl :: subxt :: events :: StaticEvent for RegistrarAdded { const PALLET : & 'static str = "Identity" ; const EVENT : & 'static str = "RegistrarAdded" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A sub-identity was added to an identity and the deposit paid."] pub struct SubIdentityAdded { pub sub : :: subxt :: utils :: AccountId32 , pub main : :: subxt :: utils :: AccountId32 , pub deposit : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for SubIdentityAdded { const PALLET : & 'static str = "Identity" ; const EVENT : & 'static str = "SubIdentityAdded" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A sub-identity was removed from an identity and the deposit freed."] pub struct SubIdentityRemoved { pub sub : :: subxt :: utils :: AccountId32 , pub main : :: subxt :: utils :: AccountId32 , pub deposit : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for SubIdentityRemoved { const PALLET : & 'static str = "Identity" ; const EVENT : & 'static str = "SubIdentityRemoved" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A sub-identity was cleared, and the given deposit repatriated from the"] # [doc = "main identity account to the sub-identity account."] pub struct SubIdentityRevoked { pub sub : :: subxt :: utils :: AccountId32 , pub main : :: subxt :: utils :: AccountId32 , pub deposit : :: core :: primitive :: u128 , } impl :: subxt :: events :: StaticEvent for SubIdentityRevoked { const PALLET : & 'static str = "Identity" ; const EVENT : & 'static str = "SubIdentityRevoked" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " Information that is pertinent to identify the entity behind an account."] # [doc = ""] # [doc = " TWOX-NOTE: OK ― `AccountId` is a secure hash."] pub fn identity_of (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: utils :: AccountId32 > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: pallet_identity :: types :: Registration < :: core :: primitive :: u128 > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Identity" , "IdentityOf" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ())] , [193u8 , 195u8 , 180u8 , 188u8 , 129u8 , 250u8 , 180u8 , 219u8 , 22u8 , 95u8 , 175u8 , 170u8 , 143u8 , 188u8 , 80u8 , 124u8 , 234u8 , 228u8 , 245u8 , 39u8 , 72u8 , 153u8 , 107u8 , 199u8 , 23u8 , 75u8 , 47u8 , 247u8 , 104u8 , 208u8 , 171u8 , 82u8 ,]) } # [doc = " Information that is pertinent to identify the entity behind an account."] # [doc = ""] # [doc = " TWOX-NOTE: OK ― `AccountId` is a secure hash."] pub fn identity_of_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: pallet_identity :: types :: Registration < :: core :: primitive :: u128 > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Identity" , "IdentityOf" , Vec :: new () , [193u8 , 195u8 , 180u8 , 188u8 , 129u8 , 250u8 , 180u8 , 219u8 , 22u8 , 95u8 , 175u8 , 170u8 , 143u8 , 188u8 , 80u8 , 124u8 , 234u8 , 228u8 , 245u8 , 39u8 , 72u8 , 153u8 , 107u8 , 199u8 , 23u8 , 75u8 , 47u8 , 247u8 , 104u8 , 208u8 , 171u8 , 82u8 ,]) } # [doc = " The super-identity of an alternative \"sub\" identity together with its name, within that"] # [doc = " context. If the account is not some other account's sub-identity, then just `None`."] pub fn super_of (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: utils :: AccountId32 > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , (:: subxt :: utils :: AccountId32 , runtime_types :: pallet_identity :: types :: Data ,) , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Identity" , "SuperOf" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ())] , [170u8 , 249u8 , 112u8 , 249u8 , 75u8 , 176u8 , 21u8 , 29u8 , 152u8 , 149u8 , 69u8 , 113u8 , 20u8 , 92u8 , 113u8 , 130u8 , 135u8 , 62u8 , 18u8 , 204u8 , 166u8 , 193u8 , 133u8 , 167u8 , 248u8 , 117u8 , 80u8 , 137u8 , 158u8 , 111u8 , 100u8 , 137u8 ,]) } # [doc = " The super-identity of an alternative \"sub\" identity together with its name, within that"] # [doc = " context. If the account is not some other account's sub-identity, then just `None`."] pub fn super_of_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , (:: subxt :: utils :: AccountId32 , runtime_types :: pallet_identity :: types :: Data ,) , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Identity" , "SuperOf" , Vec :: new () , [170u8 , 249u8 , 112u8 , 249u8 , 75u8 , 176u8 , 21u8 , 29u8 , 152u8 , 149u8 , 69u8 , 113u8 , 20u8 , 92u8 , 113u8 , 130u8 , 135u8 , 62u8 , 18u8 , 204u8 , 166u8 , 193u8 , 133u8 , 167u8 , 248u8 , 117u8 , 80u8 , 137u8 , 158u8 , 111u8 , 100u8 , 137u8 ,]) } # [doc = " Alternative \"sub\" identities of this account."] # [doc = ""] # [doc = " The first item is the deposit, the second is a vector of the accounts."] # [doc = ""] # [doc = " TWOX-NOTE: OK ― `AccountId` is a secure hash."] pub fn subs_of (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: utils :: AccountId32 > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , (:: core :: primitive :: u128 , runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < :: subxt :: utils :: AccountId32 > ,) , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Identity" , "SubsOf" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ())] , [128u8 , 15u8 , 175u8 , 155u8 , 216u8 , 225u8 , 200u8 , 169u8 , 215u8 , 206u8 , 110u8 , 22u8 , 204u8 , 89u8 , 212u8 , 210u8 , 159u8 , 169u8 , 53u8 , 7u8 , 44u8 , 164u8 , 91u8 , 151u8 , 7u8 , 227u8 , 38u8 , 230u8 , 175u8 , 84u8 , 6u8 , 4u8 ,]) } # [doc = " Alternative \"sub\" identities of this account."] # [doc = ""] # [doc = " The first item is the deposit, the second is a vector of the accounts."] # [doc = ""] # [doc = " TWOX-NOTE: OK ― `AccountId` is a secure hash."] pub fn subs_of_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , (:: core :: primitive :: u128 , runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < :: subxt :: utils :: AccountId32 > ,) , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Identity" , "SubsOf" , Vec :: new () , [128u8 , 15u8 , 175u8 , 155u8 , 216u8 , 225u8 , 200u8 , 169u8 , 215u8 , 206u8 , 110u8 , 22u8 , 204u8 , 89u8 , 212u8 , 210u8 , 159u8 , 169u8 , 53u8 , 7u8 , 44u8 , 164u8 , 91u8 , 151u8 , 7u8 , 227u8 , 38u8 , 230u8 , 175u8 , 84u8 , 6u8 , 4u8 ,]) } # [doc = " The set of registrars. Not expected to get very big as can only be added through a"] # [doc = " special origin (likely a council motion)."] # [doc = ""] # [doc = " The index into this can be cast to `RegistrarIndex` to get a valid value."] pub fn registrars (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < :: core :: option :: Option < runtime_types :: pallet_identity :: types :: RegistrarInfo < :: core :: primitive :: u128 , :: subxt :: utils :: AccountId32 > > > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("Identity" , "Registrars" , vec ! [] , [157u8 , 87u8 , 39u8 , 240u8 , 154u8 , 54u8 , 241u8 , 229u8 , 76u8 , 9u8 , 62u8 , 252u8 , 40u8 , 143u8 , 186u8 , 182u8 , 233u8 , 187u8 , 251u8 , 61u8 , 236u8 , 229u8 , 19u8 , 55u8 , 42u8 , 36u8 , 82u8 , 173u8 , 215u8 , 155u8 , 229u8 , 111u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " The amount held on deposit for a registered identity"] pub fn basic_deposit (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u128 > { :: subxt :: constants :: Address :: new_static ("Identity" , "BasicDeposit" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The amount held on deposit per additional field for a registered identity."] pub fn field_deposit (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u128 > { :: subxt :: constants :: Address :: new_static ("Identity" , "FieldDeposit" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The amount held on deposit for a registered subaccount. This should account for the fact"] # [doc = " that one storage item's value will increase by the size of an account ID, and there will"] # [doc = " be another trie item whose value is the size of an account ID plus 32 bytes."] pub fn sub_account_deposit (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u128 > { :: subxt :: constants :: Address :: new_static ("Identity" , "SubAccountDeposit" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The maximum number of sub-accounts allowed per identified account."] pub fn max_sub_accounts (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u32 > { :: subxt :: constants :: Address :: new_static ("Identity" , "MaxSubAccounts" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Maximum number of additional fields that may be stored in an ID. Needed to bound the I/O"] # [doc = " required to access an identity, but can be pretty high."] pub fn max_additional_fields (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u32 > { :: subxt :: constants :: Address :: new_static ("Identity" , "MaxAdditionalFields" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Maxmimum number of registrars allowed in the system. Needed to bound the complexity"] # [doc = " of, e.g., updating judgements."] pub fn max_registrars (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u32 > { :: subxt :: constants :: Address :: new_static ("Identity" , "MaxRegistrars" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod sudo { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Sudo { pub call : :: std :: boxed :: Box < runtime_types :: golden_gate_runtime_testnet :: RuntimeCall > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct SudoUncheckedWeight { pub call : :: std :: boxed :: Box < runtime_types :: golden_gate_runtime_testnet :: RuntimeCall > , pub weight : runtime_types :: sp_weights :: weight_v2 :: Weight , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct SetKey { pub new : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct SudoAs { pub who : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , pub call : :: std :: boxed :: Box < runtime_types :: golden_gate_runtime_testnet :: RuntimeCall > , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] pub fn sudo (& self , call : runtime_types :: golden_gate_runtime_testnet :: RuntimeCall ,) -> :: subxt :: tx :: Payload < Sudo > { :: subxt :: tx :: Payload :: new_static ("Sudo" , "sudo" , Sudo { call : :: std :: boxed :: Box :: new (call) , } , [102u8 , 11u8 , 180u8 , 86u8 , 234u8 , 90u8 , 86u8 , 124u8 , 153u8 , 7u8 , 109u8 , 241u8 , 246u8 , 154u8 , 135u8 , 42u8 , 229u8 , 243u8 , 28u8 , 104u8 , 62u8 , 144u8 , 77u8 , 34u8 , 240u8 , 11u8 , 184u8 , 238u8 , 164u8 , 159u8 , 159u8 , 25u8 ,]) } # [doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."] # [doc = "This function does not check the weight of the call, and instead allows the"] # [doc = "Sudo user to specify the weight of the call."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] pub fn sudo_unchecked_weight (& self , call : runtime_types :: golden_gate_runtime_testnet :: RuntimeCall , weight : runtime_types :: sp_weights :: weight_v2 :: Weight ,) -> :: subxt :: tx :: Payload < SudoUncheckedWeight > { :: subxt :: tx :: Payload :: new_static ("Sudo" , "sudo_unchecked_weight" , SudoUncheckedWeight { call : :: std :: boxed :: Box :: new (call) , weight , } , [180u8 , 210u8 , 17u8 , 10u8 , 8u8 , 74u8 , 14u8 , 173u8 , 48u8 , 11u8 , 112u8 , 144u8 , 1u8 , 155u8 , 36u8 , 155u8 , 186u8 , 18u8 , 242u8 , 212u8 , 246u8 , 233u8 , 57u8 , 127u8 , 82u8 , 180u8 , 248u8 , 51u8 , 105u8 , 249u8 , 95u8 , 1u8 ,]) } # [doc = "Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo"] # [doc = "key."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] pub fn set_key (& self , new : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > ,) -> :: subxt :: tx :: Payload < SetKey > { :: subxt :: tx :: Payload :: new_static ("Sudo" , "set_key" , SetKey { new , } , [34u8 , 116u8 , 170u8 , 18u8 , 106u8 , 17u8 , 231u8 , 159u8 , 110u8 , 246u8 , 2u8 , 27u8 , 161u8 , 155u8 , 163u8 , 41u8 , 138u8 , 7u8 , 81u8 , 98u8 , 230u8 , 182u8 , 23u8 , 222u8 , 240u8 , 117u8 , 173u8 , 232u8 , 192u8 , 55u8 , 92u8 , 208u8 ,]) } # [doc = "Authenticates the sudo key and dispatches a function call with `Signed` origin from"] # [doc = "a given account."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] pub fn sudo_as (& self , who : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , call : runtime_types :: golden_gate_runtime_testnet :: RuntimeCall ,) -> :: subxt :: tx :: Payload < SudoAs > { :: subxt :: tx :: Payload :: new_static ("Sudo" , "sudo_as" , SudoAs { who , call : :: std :: boxed :: Box :: new (call) , } , [241u8 , 252u8 , 67u8 , 37u8 , 116u8 , 26u8 , 244u8 , 177u8 , 91u8 , 144u8 , 219u8 , 135u8 , 224u8 , 151u8 , 38u8 , 60u8 , 48u8 , 101u8 , 227u8 , 228u8 , 210u8 , 250u8 , 95u8 , 131u8 , 212u8 , 152u8 , 90u8 , 26u8 , 122u8 , 78u8 , 104u8 , 79u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_sudo :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A sudo just took place. \\[result\\]"] pub struct Sudid { pub sudo_result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } impl :: subxt :: events :: StaticEvent for Sudid { const PALLET : & 'static str = "Sudo" ; const EVENT : & 'static str = "Sudid" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "The \\[sudoer\\] just switched identity; the old key is supplied if one existed."] pub struct KeyChanged { pub old_sudoer : :: core :: option :: Option < :: subxt :: utils :: AccountId32 > , } impl :: subxt :: events :: StaticEvent for KeyChanged { const PALLET : & 'static str = "Sudo" ; const EVENT : & 'static str = "KeyChanged" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A sudo just took place. \\[result\\]"] pub struct SudoAsDone { pub sudo_result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } impl :: subxt :: events :: StaticEvent for SudoAsDone { const PALLET : & 'static str = "Sudo" ; const EVENT : & 'static str = "SudoAsDone" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " The `AccountId` of the sudo key."] pub fn key (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: subxt :: utils :: AccountId32 , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: Address :: new_static ("Sudo" , "Key" , vec ! [] , [244u8 , 73u8 , 188u8 , 136u8 , 218u8 , 163u8 , 68u8 , 179u8 , 122u8 , 173u8 , 34u8 , 108u8 , 137u8 , 28u8 , 182u8 , 16u8 , 196u8 , 92u8 , 138u8 , 34u8 , 102u8 , 80u8 , 199u8 , 88u8 , 107u8 , 207u8 , 36u8 , 22u8 , 168u8 , 167u8 , 20u8 , 142u8 ,]) } } } } pub mod historical { use super :: root_mod ; use super :: runtime_types ; pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " Mapping from historical session indices to session-data root hash and validator count."] pub fn historical_sessions (& self , _0 : impl :: std :: borrow :: Borrow < :: core :: primitive :: u32 > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , (:: subxt :: utils :: H256 , :: core :: primitive :: u32 ,) , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Historical" , "HistoricalSessions" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ())] , [94u8 , 72u8 , 245u8 , 151u8 , 214u8 , 10u8 , 12u8 , 113u8 , 13u8 , 141u8 , 176u8 , 178u8 , 115u8 , 238u8 , 224u8 , 181u8 , 18u8 , 5u8 , 71u8 , 65u8 , 189u8 , 148u8 , 161u8 , 106u8 , 24u8 , 211u8 , 72u8 , 66u8 , 221u8 , 244u8 , 117u8 , 184u8 ,]) } # [doc = " Mapping from historical session indices to session-data root hash and validator count."] pub fn historical_sessions_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , (:: subxt :: utils :: H256 , :: core :: primitive :: u32 ,) , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Historical" , "HistoricalSessions" , Vec :: new () , [94u8 , 72u8 , 245u8 , 151u8 , 214u8 , 10u8 , 12u8 , 113u8 , 13u8 , 141u8 , 176u8 , 178u8 , 115u8 , 238u8 , 224u8 , 181u8 , 18u8 , 5u8 , 71u8 , 65u8 , 189u8 , 148u8 , 161u8 , 106u8 , 24u8 , 211u8 , 72u8 , 66u8 , 221u8 , 244u8 , 117u8 , 184u8 ,]) } # [doc = " The range of historical sessions we store. [first, last)"] pub fn stored_range (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: Address :: new_static ("Historical" , "StoredRange" , vec ! [] , [89u8 , 239u8 , 197u8 , 93u8 , 135u8 , 62u8 , 142u8 , 237u8 , 64u8 , 200u8 , 164u8 , 4u8 , 130u8 , 233u8 , 16u8 , 238u8 , 166u8 , 206u8 , 71u8 , 42u8 , 171u8 , 84u8 , 8u8 , 245u8 , 183u8 , 216u8 , 212u8 , 16u8 , 190u8 , 3u8 , 167u8 , 189u8 ,]) } } } } pub mod randomness_collective_flip { use super :: root_mod ; use super :: runtime_types ; pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " Series of block headers from the last 81 blocks that acts as random seed material. This"] # [doc = " is arranged as a ring buffer with `block_number % 81` being the index into the `Vec` of"] # [doc = " the oldest hash."] pub fn random_material (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < :: subxt :: utils :: H256 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("RandomnessCollectiveFlip" , "RandomMaterial" , vec ! [] , [152u8 , 126u8 , 73u8 , 88u8 , 54u8 , 147u8 , 6u8 , 19u8 , 214u8 , 40u8 , 159u8 , 30u8 , 236u8 , 61u8 , 240u8 , 65u8 , 178u8 , 94u8 , 146u8 , 152u8 , 135u8 , 252u8 , 160u8 , 86u8 , 123u8 , 114u8 , 251u8 , 140u8 , 98u8 , 143u8 , 217u8 , 242u8 ,]) } } } } pub mod validator_manager { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct RegisterValidators { pub validators : :: std :: vec :: Vec < :: subxt :: utils :: AccountId32 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct DeregisterValidators { pub validators : :: std :: vec :: Vec < :: subxt :: utils :: AccountId32 > , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Add new validators to the set."] # [doc = ""] # [doc = "The new validators will be active from current session + 2."] pub fn register_validators (& self , validators : :: std :: vec :: Vec < :: subxt :: utils :: AccountId32 > ,) -> :: subxt :: tx :: Payload < RegisterValidators > { :: subxt :: tx :: Payload :: new_static ("ValidatorManager" , "register_validators" , RegisterValidators { validators , } , [17u8 , 237u8 , 46u8 , 131u8 , 162u8 , 213u8 , 36u8 , 137u8 , 92u8 , 108u8 , 181u8 , 49u8 , 13u8 , 232u8 , 79u8 , 39u8 , 80u8 , 200u8 , 88u8 , 168u8 , 16u8 , 239u8 , 53u8 , 255u8 , 155u8 , 176u8 , 130u8 , 69u8 , 19u8 , 39u8 , 48u8 , 214u8 ,]) } # [doc = "Remove validators from the set."] # [doc = ""] # [doc = "The removed validators will be deactivated from current session + 2."] pub fn deregister_validators (& self , validators : :: std :: vec :: Vec < :: subxt :: utils :: AccountId32 > ,) -> :: subxt :: tx :: Payload < DeregisterValidators > { :: subxt :: tx :: Payload :: new_static ("ValidatorManager" , "deregister_validators" , DeregisterValidators { validators , } , [174u8 , 68u8 , 36u8 , 38u8 , 204u8 , 164u8 , 127u8 , 114u8 , 51u8 , 193u8 , 35u8 , 231u8 , 161u8 , 11u8 , 206u8 , 181u8 , 117u8 , 72u8 , 226u8 , 175u8 , 166u8 , 33u8 , 135u8 , 192u8 , 180u8 , 192u8 , 98u8 , 208u8 , 135u8 , 249u8 , 122u8 , 159u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: runtime_common :: validator_manager :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "New validators were added to the set."] pub struct ValidatorsRegistered (pub :: std :: vec :: Vec < :: subxt :: utils :: AccountId32 > ,) ; impl :: subxt :: events :: StaticEvent for ValidatorsRegistered { const PALLET : & 'static str = "ValidatorManager" ; const EVENT : & 'static str = "ValidatorsRegistered" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Validators were removed from the set."] pub struct ValidatorsDeregistered (pub :: std :: vec :: Vec < :: subxt :: utils :: AccountId32 > ,) ; impl :: subxt :: events :: StaticEvent for ValidatorsDeregistered { const PALLET : & 'static str = "ValidatorManager" ; const EVENT : & 'static str = "ValidatorsDeregistered" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " Validators that should be retired, because their Parachain was deregistered."] pub fn validators_to_retire (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: std :: vec :: Vec < :: subxt :: utils :: AccountId32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("ValidatorManager" , "ValidatorsToRetire" , vec ! [] , [174u8 , 83u8 , 236u8 , 203u8 , 146u8 , 196u8 , 48u8 , 111u8 , 29u8 , 182u8 , 114u8 , 60u8 , 7u8 , 134u8 , 2u8 , 255u8 , 1u8 , 42u8 , 186u8 , 222u8 , 93u8 , 153u8 , 108u8 , 35u8 , 1u8 , 91u8 , 197u8 , 144u8 , 31u8 , 81u8 , 67u8 , 136u8 ,]) } # [doc = " Validators that should be added."] pub fn validators_to_add (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: std :: vec :: Vec < :: subxt :: utils :: AccountId32 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("ValidatorManager" , "ValidatorsToAdd" , vec ! [] , [244u8 , 237u8 , 251u8 , 6u8 , 157u8 , 59u8 , 227u8 , 61u8 , 240u8 , 204u8 , 12u8 , 87u8 , 118u8 , 12u8 , 61u8 , 103u8 , 194u8 , 128u8 , 7u8 , 67u8 , 218u8 , 129u8 , 106u8 , 33u8 , 135u8 , 95u8 , 45u8 , 208u8 , 42u8 , 99u8 , 83u8 , 69u8 ,]) } } } } pub mod ethereum { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Transact { pub transaction : runtime_types :: ethereum :: transaction :: TransactionV2 , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Transact an Ethereum transaction."] pub fn transact (& self , transaction : runtime_types :: ethereum :: transaction :: TransactionV2 ,) -> :: subxt :: tx :: Payload < Transact > { :: subxt :: tx :: Payload :: new_static ("Ethereum" , "transact" , Transact { transaction , } , [124u8 , 231u8 , 112u8 , 236u8 , 222u8 , 106u8 , 130u8 , 211u8 , 84u8 , 12u8 , 97u8 , 12u8 , 232u8 , 118u8 , 85u8 , 90u8 , 122u8 , 215u8 , 64u8 , 236u8 , 59u8 , 113u8 , 188u8 , 158u8 , 238u8 , 223u8 , 237u8 , 33u8 , 205u8 , 41u8 , 168u8 , 104u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_ethereum :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "An ethereum transaction was successfully executed."] pub struct Executed { pub from : :: subxt :: utils :: H160 , pub to : :: subxt :: utils :: H160 , pub transaction_hash : :: subxt :: utils :: H256 , pub exit_reason : runtime_types :: evm_core :: error :: ExitReason , } impl :: subxt :: events :: StaticEvent for Executed { const PALLET : & 'static str = "Ethereum" ; const EVENT : & 'static str = "Executed" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " Current building block's transactions and receipts."] pub fn pending (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: std :: vec :: Vec < (runtime_types :: ethereum :: transaction :: TransactionV2 , runtime_types :: fp_rpc :: TransactionStatus , runtime_types :: ethereum :: receipt :: ReceiptV3 ,) > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("Ethereum" , "Pending" , vec ! [] , [234u8 , 231u8 , 64u8 , 113u8 , 143u8 , 30u8 , 254u8 , 67u8 , 96u8 , 28u8 , 103u8 , 215u8 , 223u8 , 144u8 , 45u8 , 129u8 , 136u8 , 100u8 , 67u8 , 12u8 , 118u8 , 161u8 , 220u8 , 165u8 , 214u8 , 208u8 , 245u8 , 145u8 , 179u8 , 19u8 , 245u8 , 188u8 ,]) } # [doc = " The current Ethereum block."] pub fn current_block (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: ethereum :: block :: Block < runtime_types :: ethereum :: transaction :: TransactionV2 > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: Address :: new_static ("Ethereum" , "CurrentBlock" , vec ! [] , [171u8 , 129u8 , 163u8 , 132u8 , 210u8 , 205u8 , 192u8 , 188u8 , 30u8 , 74u8 , 77u8 , 104u8 , 141u8 , 203u8 , 231u8 , 2u8 , 193u8 , 215u8 , 43u8 , 10u8 , 127u8 , 99u8 , 96u8 , 207u8 , 99u8 , 151u8 , 155u8 , 225u8 , 33u8 , 139u8 , 130u8 , 147u8 ,]) } # [doc = " The current Ethereum receipts."] pub fn current_receipts (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: std :: vec :: Vec < runtime_types :: ethereum :: receipt :: ReceiptV3 > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: Address :: new_static ("Ethereum" , "CurrentReceipts" , vec ! [] , [4u8 , 233u8 , 182u8 , 46u8 , 99u8 , 220u8 , 249u8 , 65u8 , 155u8 , 156u8 , 99u8 , 51u8 , 167u8 , 151u8 , 254u8 , 146u8 , 9u8 , 230u8 , 86u8 , 130u8 , 45u8 , 168u8 , 166u8 , 213u8 , 34u8 , 74u8 , 137u8 , 66u8 , 218u8 , 115u8 , 47u8 , 44u8 ,]) } # [doc = " The current transaction statuses."] pub fn current_transaction_statuses (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: std :: vec :: Vec < runtime_types :: fp_rpc :: TransactionStatus > , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: Address :: new_static ("Ethereum" , "CurrentTransactionStatuses" , vec ! [] , [140u8 , 37u8 , 8u8 , 78u8 , 94u8 , 11u8 , 18u8 , 214u8 , 48u8 , 113u8 , 119u8 , 170u8 , 92u8 , 213u8 , 178u8 , 9u8 , 197u8 , 192u8 , 111u8 , 228u8 , 212u8 , 11u8 , 136u8 , 63u8 , 121u8 , 38u8 , 156u8 , 167u8 , 114u8 , 10u8 , 43u8 , 29u8 ,]) } pub fn block_hash (& self , _0 : impl :: std :: borrow :: Borrow < runtime_types :: primitive_types :: U256 > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: subxt :: utils :: H256 , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Ethereum" , "BlockHash" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ())] , [57u8 , 222u8 , 197u8 , 205u8 , 99u8 , 80u8 , 107u8 , 48u8 , 117u8 , 3u8 , 160u8 , 10u8 , 161u8 , 85u8 , 10u8 , 249u8 , 83u8 , 216u8 , 233u8 , 70u8 , 125u8 , 244u8 , 48u8 , 188u8 , 8u8 , 168u8 , 0u8 , 111u8 , 180u8 , 236u8 , 67u8 , 78u8 ,]) } pub fn block_hash_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: subxt :: utils :: H256 , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Ethereum" , "BlockHash" , Vec :: new () , [57u8 , 222u8 , 197u8 , 205u8 , 99u8 , 80u8 , 107u8 , 48u8 , 117u8 , 3u8 , 160u8 , 10u8 , 161u8 , 85u8 , 10u8 , 249u8 , 83u8 , 216u8 , 233u8 , 70u8 , 125u8 , 244u8 , 48u8 , 188u8 , 8u8 , 168u8 , 0u8 , 111u8 , 180u8 , 236u8 , 67u8 , 78u8 ,]) } } } } pub mod evm { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Withdraw { pub address : :: subxt :: utils :: H160 , pub value : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Call { pub source : :: subxt :: utils :: H160 , pub target : :: subxt :: utils :: H160 , pub input : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub value : runtime_types :: primitive_types :: U256 , pub gas_limit : :: core :: primitive :: u64 , pub max_fee_per_gas : runtime_types :: primitive_types :: U256 , pub max_priority_fee_per_gas : :: core :: option :: Option < runtime_types :: primitive_types :: U256 > , pub nonce : :: core :: option :: Option < runtime_types :: primitive_types :: U256 > , pub access_list : :: std :: vec :: Vec < (:: subxt :: utils :: H160 , :: std :: vec :: Vec < :: subxt :: utils :: H256 > ,) > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Create { pub source : :: subxt :: utils :: H160 , pub init : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub value : runtime_types :: primitive_types :: U256 , pub gas_limit : :: core :: primitive :: u64 , pub max_fee_per_gas : runtime_types :: primitive_types :: U256 , pub max_priority_fee_per_gas : :: core :: option :: Option < runtime_types :: primitive_types :: U256 > , pub nonce : :: core :: option :: Option < runtime_types :: primitive_types :: U256 > , pub access_list : :: std :: vec :: Vec < (:: subxt :: utils :: H160 , :: std :: vec :: Vec < :: subxt :: utils :: H256 > ,) > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Create2 { pub source : :: subxt :: utils :: H160 , pub init : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub salt : :: subxt :: utils :: H256 , pub value : runtime_types :: primitive_types :: U256 , pub gas_limit : :: core :: primitive :: u64 , pub max_fee_per_gas : runtime_types :: primitive_types :: U256 , pub max_priority_fee_per_gas : :: core :: option :: Option < runtime_types :: primitive_types :: U256 > , pub nonce : :: core :: option :: Option < runtime_types :: primitive_types :: U256 > , pub access_list : :: std :: vec :: Vec < (:: subxt :: utils :: H160 , :: std :: vec :: Vec < :: subxt :: utils :: H256 > ,) > , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Withdraw balance from EVM into currency/balances pallet."] pub fn withdraw (& self , address : :: subxt :: utils :: H160 , value : :: core :: primitive :: u128 ,) -> :: subxt :: tx :: Payload < Withdraw > { :: subxt :: tx :: Payload :: new_static ("EVM" , "withdraw" , Withdraw { address , value , } , [129u8 , 46u8 , 181u8 , 200u8 , 82u8 , 77u8 , 184u8 , 125u8 , 89u8 , 74u8 , 209u8 , 255u8 , 206u8 , 246u8 , 172u8 , 140u8 , 93u8 , 40u8 , 51u8 , 77u8 , 109u8 , 14u8 , 151u8 , 186u8 , 208u8 , 0u8 , 217u8 , 43u8 , 173u8 , 100u8 , 181u8 , 53u8 ,]) } # [doc = "Issue an EVM call operation. This is similar to a message call transaction in Ethereum."] pub fn call (& self , source : :: subxt :: utils :: H160 , target : :: subxt :: utils :: H160 , input : :: std :: vec :: Vec < :: core :: primitive :: u8 > , value : runtime_types :: primitive_types :: U256 , gas_limit : :: core :: primitive :: u64 , max_fee_per_gas : runtime_types :: primitive_types :: U256 , max_priority_fee_per_gas : :: core :: option :: Option < runtime_types :: primitive_types :: U256 > , nonce : :: core :: option :: Option < runtime_types :: primitive_types :: U256 > , access_list : :: std :: vec :: Vec < (:: subxt :: utils :: H160 , :: std :: vec :: Vec < :: subxt :: utils :: H256 > ,) > ,) -> :: subxt :: tx :: Payload < Call > { :: subxt :: tx :: Payload :: new_static ("EVM" , "call" , Call { source , target , input , value , gas_limit , max_fee_per_gas , max_priority_fee_per_gas , nonce , access_list , } , [111u8 , 66u8 , 86u8 , 172u8 , 204u8 , 89u8 , 98u8 , 74u8 , 126u8 , 46u8 , 126u8 , 117u8 , 238u8 , 160u8 , 98u8 , 114u8 , 190u8 , 54u8 , 203u8 , 100u8 , 81u8 , 47u8 , 142u8 , 201u8 , 169u8 , 69u8 , 36u8 , 195u8 , 219u8 , 37u8 , 167u8 , 250u8 ,]) } # [doc = "Issue an EVM create operation. This is similar to a contract creation transaction in"] # [doc = "Ethereum."] pub fn create (& self , source : :: subxt :: utils :: H160 , init : :: std :: vec :: Vec < :: core :: primitive :: u8 > , value : runtime_types :: primitive_types :: U256 , gas_limit : :: core :: primitive :: u64 , max_fee_per_gas : runtime_types :: primitive_types :: U256 , max_priority_fee_per_gas : :: core :: option :: Option < runtime_types :: primitive_types :: U256 > , nonce : :: core :: option :: Option < runtime_types :: primitive_types :: U256 > , access_list : :: std :: vec :: Vec < (:: subxt :: utils :: H160 , :: std :: vec :: Vec < :: subxt :: utils :: H256 > ,) > ,) -> :: subxt :: tx :: Payload < Create > { :: subxt :: tx :: Payload :: new_static ("EVM" , "create" , Create { source , init , value , gas_limit , max_fee_per_gas , max_priority_fee_per_gas , nonce , access_list , } , [11u8 , 34u8 , 212u8 , 178u8 , 114u8 , 184u8 , 252u8 , 24u8 , 212u8 , 206u8 , 0u8 , 140u8 , 1u8 , 50u8 , 32u8 , 173u8 , 14u8 , 228u8 , 156u8 , 214u8 , 41u8 , 50u8 , 244u8 , 220u8 , 77u8 , 226u8 , 100u8 , 51u8 , 84u8 , 107u8 , 234u8 , 144u8 ,]) } # [doc = "Issue an EVM create2 operation."] pub fn create2 (& self , source : :: subxt :: utils :: H160 , init : :: std :: vec :: Vec < :: core :: primitive :: u8 > , salt : :: subxt :: utils :: H256 , value : runtime_types :: primitive_types :: U256 , gas_limit : :: core :: primitive :: u64 , max_fee_per_gas : runtime_types :: primitive_types :: U256 , max_priority_fee_per_gas : :: core :: option :: Option < runtime_types :: primitive_types :: U256 > , nonce : :: core :: option :: Option < runtime_types :: primitive_types :: U256 > , access_list : :: std :: vec :: Vec < (:: subxt :: utils :: H160 , :: std :: vec :: Vec < :: subxt :: utils :: H256 > ,) > ,) -> :: subxt :: tx :: Payload < Create2 > { :: subxt :: tx :: Payload :: new_static ("EVM" , "create2" , Create2 { source , init , salt , value , gas_limit , max_fee_per_gas , max_priority_fee_per_gas , nonce , access_list , } , [173u8 , 184u8 , 126u8 , 170u8 , 220u8 , 91u8 , 0u8 , 235u8 , 43u8 , 253u8 , 21u8 , 32u8 , 76u8 , 80u8 , 222u8 , 50u8 , 234u8 , 183u8 , 248u8 , 7u8 , 44u8 , 184u8 , 76u8 , 244u8 , 233u8 , 151u8 , 234u8 , 227u8 , 140u8 , 131u8 , 211u8 , 204u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_evm :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Ethereum events from contracts."] pub struct Log { pub log : runtime_types :: ethereum :: log :: Log , } impl :: subxt :: events :: StaticEvent for Log { const PALLET : & 'static str = "EVM" ; const EVENT : & 'static str = "Log" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A contract has been created at given address."] pub struct Created { pub address : :: subxt :: utils :: H160 , } impl :: subxt :: events :: StaticEvent for Created { const PALLET : & 'static str = "EVM" ; const EVENT : & 'static str = "Created" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A contract was attempted to be created, but the execution failed."] pub struct CreatedFailed { pub address : :: subxt :: utils :: H160 , } impl :: subxt :: events :: StaticEvent for CreatedFailed { const PALLET : & 'static str = "EVM" ; const EVENT : & 'static str = "CreatedFailed" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A contract has been executed successfully with states applied."] pub struct Executed { pub address : :: subxt :: utils :: H160 , } impl :: subxt :: events :: StaticEvent for Executed { const PALLET : & 'static str = "EVM" ; const EVENT : & 'static str = "Executed" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A contract has been executed with errors. States are reverted with only gas fees applied."] pub struct ExecutedFailed { pub address : :: subxt :: utils :: H160 , } impl :: subxt :: events :: StaticEvent for ExecutedFailed { const PALLET : & 'static str = "EVM" ; const EVENT : & 'static str = "ExecutedFailed" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { pub fn account_codes (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: utils :: H160 > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: std :: vec :: Vec < :: core :: primitive :: u8 > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("EVM" , "AccountCodes" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ())] , [84u8 , 64u8 , 188u8 , 245u8 , 10u8 , 25u8 , 248u8 , 118u8 , 104u8 , 149u8 , 166u8 , 38u8 , 172u8 , 246u8 , 22u8 , 198u8 , 113u8 , 130u8 , 153u8 , 130u8 , 63u8 , 78u8 , 53u8 , 199u8 , 86u8 , 221u8 , 67u8 , 14u8 , 255u8 , 94u8 , 217u8 , 181u8 ,]) } pub fn account_codes_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: std :: vec :: Vec < :: core :: primitive :: u8 > , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("EVM" , "AccountCodes" , Vec :: new () , [84u8 , 64u8 , 188u8 , 245u8 , 10u8 , 25u8 , 248u8 , 118u8 , 104u8 , 149u8 , 166u8 , 38u8 , 172u8 , 246u8 , 22u8 , 198u8 , 113u8 , 130u8 , 153u8 , 130u8 , 63u8 , 78u8 , 53u8 , 199u8 , 86u8 , 221u8 , 67u8 , 14u8 , 255u8 , 94u8 , 217u8 , 181u8 ,]) } pub fn account_storages (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: utils :: H160 > , _1 : impl :: std :: borrow :: Borrow < :: subxt :: utils :: H256 > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: subxt :: utils :: H256 , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("EVM" , "AccountStorages" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ()) , :: subxt :: storage :: address :: make_static_storage_map_key (_1 . borrow ())] , [180u8 , 120u8 , 181u8 , 205u8 , 0u8 , 15u8 , 59u8 , 19u8 , 203u8 , 236u8 , 95u8 , 4u8 , 206u8 , 91u8 , 71u8 , 61u8 , 84u8 , 33u8 , 40u8 , 83u8 , 92u8 , 63u8 , 123u8 , 0u8 , 24u8 , 210u8 , 209u8 , 242u8 , 195u8 , 89u8 , 188u8 , 215u8 ,]) } pub fn account_storages_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: subxt :: utils :: H256 , () , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("EVM" , "AccountStorages" , Vec :: new () , [180u8 , 120u8 , 181u8 , 205u8 , 0u8 , 15u8 , 59u8 , 19u8 , 203u8 , 236u8 , 95u8 , 4u8 , 206u8 , 91u8 , 71u8 , 61u8 , 84u8 , 33u8 , 40u8 , 83u8 , 92u8 , 63u8 , 123u8 , 0u8 , 24u8 , 210u8 , 209u8 , 242u8 , 195u8 , 89u8 , 188u8 , 215u8 ,]) } } } } pub mod evm_chain_id { use super :: root_mod ; use super :: runtime_types ; pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " The EVM chain ID."] pub fn chain_id (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: core :: primitive :: u64 , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("EVMChainId" , "ChainId" , vec ! [] , [211u8 , 158u8 , 102u8 , 190u8 , 179u8 , 13u8 , 76u8 , 94u8 , 169u8 , 9u8 , 158u8 , 213u8 , 33u8 , 249u8 , 111u8 , 64u8 , 177u8 , 235u8 , 224u8 , 226u8 , 145u8 , 19u8 , 243u8 , 135u8 , 66u8 , 160u8 , 241u8 , 253u8 , 17u8 , 111u8 , 102u8 , 104u8 ,]) } } } } pub mod dynamic_fee { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct NoteMinGasPriceTarget { pub target : runtime_types :: primitive_types :: U256 , } pub struct TransactionApi ; impl TransactionApi { pub fn note_min_gas_price_target (& self , target : runtime_types :: primitive_types :: U256 ,) -> :: subxt :: tx :: Payload < NoteMinGasPriceTarget > { :: subxt :: tx :: Payload :: new_static ("DynamicFee" , "note_min_gas_price_target" , NoteMinGasPriceTarget { target , } , [177u8 , 161u8 , 187u8 , 43u8 , 42u8 , 243u8 , 244u8 , 186u8 , 90u8 , 206u8 , 137u8 , 146u8 , 230u8 , 219u8 , 148u8 , 122u8 , 248u8 , 12u8 , 122u8 , 188u8 , 2u8 , 242u8 , 112u8 , 145u8 , 180u8 , 91u8 , 242u8 , 211u8 , 145u8 , 239u8 , 76u8 , 220u8 ,]) } } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { pub fn min_gas_price (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: primitive_types :: U256 , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("DynamicFee" , "MinGasPrice" , vec ! [] , [195u8 , 69u8 , 31u8 , 156u8 , 248u8 , 3u8 , 179u8 , 152u8 , 8u8 , 9u8 , 80u8 , 248u8 , 223u8 , 147u8 , 57u8 , 157u8 , 114u8 , 93u8 , 150u8 , 222u8 , 220u8 , 190u8 , 124u8 , 239u8 , 18u8 , 242u8 , 68u8 , 23u8 , 50u8 , 77u8 , 176u8 , 165u8 ,]) } pub fn target_min_gas_price (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: primitive_types :: U256 , :: subxt :: storage :: address :: Yes , () , () > { :: subxt :: storage :: address :: Address :: new_static ("DynamicFee" , "TargetMinGasPrice" , vec ! [] , [148u8 , 31u8 , 204u8 , 98u8 , 198u8 , 201u8 , 140u8 , 251u8 , 168u8 , 27u8 , 63u8 , 32u8 , 121u8 , 7u8 , 178u8 , 128u8 , 150u8 , 71u8 , 190u8 , 184u8 , 110u8 , 131u8 , 120u8 , 44u8 , 136u8 , 224u8 , 121u8 , 248u8 , 180u8 , 232u8 , 71u8 , 1u8 ,]) } } } } pub mod base_fee { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct SetBaseFeePerGas { pub fee : runtime_types :: primitive_types :: U256 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct SetElasticity { pub elasticity : runtime_types :: sp_arithmetic :: per_things :: Permill , } pub struct TransactionApi ; impl TransactionApi { pub fn set_base_fee_per_gas (& self , fee : runtime_types :: primitive_types :: U256 ,) -> :: subxt :: tx :: Payload < SetBaseFeePerGas > { :: subxt :: tx :: Payload :: new_static ("BaseFee" , "set_base_fee_per_gas" , SetBaseFeePerGas { fee , } , [239u8 , 136u8 , 2u8 , 94u8 , 21u8 , 234u8 , 78u8 , 190u8 , 238u8 , 101u8 , 129u8 , 252u8 , 142u8 , 77u8 , 97u8 , 185u8 , 96u8 , 235u8 , 110u8 , 1u8 , 66u8 , 83u8 , 87u8 , 211u8 , 18u8 , 91u8 , 30u8 , 221u8 , 19u8 , 28u8 , 45u8 , 64u8 ,]) } pub fn set_elasticity (& self , elasticity : runtime_types :: sp_arithmetic :: per_things :: Permill ,) -> :: subxt :: tx :: Payload < SetElasticity > { :: subxt :: tx :: Payload :: new_static ("BaseFee" , "set_elasticity" , SetElasticity { elasticity , } , [184u8 , 22u8 , 111u8 , 158u8 , 76u8 , 4u8 , 40u8 , 214u8 , 106u8 , 91u8 , 27u8 , 192u8 , 222u8 , 211u8 , 237u8 , 91u8 , 240u8 , 250u8 , 123u8 , 122u8 , 82u8 , 246u8 , 166u8 , 29u8 , 213u8 , 17u8 , 78u8 , 191u8 , 139u8 , 79u8 , 131u8 , 66u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_base_fee :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct NewBaseFeePerGas { pub fee : runtime_types :: primitive_types :: U256 , } impl :: subxt :: events :: StaticEvent for NewBaseFeePerGas { const PALLET : & 'static str = "BaseFee" ; const EVENT : & 'static str = "NewBaseFeePerGas" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct BaseFeeOverflow ; impl :: subxt :: events :: StaticEvent for BaseFeeOverflow { const PALLET : & 'static str = "BaseFee" ; const EVENT : & 'static str = "BaseFeeOverflow" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct NewElasticity { pub elasticity : runtime_types :: sp_arithmetic :: per_things :: Permill , } impl :: subxt :: events :: StaticEvent for NewElasticity { const PALLET : & 'static str = "BaseFee" ; const EVENT : & 'static str = "NewElasticity" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { pub fn base_fee_per_gas (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: primitive_types :: U256 , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("BaseFee" , "BaseFeePerGas" , vec ! [] , [94u8 , 84u8 , 35u8 , 146u8 , 96u8 , 101u8 , 214u8 , 91u8 , 165u8 , 245u8 , 119u8 , 213u8 , 247u8 , 51u8 , 132u8 , 243u8 , 167u8 , 230u8 , 10u8 , 23u8 , 1u8 , 117u8 , 124u8 , 168u8 , 182u8 , 21u8 , 113u8 , 150u8 , 99u8 , 130u8 , 99u8 , 255u8 ,]) } pub fn elasticity (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: sp_arithmetic :: per_things :: Permill , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("BaseFee" , "Elasticity" , vec ! [] , [108u8 , 105u8 , 182u8 , 196u8 , 117u8 , 243u8 , 88u8 , 200u8 , 70u8 , 94u8 , 115u8 , 59u8 , 61u8 , 255u8 , 166u8 , 1u8 , 227u8 , 175u8 , 32u8 , 14u8 , 167u8 , 197u8 , 116u8 , 206u8 , 114u8 , 134u8 , 225u8 , 193u8 , 216u8 , 83u8 , 162u8 , 31u8 ,]) } } } } pub mod hotfix_sufficients { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct HotfixIncAccountSufficients { pub addresses : :: std :: vec :: Vec < :: subxt :: utils :: H160 > , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Increment `sufficients` for existing accounts having a nonzero `nonce` but zero `sufficients`, `consumers` and `providers` value."] # [doc = "This state was caused by a previous bug in EVM create account dispatchable."] # [doc = ""] # [doc = "Any accounts in the input list not satisfying the above condition will remain unaffected."] pub fn hotfix_inc_account_sufficients (& self , addresses : :: std :: vec :: Vec < :: subxt :: utils :: H160 > ,) -> :: subxt :: tx :: Payload < HotfixIncAccountSufficients > { :: subxt :: tx :: Payload :: new_static ("HotfixSufficients" , "hotfix_inc_account_sufficients" , HotfixIncAccountSufficients { addresses , } , [19u8 , 16u8 , 111u8 , 152u8 , 251u8 , 182u8 , 13u8 , 138u8 , 105u8 , 252u8 , 255u8 , 109u8 , 136u8 , 245u8 , 72u8 , 151u8 , 128u8 , 138u8 , 250u8 , 114u8 , 86u8 , 59u8 , 28u8 , 5u8 , 35u8 , 56u8 , 243u8 , 54u8 , 85u8 , 64u8 , 168u8 , 61u8 ,]) } } } } pub mod account_filter { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct AddAccount { pub new_account : :: subxt :: utils :: AccountId32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct RemoveAccount { pub account_to_remove : :: subxt :: utils :: AccountId32 , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Add a new account to the allow-list."] # [doc = "Can only be called by the defined origin."] pub fn add_account (& self , new_account : :: subxt :: utils :: AccountId32 ,) -> :: subxt :: tx :: Payload < AddAccount > { :: subxt :: tx :: Payload :: new_static ("AccountFilter" , "add_account" , AddAccount { new_account , } , [45u8 , 104u8 , 104u8 , 202u8 , 41u8 , 184u8 , 138u8 , 74u8 , 66u8 , 77u8 , 152u8 , 24u8 , 201u8 , 238u8 , 20u8 , 142u8 , 229u8 , 118u8 , 251u8 , 176u8 , 165u8 , 113u8 , 110u8 , 190u8 , 129u8 , 62u8 , 90u8 , 136u8 , 88u8 , 234u8 , 227u8 , 104u8 ,]) } # [doc = "Remove an account from the allow-list."] # [doc = "Can only be called by the defined origin."] pub fn remove_account (& self , account_to_remove : :: subxt :: utils :: AccountId32 ,) -> :: subxt :: tx :: Payload < RemoveAccount > { :: subxt :: tx :: Payload :: new_static ("AccountFilter" , "remove_account" , RemoveAccount { account_to_remove , } , [217u8 , 157u8 , 151u8 , 111u8 , 116u8 , 15u8 , 219u8 , 196u8 , 91u8 , 13u8 , 12u8 , 90u8 , 32u8 , 159u8 , 88u8 , 97u8 , 243u8 , 120u8 , 220u8 , 210u8 , 250u8 , 178u8 , 199u8 , 186u8 , 222u8 , 24u8 , 125u8 , 190u8 , 15u8 , 90u8 , 236u8 , 40u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: substrate_account_filter :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct AccountAllowed (pub :: subxt :: utils :: AccountId32 ,) ; impl :: subxt :: events :: StaticEvent for AccountAllowed { const PALLET : & 'static str = "AccountFilter" ; const EVENT : & 'static str = "AccountAllowed" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct AccountRemoved (pub :: subxt :: utils :: AccountId32 ,) ; impl :: subxt :: events :: StaticEvent for AccountRemoved { const PALLET : & 'static str = "AccountFilter" ; const EVENT : & 'static str = "AccountRemoved" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { pub fn allowed_accounts (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: utils :: AccountId32 > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , () , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("AccountFilter" , "AllowedAccounts" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ())] , [27u8 , 251u8 , 167u8 , 13u8 , 218u8 , 6u8 , 80u8 , 18u8 , 0u8 , 9u8 , 252u8 , 3u8 , 133u8 , 230u8 , 65u8 , 6u8 , 124u8 , 67u8 , 17u8 , 66u8 , 245u8 , 252u8 , 43u8 , 201u8 , 106u8 , 120u8 , 135u8 , 127u8 , 162u8 , 66u8 , 79u8 , 3u8 ,]) } pub fn allowed_accounts_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , () , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("AccountFilter" , "AllowedAccounts" , Vec :: new () , [27u8 , 251u8 , 167u8 , 13u8 , 218u8 , 6u8 , 80u8 , 18u8 , 0u8 , 9u8 , 252u8 , 3u8 , 133u8 , 230u8 , 65u8 , 6u8 , 124u8 , 67u8 , 17u8 , 66u8 , 245u8 , 252u8 , 43u8 , 201u8 , 106u8 , 120u8 , 135u8 , 127u8 , 162u8 , 66u8 , 79u8 , 3u8 ,]) } } } } pub mod contracts { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct CallOldWeight { pub dest : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pub value : :: core :: primitive :: u128 , # [codec (compact)] pub gas_limit : runtime_types :: sp_weights :: OldWeight , pub storage_deposit_limit : :: core :: option :: Option < :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u128 > > , pub data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct InstantiateWithCodeOldWeight { # [codec (compact)] pub value : :: core :: primitive :: u128 , # [codec (compact)] pub gas_limit : runtime_types :: sp_weights :: OldWeight , pub storage_deposit_limit : :: core :: option :: Option < :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u128 > > , pub code : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub salt : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct InstantiateOldWeight { # [codec (compact)] pub value : :: core :: primitive :: u128 , # [codec (compact)] pub gas_limit : runtime_types :: sp_weights :: OldWeight , pub storage_deposit_limit : :: core :: option :: Option < :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u128 > > , pub code_hash : :: subxt :: utils :: H256 , pub data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub salt : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct UploadCode { pub code : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub storage_deposit_limit : :: core :: option :: Option < :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u128 > > , pub determinism : runtime_types :: pallet_contracts :: wasm :: Determinism , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct RemoveCode { pub code_hash : :: subxt :: utils :: H256 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct SetCode { pub dest : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , pub code_hash : :: subxt :: utils :: H256 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Call { pub dest : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pub value : :: core :: primitive :: u128 , pub gas_limit : runtime_types :: sp_weights :: weight_v2 :: Weight , pub storage_deposit_limit : :: core :: option :: Option < :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u128 > > , pub data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct InstantiateWithCode { # [codec (compact)] pub value : :: core :: primitive :: u128 , pub gas_limit : runtime_types :: sp_weights :: weight_v2 :: Weight , pub storage_deposit_limit : :: core :: option :: Option < :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u128 > > , pub code : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub salt : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Instantiate { # [codec (compact)] pub value : :: core :: primitive :: u128 , pub gas_limit : runtime_types :: sp_weights :: weight_v2 :: Weight , pub storage_deposit_limit : :: core :: option :: Option < :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u128 > > , pub code_hash : :: subxt :: utils :: H256 , pub data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub salt : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } pub struct TransactionApi ; impl TransactionApi { # [doc = "Deprecated version if [`Self::call`] for use in an in-storage `Call`."] pub fn call_old_weight (& self , dest : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , value : :: core :: primitive :: u128 , gas_limit : runtime_types :: sp_weights :: OldWeight , storage_deposit_limit : :: core :: option :: Option < :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u128 > > , data : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: tx :: Payload < CallOldWeight > { :: subxt :: tx :: Payload :: new_static ("Contracts" , "call_old_weight" , CallOldWeight { dest , value , gas_limit , storage_deposit_limit , data , } , [110u8 , 227u8 , 98u8 , 194u8 , 241u8 , 14u8 , 112u8 , 34u8 , 18u8 , 0u8 , 102u8 , 76u8 , 145u8 , 224u8 , 186u8 , 143u8 , 89u8 , 61u8 , 182u8 , 157u8 , 35u8 , 128u8 , 148u8 , 255u8 , 192u8 , 223u8 , 12u8 , 178u8 , 69u8 , 1u8 , 168u8 , 149u8 ,]) } # [doc = "Deprecated version if [`Self::instantiate_with_code`] for use in an in-storage `Call`."] pub fn instantiate_with_code_old_weight (& self , value : :: core :: primitive :: u128 , gas_limit : runtime_types :: sp_weights :: OldWeight , storage_deposit_limit : :: core :: option :: Option < :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u128 > > , code : :: std :: vec :: Vec < :: core :: primitive :: u8 > , data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , salt : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: tx :: Payload < InstantiateWithCodeOldWeight > { :: subxt :: tx :: Payload :: new_static ("Contracts" , "instantiate_with_code_old_weight" , InstantiateWithCodeOldWeight { value , gas_limit , storage_deposit_limit , code , data , salt , } , [93u8 , 124u8 , 100u8 , 101u8 , 7u8 , 110u8 , 92u8 , 199u8 , 162u8 , 126u8 , 35u8 , 47u8 , 190u8 , 42u8 , 237u8 , 152u8 , 169u8 , 130u8 , 21u8 , 33u8 , 136u8 , 220u8 , 110u8 , 106u8 , 57u8 , 211u8 , 158u8 , 130u8 , 112u8 , 37u8 , 41u8 , 39u8 ,]) } # [doc = "Deprecated version if [`Self::instantiate`] for use in an in-storage `Call`."] pub fn instantiate_old_weight (& self , value : :: core :: primitive :: u128 , gas_limit : runtime_types :: sp_weights :: OldWeight , storage_deposit_limit : :: core :: option :: Option < :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u128 > > , code_hash : :: subxt :: utils :: H256 , data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , salt : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: tx :: Payload < InstantiateOldWeight > { :: subxt :: tx :: Payload :: new_static ("Contracts" , "instantiate_old_weight" , InstantiateOldWeight { value , gas_limit , storage_deposit_limit , code_hash , data , salt , } , [243u8 , 56u8 , 93u8 , 198u8 , 169u8 , 134u8 , 6u8 , 135u8 , 19u8 , 1u8 , 20u8 , 138u8 , 202u8 , 59u8 , 59u8 , 99u8 , 58u8 , 22u8 , 33u8 , 94u8 , 253u8 , 215u8 , 203u8 , 159u8 , 58u8 , 21u8 , 24u8 , 235u8 , 30u8 , 215u8 , 173u8 , 23u8 ,]) } # [doc = "Upload new `code` without instantiating a contract from it."] # [doc = ""] # [doc = "If the code does not already exist a deposit is reserved from the caller"] # [doc = "and unreserved only when [`Self::remove_code`] is called. The size of the reserve"] # [doc = "depends on the instrumented size of the the supplied `code`."] # [doc = ""] # [doc = "If the code already exists in storage it will still return `Ok` and upgrades"] # [doc = "the in storage version to the current"] # [doc = "[`InstructionWeights::version`](InstructionWeights)."] # [doc = ""] # [doc = "- `determinism`: If this is set to any other value but [`Determinism::Deterministic`]"] # [doc = "  then the only way to use this code is to delegate call into it from an offchain"] # [doc = "  execution. Set to [`Determinism::Deterministic`] if in doubt."] # [doc = ""] # [doc = "# Note"] # [doc = ""] # [doc = "Anyone can instantiate a contract from any uploaded code and thus prevent its removal."] # [doc = "To avoid this situation a constructor could employ access control so that it can"] # [doc = "only be instantiated by permissioned entities. The same is true when uploading"] # [doc = "through [`Self::instantiate_with_code`]."] pub fn upload_code (& self , code : :: std :: vec :: Vec < :: core :: primitive :: u8 > , storage_deposit_limit : :: core :: option :: Option < :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u128 > > , determinism : runtime_types :: pallet_contracts :: wasm :: Determinism ,) -> :: subxt :: tx :: Payload < UploadCode > { :: subxt :: tx :: Payload :: new_static ("Contracts" , "upload_code" , UploadCode { code , storage_deposit_limit , determinism , } , [233u8 , 137u8 , 54u8 , 111u8 , 132u8 , 124u8 , 80u8 , 213u8 , 182u8 , 224u8 , 144u8 , 240u8 , 6u8 , 235u8 , 148u8 , 26u8 , 65u8 , 39u8 , 91u8 , 151u8 , 131u8 , 10u8 , 216u8 , 101u8 , 89u8 , 115u8 , 160u8 , 154u8 , 44u8 , 239u8 , 142u8 , 116u8 ,]) } # [doc = "Remove the code stored under `code_hash` and refund the deposit to its owner."] # [doc = ""] # [doc = "A code can only be removed by its original uploader (its owner) and only if it is"] # [doc = "not used by any contract."] pub fn remove_code (& self , code_hash : :: subxt :: utils :: H256 ,) -> :: subxt :: tx :: Payload < RemoveCode > { :: subxt :: tx :: Payload :: new_static ("Contracts" , "remove_code" , RemoveCode { code_hash , } , [43u8 , 192u8 , 198u8 , 182u8 , 108u8 , 76u8 , 21u8 , 42u8 , 169u8 , 41u8 , 195u8 , 73u8 , 31u8 , 179u8 , 162u8 , 56u8 , 91u8 , 5u8 , 64u8 , 7u8 , 252u8 , 194u8 , 255u8 , 170u8 , 67u8 , 137u8 , 143u8 , 192u8 , 2u8 , 149u8 , 38u8 , 180u8 ,]) } # [doc = "Privileged function that changes the code of an existing contract."] # [doc = ""] # [doc = "This takes care of updating refcounts and all other necessary operations. Returns"] # [doc = "an error if either the `code_hash` or `dest` do not exist."] # [doc = ""] # [doc = "# Note"] # [doc = ""] # [doc = "This does **not** change the address of the contract in question. This means"] # [doc = "that the contract address is no longer derived from its code hash after calling"] # [doc = "this dispatchable."] pub fn set_code (& self , dest : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , code_hash : :: subxt :: utils :: H256 ,) -> :: subxt :: tx :: Payload < SetCode > { :: subxt :: tx :: Payload :: new_static ("Contracts" , "set_code" , SetCode { dest , code_hash , } , [87u8 , 240u8 , 9u8 , 107u8 , 114u8 , 69u8 , 236u8 , 184u8 , 154u8 , 179u8 , 251u8 , 25u8 , 177u8 , 13u8 , 199u8 , 181u8 , 166u8 , 219u8 , 217u8 , 11u8 , 98u8 , 167u8 , 45u8 , 214u8 , 212u8 , 208u8 , 110u8 , 91u8 , 8u8 , 65u8 , 232u8 , 11u8 ,]) } # [doc = "Makes a call to an account, optionally transferring some balance."] # [doc = ""] # [doc = "# Parameters"] # [doc = ""] # [doc = "* `dest`: Address of the contract to call."] # [doc = "* `value`: The balance to transfer from the `origin` to `dest`."] # [doc = "* `gas_limit`: The gas limit enforced when executing the constructor."] # [doc = "* `storage_deposit_limit`: The maximum amount of balance that can be charged from the"] # [doc = "  caller to pay for the storage consumed."] # [doc = "* `data`: The input data to pass to the contract."] # [doc = ""] # [doc = "* If the account is a smart-contract account, the associated code will be"] # [doc = "executed and any value will be transferred."] # [doc = "* If the account is a regular account, any value will be transferred."] # [doc = "* If no account exists and the call value is not less than `existential_deposit`,"] # [doc = "a regular account will be created and any value will be transferred."] pub fn call (& self , dest : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , value : :: core :: primitive :: u128 , gas_limit : runtime_types :: sp_weights :: weight_v2 :: Weight , storage_deposit_limit : :: core :: option :: Option < :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u128 > > , data : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: tx :: Payload < Call > { :: subxt :: tx :: Payload :: new_static ("Contracts" , "call" , Call { dest , value , gas_limit , storage_deposit_limit , data , } , [196u8 , 11u8 , 91u8 , 234u8 , 7u8 , 74u8 , 48u8 , 20u8 , 202u8 , 48u8 , 234u8 , 203u8 , 148u8 , 60u8 , 217u8 , 84u8 , 219u8 , 41u8 , 230u8 , 150u8 , 158u8 , 153u8 , 160u8 , 81u8 , 59u8 , 2u8 , 170u8 , 20u8 , 252u8 , 97u8 , 6u8 , 173u8 ,]) } # [doc = "Instantiates a new contract from the supplied `code` optionally transferring"] # [doc = "some balance."] # [doc = ""] # [doc = "This dispatchable has the same effect as calling [`Self::upload_code`] +"] # [doc = "[`Self::instantiate`]. Bundling them together provides efficiency gains. Please"] # [doc = "also check the documentation of [`Self::upload_code`]."] # [doc = ""] # [doc = "# Parameters"] # [doc = ""] # [doc = "* `value`: The balance to transfer from the `origin` to the newly created contract."] # [doc = "* `gas_limit`: The gas limit enforced when executing the constructor."] # [doc = "* `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved"] # [doc = "  from the caller to pay for the storage consumed."] # [doc = "* `code`: The contract code to deploy in raw bytes."] # [doc = "* `data`: The input data to pass to the contract constructor."] # [doc = "* `salt`: Used for the address derivation. See [`Pallet::contract_address`]."] # [doc = ""] # [doc = "Instantiation is executed as follows:"] # [doc = ""] # [doc = "- The supplied `code` is instrumented, deployed, and a `code_hash` is created for that"] # [doc = "  code."] # [doc = "- If the `code_hash` already exists on the chain the underlying `code` will be shared."] # [doc = "- The destination address is computed based on the sender, code_hash and the salt."] # [doc = "- The smart-contract account is created at the computed address."] # [doc = "- The `value` is transferred to the new account."] # [doc = "- The `deploy` function is executed in the context of the newly-created account."] pub fn instantiate_with_code (& self , value : :: core :: primitive :: u128 , gas_limit : runtime_types :: sp_weights :: weight_v2 :: Weight , storage_deposit_limit : :: core :: option :: Option < :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u128 > > , code : :: std :: vec :: Vec < :: core :: primitive :: u8 > , data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , salt : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: tx :: Payload < InstantiateWithCode > { :: subxt :: tx :: Payload :: new_static ("Contracts" , "instantiate_with_code" , InstantiateWithCode { value , gas_limit , storage_deposit_limit , code , data , salt , } , [94u8 , 238u8 , 175u8 , 86u8 , 230u8 , 186u8 , 94u8 , 60u8 , 201u8 , 35u8 , 117u8 , 236u8 , 221u8 , 10u8 , 180u8 , 191u8 , 140u8 , 79u8 , 203u8 , 134u8 , 240u8 , 21u8 , 31u8 , 63u8 , 9u8 , 17u8 , 134u8 , 30u8 , 244u8 , 95u8 , 171u8 , 164u8 ,]) } # [doc = "Instantiates a contract from a previously deployed wasm binary."] # [doc = ""] # [doc = "This function is identical to [`Self::instantiate_with_code`] but without the"] # [doc = "code deployment step. Instead, the `code_hash` of an on-chain deployed wasm binary"] # [doc = "must be supplied."] pub fn instantiate (& self , value : :: core :: primitive :: u128 , gas_limit : runtime_types :: sp_weights :: weight_v2 :: Weight , storage_deposit_limit : :: core :: option :: Option < :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u128 > > , code_hash : :: subxt :: utils :: H256 , data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , salt : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: tx :: Payload < Instantiate > { :: subxt :: tx :: Payload :: new_static ("Contracts" , "instantiate" , Instantiate { value , gas_limit , storage_deposit_limit , code_hash , data , salt , } , [251u8 , 49u8 , 158u8 , 1u8 , 138u8 , 29u8 , 106u8 , 187u8 , 68u8 , 135u8 , 44u8 , 196u8 , 230u8 , 237u8 , 88u8 , 244u8 , 170u8 , 168u8 , 11u8 , 91u8 , 185u8 , 11u8 , 45u8 , 86u8 , 113u8 , 79u8 , 92u8 , 248u8 , 113u8 , 47u8 , 141u8 , 10u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_contracts :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Contract deployed by address at the specified address."] pub struct Instantiated { pub deployer : :: subxt :: utils :: AccountId32 , pub contract : :: subxt :: utils :: AccountId32 , } impl :: subxt :: events :: StaticEvent for Instantiated { const PALLET : & 'static str = "Contracts" ; const EVENT : & 'static str = "Instantiated" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Contract has been removed."] # [doc = ""] # [doc = "# Note"] # [doc = ""] # [doc = "The only way for a contract to be removed and emitting this event is by calling"] # [doc = "`seal_terminate`."] pub struct Terminated { pub contract : :: subxt :: utils :: AccountId32 , pub beneficiary : :: subxt :: utils :: AccountId32 , } impl :: subxt :: events :: StaticEvent for Terminated { const PALLET : & 'static str = "Contracts" ; const EVENT : & 'static str = "Terminated" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Code with the specified hash has been stored."] pub struct CodeStored { pub code_hash : :: subxt :: utils :: H256 , } impl :: subxt :: events :: StaticEvent for CodeStored { const PALLET : & 'static str = "Contracts" ; const EVENT : & 'static str = "CodeStored" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A custom event emitted by the contract."] pub struct ContractEmitted { pub contract : :: subxt :: utils :: AccountId32 , pub data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } impl :: subxt :: events :: StaticEvent for ContractEmitted { const PALLET : & 'static str = "Contracts" ; const EVENT : & 'static str = "ContractEmitted" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A code with the specified hash was removed."] pub struct CodeRemoved { pub code_hash : :: subxt :: utils :: H256 , } impl :: subxt :: events :: StaticEvent for CodeRemoved { const PALLET : & 'static str = "Contracts" ; const EVENT : & 'static str = "CodeRemoved" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A contract's code was updated."] pub struct ContractCodeUpdated { pub contract : :: subxt :: utils :: AccountId32 , pub new_code_hash : :: subxt :: utils :: H256 , pub old_code_hash : :: subxt :: utils :: H256 , } impl :: subxt :: events :: StaticEvent for ContractCodeUpdated { const PALLET : & 'static str = "Contracts" ; const EVENT : & 'static str = "ContractCodeUpdated" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A contract was called either by a plain account or another contract."] # [doc = ""] # [doc = "# Note"] # [doc = ""] # [doc = "Please keep in mind that like all events this is only emitted for successful"] # [doc = "calls. This is because on failure all storage changes including events are"] # [doc = "rolled back."] pub struct Called { pub caller : :: subxt :: utils :: AccountId32 , pub contract : :: subxt :: utils :: AccountId32 , } impl :: subxt :: events :: StaticEvent for Called { const PALLET : & 'static str = "Contracts" ; const EVENT : & 'static str = "Called" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "A contract delegate called a code hash."] # [doc = ""] # [doc = "# Note"] # [doc = ""] # [doc = "Please keep in mind that like all events this is only emitted for successful"] # [doc = "calls. This is because on failure all storage changes including events are"] # [doc = "rolled back."] pub struct DelegateCalled { pub contract : :: subxt :: utils :: AccountId32 , pub code_hash : :: subxt :: utils :: H256 , } impl :: subxt :: events :: StaticEvent for DelegateCalled { const PALLET : & 'static str = "Contracts" ; const EVENT : & 'static str = "DelegateCalled" ; } } pub mod storage { use super :: runtime_types ; pub struct StorageApi ; impl StorageApi { # [doc = " A mapping from an original code hash to the original code, untouched by instrumentation."] pub fn pristine_code (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: utils :: H256 > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Contracts" , "PristineCode" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ())] , [244u8 , 169u8 , 220u8 , 235u8 , 62u8 , 153u8 , 226u8 , 187u8 , 220u8 , 141u8 , 149u8 , 75u8 , 224u8 , 117u8 , 181u8 , 147u8 , 140u8 , 84u8 , 9u8 , 109u8 , 230u8 , 25u8 , 186u8 , 26u8 , 171u8 , 147u8 , 19u8 , 78u8 , 62u8 , 170u8 , 27u8 , 105u8 ,]) } # [doc = " A mapping from an original code hash to the original code, untouched by instrumentation."] pub fn pristine_code_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Contracts" , "PristineCode" , Vec :: new () , [244u8 , 169u8 , 220u8 , 235u8 , 62u8 , 153u8 , 226u8 , 187u8 , 220u8 , 141u8 , 149u8 , 75u8 , 224u8 , 117u8 , 181u8 , 147u8 , 140u8 , 84u8 , 9u8 , 109u8 , 230u8 , 25u8 , 186u8 , 26u8 , 171u8 , 147u8 , 19u8 , 78u8 , 62u8 , 170u8 , 27u8 , 105u8 ,]) } # [doc = " A mapping between an original code hash and instrumented wasm code, ready for execution."] pub fn code_storage (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: utils :: H256 > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: pallet_contracts :: wasm :: PrefabWasmModule , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Contracts" , "CodeStorage" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ())] , [57u8 , 55u8 , 36u8 , 82u8 , 39u8 , 194u8 , 172u8 , 147u8 , 144u8 , 63u8 , 101u8 , 240u8 , 179u8 , 25u8 , 177u8 , 68u8 , 253u8 , 230u8 , 156u8 , 228u8 , 181u8 , 194u8 , 48u8 , 99u8 , 188u8 , 117u8 , 44u8 , 80u8 , 121u8 , 46u8 , 149u8 , 48u8 ,]) } # [doc = " A mapping between an original code hash and instrumented wasm code, ready for execution."] pub fn code_storage_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: pallet_contracts :: wasm :: PrefabWasmModule , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Contracts" , "CodeStorage" , Vec :: new () , [57u8 , 55u8 , 36u8 , 82u8 , 39u8 , 194u8 , 172u8 , 147u8 , 144u8 , 63u8 , 101u8 , 240u8 , 179u8 , 25u8 , 177u8 , 68u8 , 253u8 , 230u8 , 156u8 , 228u8 , 181u8 , 194u8 , 48u8 , 99u8 , 188u8 , 117u8 , 44u8 , 80u8 , 121u8 , 46u8 , 149u8 , 48u8 ,]) } # [doc = " A mapping between an original code hash and its owner information."] pub fn owner_info_of (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: utils :: H256 > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: pallet_contracts :: wasm :: OwnerInfo , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Contracts" , "OwnerInfoOf" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ())] , [147u8 , 6u8 , 225u8 , 62u8 , 211u8 , 236u8 , 61u8 , 116u8 , 152u8 , 219u8 , 220u8 , 17u8 , 82u8 , 221u8 , 156u8 , 88u8 , 63u8 , 204u8 , 16u8 , 11u8 , 184u8 , 236u8 , 181u8 , 189u8 , 170u8 , 160u8 , 60u8 , 64u8 , 71u8 , 250u8 , 202u8 , 186u8 ,]) } # [doc = " A mapping between an original code hash and its owner information."] pub fn owner_info_of_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: pallet_contracts :: wasm :: OwnerInfo , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Contracts" , "OwnerInfoOf" , Vec :: new () , [147u8 , 6u8 , 225u8 , 62u8 , 211u8 , 236u8 , 61u8 , 116u8 , 152u8 , 219u8 , 220u8 , 17u8 , 82u8 , 221u8 , 156u8 , 88u8 , 63u8 , 204u8 , 16u8 , 11u8 , 184u8 , 236u8 , 181u8 , 189u8 , 170u8 , 160u8 , 60u8 , 64u8 , 71u8 , 250u8 , 202u8 , 186u8 ,]) } # [doc = " This is a **monotonic** counter incremented on contract instantiation."] # [doc = ""] # [doc = " This is used in order to generate unique trie ids for contracts."] # [doc = " The trie id of a new contract is calculated from hash(account_id, nonce)."] # [doc = " The nonce is required because otherwise the following sequence would lead to"] # [doc = " a possible collision of storage:"] # [doc = ""] # [doc = " 1. Create a new contract."] # [doc = " 2. Terminate the contract."] # [doc = " 3. Immediately recreate the contract with the same account_id."] # [doc = ""] # [doc = " This is bad because the contents of a trie are deleted lazily and there might be"] # [doc = " storage of the old instantiation still in it when the new contract is created. Please"] # [doc = " note that we can't replace the counter by the block number because the sequence above"] # [doc = " can happen in the same block. We also can't keep the account counter in memory only"] # [doc = " because storage is the only way to communicate across different extrinsics in the"] # [doc = " same block."] # [doc = ""] # [doc = " # Note"] # [doc = ""] # [doc = " Do not use it to determine the number of contracts. It won't be decremented if"] # [doc = " a contract is destroyed."] pub fn nonce (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , :: core :: primitive :: u64 , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("Contracts" , "Nonce" , vec ! [] , [122u8 , 169u8 , 95u8 , 131u8 , 85u8 , 32u8 , 154u8 , 114u8 , 143u8 , 56u8 , 12u8 , 182u8 , 64u8 , 150u8 , 241u8 , 249u8 , 254u8 , 251u8 , 160u8 , 235u8 , 192u8 , 41u8 , 101u8 , 232u8 , 186u8 , 108u8 , 187u8 , 149u8 , 210u8 , 91u8 , 179u8 , 98u8 ,]) } # [doc = " The code associated with a given account."] # [doc = ""] # [doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."] pub fn contract_info_of (& self , _0 : impl :: std :: borrow :: Borrow < :: subxt :: utils :: AccountId32 > ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: pallet_contracts :: storage :: ContractInfo , :: subxt :: storage :: address :: Yes , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Contracts" , "ContractInfoOf" , vec ! [:: subxt :: storage :: address :: make_static_storage_map_key (_0 . borrow ())] , [232u8 , 91u8 , 50u8 , 59u8 , 181u8 , 61u8 , 225u8 , 209u8 , 85u8 , 192u8 , 4u8 , 248u8 , 59u8 , 67u8 , 153u8 , 199u8 , 206u8 , 151u8 , 245u8 , 85u8 , 167u8 , 111u8 , 178u8 , 94u8 , 40u8 , 132u8 , 247u8 , 97u8 , 231u8 , 209u8 , 15u8 , 23u8 ,]) } # [doc = " The code associated with a given account."] # [doc = ""] # [doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."] pub fn contract_info_of_root (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: pallet_contracts :: storage :: ContractInfo , () , () , :: subxt :: storage :: address :: Yes > { :: subxt :: storage :: address :: Address :: new_static ("Contracts" , "ContractInfoOf" , Vec :: new () , [232u8 , 91u8 , 50u8 , 59u8 , 181u8 , 61u8 , 225u8 , 209u8 , 85u8 , 192u8 , 4u8 , 248u8 , 59u8 , 67u8 , 153u8 , 199u8 , 206u8 , 151u8 , 245u8 , 85u8 , 167u8 , 111u8 , 178u8 , 94u8 , 40u8 , 132u8 , 247u8 , 97u8 , 231u8 , 209u8 , 15u8 , 23u8 ,]) } # [doc = " Evicted contracts that await child trie deletion."] # [doc = ""] # [doc = " Child trie deletion is a heavy operation depending on the amount of storage items"] # [doc = " stored in said trie. Therefore this operation is performed lazily in `on_initialize`."] pub fn deletion_queue (& self ,) -> :: subxt :: storage :: address :: Address :: < :: subxt :: storage :: address :: StaticStorageMapKey , runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < runtime_types :: pallet_contracts :: storage :: DeletedContract > , :: subxt :: storage :: address :: Yes , :: subxt :: storage :: address :: Yes , () > { :: subxt :: storage :: address :: Address :: new_static ("Contracts" , "DeletionQueue" , vec ! [] , [119u8 , 169u8 , 146u8 , 210u8 , 21u8 , 216u8 , 51u8 , 225u8 , 107u8 , 61u8 , 42u8 , 155u8 , 169u8 , 127u8 , 140u8 , 106u8 , 255u8 , 137u8 , 163u8 , 199u8 , 91u8 , 137u8 , 73u8 , 61u8 , 9u8 , 167u8 , 16u8 , 157u8 , 183u8 , 212u8 , 35u8 , 88u8 ,]) } } } pub mod constants { use super :: runtime_types ; pub struct ConstantsApi ; impl ConstantsApi { # [doc = " Cost schedule and limits."] pub fn schedule (& self) -> :: subxt :: constants :: Address < runtime_types :: pallet_contracts :: schedule :: Schedule > { :: subxt :: constants :: Address :: new_static ("Contracts" , "Schedule" , [226u8 , 87u8 , 131u8 , 107u8 , 87u8 , 216u8 , 116u8 , 37u8 , 148u8 , 70u8 , 79u8 , 238u8 , 169u8 , 50u8 , 213u8 , 148u8 , 134u8 , 252u8 , 58u8 , 185u8 , 153u8 , 57u8 , 107u8 , 99u8 , 166u8 , 213u8 , 251u8 , 246u8 , 156u8 , 105u8 , 155u8 , 211u8 ,]) } # [doc = " The maximum number of contracts that can be pending for deletion."] # [doc = ""] # [doc = " When a contract is deleted by calling `seal_terminate` it becomes inaccessible"] # [doc = " immediately, but the deletion of the storage items it has accumulated is performed"] # [doc = " later. The contract is put into the deletion queue. This defines how many"] # [doc = " contracts can be queued up at the same time. If that limit is reached `seal_terminate`"] # [doc = " will fail. The action must be retried in a later block in that case."] # [doc = ""] # [doc = " The reasons for limiting the queue depth are:"] # [doc = ""] # [doc = " 1. The queue is in storage in order to be persistent between blocks. We want to limit"] # [doc = " \tthe amount of storage that can be consumed."] # [doc = " 2. The queue is stored in a vector and needs to be decoded as a whole when reading"] # [doc = "\t\tit at the end of each block. Longer queues take more weight to decode and hence"] # [doc = "\t\tlimit the amount of items that can be deleted per block."] pub fn deletion_queue_depth (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u32 > { :: subxt :: constants :: Address :: new_static ("Contracts" , "DeletionQueueDepth" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The maximum amount of weight that can be consumed per block for lazy trie removal."] # [doc = ""] # [doc = " The amount of weight that is dedicated per block to work on the deletion queue. Larger"] # [doc = " values allow more trie keys to be deleted in each block but reduce the amount of"] # [doc = " weight that is left for transactions. See [`Self::DeletionQueueDepth`] for more"] # [doc = " information about the deletion queue."] pub fn deletion_weight_limit (& self) -> :: subxt :: constants :: Address < runtime_types :: sp_weights :: weight_v2 :: Weight > { :: subxt :: constants :: Address :: new_static ("Contracts" , "DeletionWeightLimit" , [206u8 , 61u8 , 253u8 , 247u8 , 163u8 , 40u8 , 161u8 , 52u8 , 134u8 , 140u8 , 206u8 , 83u8 , 44u8 , 166u8 , 226u8 , 115u8 , 181u8 , 14u8 , 227u8 , 130u8 , 210u8 , 32u8 , 85u8 , 29u8 , 230u8 , 97u8 , 130u8 , 165u8 , 147u8 , 134u8 , 106u8 , 76u8 ,]) } # [doc = " The amount of balance a caller has to pay for each byte of storage."] # [doc = ""] # [doc = " # Note"] # [doc = ""] # [doc = " Changing this value for an existing chain might need a storage migration."] pub fn deposit_per_byte (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u128 > { :: subxt :: constants :: Address :: new_static ("Contracts" , "DepositPerByte" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The amount of balance a caller has to pay for each storage item."] # [doc = ""] # [doc = " # Note"] # [doc = ""] # [doc = " Changing this value for an existing chain might need a storage migration."] pub fn deposit_per_item (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u128 > { :: subxt :: constants :: Address :: new_static ("Contracts" , "DepositPerItem" , [84u8 , 157u8 , 140u8 , 4u8 , 93u8 , 57u8 , 29u8 , 133u8 , 105u8 , 200u8 , 214u8 , 27u8 , 144u8 , 208u8 , 218u8 , 160u8 , 130u8 , 109u8 , 101u8 , 54u8 , 210u8 , 136u8 , 71u8 , 63u8 , 49u8 , 237u8 , 234u8 , 15u8 , 178u8 , 98u8 , 148u8 , 156u8 ,]) } # [doc = " The maximum length of a contract code in bytes. This limit applies to the instrumented"] # [doc = " version of the code. Therefore `instantiate_with_code` can fail even when supplying"] # [doc = " a wasm binary below this maximum size."] # [doc = ""] # [doc = " The value should be chosen carefully taking into the account the overall memory limit"] # [doc = " your runtime has, as well as the [maximum allowed callstack"] # [doc = " depth](#associatedtype.CallStack). Look into the `integrity_test()` for some insights."] pub fn max_code_len (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u32 > { :: subxt :: constants :: Address :: new_static ("Contracts" , "MaxCodeLen" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " The maximum allowable length in bytes for storage keys."] pub fn max_storage_key_len (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u32 > { :: subxt :: constants :: Address :: new_static ("Contracts" , "MaxStorageKeyLen" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } # [doc = " Make contract callable functions marked as `#[unstable]` available."] # [doc = ""] # [doc = " Contracts that use `#[unstable]` functions won't be able to be uploaded unless"] # [doc = " this is set to `true`. This is only meant for testnets and dev nodes in order to"] # [doc = " experiment with new features."] # [doc = ""] # [doc = " # Warning"] # [doc = ""] # [doc = " Do **not** set to `true` on productions chains."] pub fn unsafe_unstable_interface (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: bool > { :: subxt :: constants :: Address :: new_static ("Contracts" , "UnsafeUnstableInterface" , [165u8 , 28u8 , 112u8 , 190u8 , 18u8 , 129u8 , 182u8 , 206u8 , 237u8 , 1u8 , 68u8 , 252u8 , 125u8 , 234u8 , 185u8 , 50u8 , 149u8 , 164u8 , 47u8 , 126u8 , 134u8 , 100u8 , 14u8 , 86u8 , 209u8 , 39u8 , 20u8 , 4u8 , 233u8 , 115u8 , 102u8 , 131u8 ,]) } # [doc = " The maximum length of the debug buffer in bytes."] pub fn max_debug_buffer_len (& self) -> :: subxt :: constants :: Address < :: core :: primitive :: u32 > { :: subxt :: constants :: Address :: new_static ("Contracts" , "MaxDebugBufferLen" , [98u8 , 252u8 , 116u8 , 72u8 , 26u8 , 180u8 , 225u8 , 83u8 , 200u8 , 157u8 , 125u8 , 151u8 , 53u8 , 76u8 , 168u8 , 26u8 , 10u8 , 9u8 , 98u8 , 68u8 , 9u8 , 178u8 , 197u8 , 113u8 , 31u8 , 79u8 , 200u8 , 90u8 , 203u8 , 100u8 , 41u8 , 145u8 ,]) } } } } pub mod xvm { use super :: root_mod ; use super :: runtime_types ; # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub mod calls { use super :: root_mod ; use super :: runtime_types ; type DispatchError = runtime_types :: sp_runtime :: DispatchError ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct XvmCall { pub context : runtime_types :: pallet_xvm :: XvmContext , pub to : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub input : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct XvmSend { pub context : runtime_types :: pallet_xvm :: XvmContext , pub to : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub message : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct XvmQuery { pub context : runtime_types :: pallet_xvm :: XvmContext , } pub struct TransactionApi ; impl TransactionApi { pub fn xvm_call (& self , context : runtime_types :: pallet_xvm :: XvmContext , to : :: std :: vec :: Vec < :: core :: primitive :: u8 > , input : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: tx :: Payload < XvmCall > { :: subxt :: tx :: Payload :: new_static ("Xvm" , "xvm_call" , XvmCall { context , to , input , } , [11u8 , 65u8 , 216u8 , 239u8 , 123u8 , 74u8 , 17u8 , 141u8 , 215u8 , 134u8 , 41u8 , 142u8 , 126u8 , 244u8 , 111u8 , 196u8 , 114u8 , 212u8 , 21u8 , 148u8 , 188u8 , 234u8 , 185u8 , 86u8 , 100u8 , 51u8 , 121u8 , 120u8 , 199u8 , 7u8 , 67u8 , 64u8 ,]) } pub fn xvm_send (& self , context : runtime_types :: pallet_xvm :: XvmContext , to : :: std :: vec :: Vec < :: core :: primitive :: u8 > , message : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: tx :: Payload < XvmSend > { :: subxt :: tx :: Payload :: new_static ("Xvm" , "xvm_send" , XvmSend { context , to , message , } , [201u8 , 80u8 , 202u8 , 98u8 , 190u8 , 206u8 , 208u8 , 24u8 , 66u8 , 44u8 , 43u8 , 236u8 , 197u8 , 188u8 , 64u8 , 128u8 , 214u8 , 215u8 , 188u8 , 112u8 , 94u8 , 3u8 , 99u8 , 148u8 , 127u8 , 190u8 , 138u8 , 134u8 , 106u8 , 251u8 , 148u8 , 5u8 ,]) } pub fn xvm_query (& self , context : runtime_types :: pallet_xvm :: XvmContext ,) -> :: subxt :: tx :: Payload < XvmQuery > { :: subxt :: tx :: Payload :: new_static ("Xvm" , "xvm_query" , XvmQuery { context , } , [2u8 , 149u8 , 42u8 , 221u8 , 32u8 , 167u8 , 108u8 , 183u8 , 19u8 , 95u8 , 70u8 , 176u8 , 87u8 , 207u8 , 81u8 , 130u8 , 1u8 , 104u8 , 8u8 , 241u8 , 175u8 , 238u8 , 18u8 , 218u8 , 236u8 , 0u8 , 25u8 , 70u8 , 194u8 , 85u8 , 88u8 , 113u8 ,]) } } } # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub type Event = runtime_types :: pallet_xvm :: pallet :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct XvmCall { pub result : :: core :: result :: Result < :: std :: vec :: Vec < :: core :: primitive :: u8 > , runtime_types :: pallet_xvm :: XvmError > , } impl :: subxt :: events :: StaticEvent for XvmCall { const PALLET : & 'static str = "Xvm" ; const EVENT : & 'static str = "XvmCall" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct XvmSend { pub result : :: core :: result :: Result < :: std :: vec :: Vec < :: core :: primitive :: u8 > , runtime_types :: pallet_xvm :: XvmError > , } impl :: subxt :: events :: StaticEvent for XvmSend { const PALLET : & 'static str = "Xvm" ; const EVENT : & 'static str = "XvmSend" ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct XvmQuery { pub result : :: core :: result :: Result < :: std :: vec :: Vec < :: core :: primitive :: u8 > , runtime_types :: pallet_xvm :: XvmError > , } impl :: subxt :: events :: StaticEvent for XvmQuery { const PALLET : & 'static str = "Xvm" ; const EVENT : & 'static str = "XvmQuery" ; } } } pub mod runtime_types { use super :: runtime_types ; pub mod bounded_collections { use super :: runtime_types ; pub mod bounded_vec { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct BoundedVec < _0 > (pub :: std :: vec :: Vec < _0 > ,) ; } pub mod weak_bounded_vec { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct WeakBoundedVec < _0 > (pub :: std :: vec :: Vec < _0 > ,) ; } } pub mod ethbloom { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Bloom (pub [:: core :: primitive :: u8 ; 256usize] ,) ; } pub mod ethereum { use super :: runtime_types ; pub mod block { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Block < _0 > { pub header : runtime_types :: ethereum :: header :: Header , pub transactions : :: std :: vec :: Vec < _0 > , pub ommers : :: std :: vec :: Vec < runtime_types :: ethereum :: header :: Header > , } } pub mod header { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Header { pub parent_hash : :: subxt :: utils :: H256 , pub ommers_hash : :: subxt :: utils :: H256 , pub beneficiary : :: subxt :: utils :: H160 , pub state_root : :: subxt :: utils :: H256 , pub transactions_root : :: subxt :: utils :: H256 , pub receipts_root : :: subxt :: utils :: H256 , pub logs_bloom : runtime_types :: ethbloom :: Bloom , pub difficulty : runtime_types :: primitive_types :: U256 , pub number : runtime_types :: primitive_types :: U256 , pub gas_limit : runtime_types :: primitive_types :: U256 , pub gas_used : runtime_types :: primitive_types :: U256 , pub timestamp : :: core :: primitive :: u64 , pub extra_data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub mix_hash : :: subxt :: utils :: H256 , pub nonce : runtime_types :: ethereum_types :: hash :: H64 , } } pub mod log { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Log { pub address : :: subxt :: utils :: H160 , pub topics : :: std :: vec :: Vec < :: subxt :: utils :: H256 > , pub data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } } pub mod receipt { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct EIP658ReceiptData { pub status_code : :: core :: primitive :: u8 , pub used_gas : runtime_types :: primitive_types :: U256 , pub logs_bloom : runtime_types :: ethbloom :: Bloom , pub logs : :: std :: vec :: Vec < runtime_types :: ethereum :: log :: Log > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum ReceiptV3 { # [codec (index = 0)] Legacy (runtime_types :: ethereum :: receipt :: EIP658ReceiptData ,) , # [codec (index = 1)] EIP2930 (runtime_types :: ethereum :: receipt :: EIP658ReceiptData ,) , # [codec (index = 2)] EIP1559 (runtime_types :: ethereum :: receipt :: EIP658ReceiptData ,) , } } pub mod transaction { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct AccessListItem { pub address : :: subxt :: utils :: H160 , pub storage_keys : :: std :: vec :: Vec < :: subxt :: utils :: H256 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct EIP1559Transaction { pub chain_id : :: core :: primitive :: u64 , pub nonce : runtime_types :: primitive_types :: U256 , pub max_priority_fee_per_gas : runtime_types :: primitive_types :: U256 , pub max_fee_per_gas : runtime_types :: primitive_types :: U256 , pub gas_limit : runtime_types :: primitive_types :: U256 , pub action : runtime_types :: ethereum :: transaction :: TransactionAction , pub value : runtime_types :: primitive_types :: U256 , pub input : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub access_list : :: std :: vec :: Vec < runtime_types :: ethereum :: transaction :: AccessListItem > , pub odd_y_parity : :: core :: primitive :: bool , pub r : :: subxt :: utils :: H256 , pub s : :: subxt :: utils :: H256 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct EIP2930Transaction { pub chain_id : :: core :: primitive :: u64 , pub nonce : runtime_types :: primitive_types :: U256 , pub gas_price : runtime_types :: primitive_types :: U256 , pub gas_limit : runtime_types :: primitive_types :: U256 , pub action : runtime_types :: ethereum :: transaction :: TransactionAction , pub value : runtime_types :: primitive_types :: U256 , pub input : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub access_list : :: std :: vec :: Vec < runtime_types :: ethereum :: transaction :: AccessListItem > , pub odd_y_parity : :: core :: primitive :: bool , pub r : :: subxt :: utils :: H256 , pub s : :: subxt :: utils :: H256 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct LegacyTransaction { pub nonce : runtime_types :: primitive_types :: U256 , pub gas_price : runtime_types :: primitive_types :: U256 , pub gas_limit : runtime_types :: primitive_types :: U256 , pub action : runtime_types :: ethereum :: transaction :: TransactionAction , pub value : runtime_types :: primitive_types :: U256 , pub input : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub signature : runtime_types :: ethereum :: transaction :: TransactionSignature , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum TransactionAction { # [codec (index = 0)] Call (:: subxt :: utils :: H160 ,) , # [codec (index = 1)] Create , } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct TransactionRecoveryId (pub :: core :: primitive :: u64 ,) ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct TransactionSignature { pub v : runtime_types :: ethereum :: transaction :: TransactionRecoveryId , pub r : :: subxt :: utils :: H256 , pub s : :: subxt :: utils :: H256 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum TransactionV2 { # [codec (index = 0)] Legacy (runtime_types :: ethereum :: transaction :: LegacyTransaction ,) , # [codec (index = 1)] EIP2930 (runtime_types :: ethereum :: transaction :: EIP2930Transaction ,) , # [codec (index = 2)] EIP1559 (runtime_types :: ethereum :: transaction :: EIP1559Transaction ,) , } } } pub mod ethereum_types { use super :: runtime_types ; pub mod hash { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct H64 (pub [:: core :: primitive :: u8 ; 8usize] ,) ; } } pub mod evm_core { use super :: runtime_types ; pub mod error { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum ExitError { # [codec (index = 0)] StackUnderflow , # [codec (index = 1)] StackOverflow , # [codec (index = 2)] InvalidJump , # [codec (index = 3)] InvalidRange , # [codec (index = 4)] DesignatedInvalid , # [codec (index = 5)] CallTooDeep , # [codec (index = 6)] CreateCollision , # [codec (index = 7)] CreateContractLimit , # [codec (index = 15)] InvalidCode (runtime_types :: evm_core :: opcode :: Opcode ,) , # [codec (index = 8)] OutOfOffset , # [codec (index = 9)] OutOfGas , # [codec (index = 10)] OutOfFund , # [codec (index = 11)] PCUnderflow , # [codec (index = 12)] CreateEmpty , # [codec (index = 13)] Other (:: std :: string :: String ,) , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum ExitFatal { # [codec (index = 0)] NotSupported , # [codec (index = 1)] UnhandledInterrupt , # [codec (index = 2)] CallErrorAsFatal (runtime_types :: evm_core :: error :: ExitError ,) , # [codec (index = 3)] Other (:: std :: string :: String ,) , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum ExitReason { # [codec (index = 0)] Succeed (runtime_types :: evm_core :: error :: ExitSucceed ,) , # [codec (index = 1)] Error (runtime_types :: evm_core :: error :: ExitError ,) , # [codec (index = 2)] Revert (runtime_types :: evm_core :: error :: ExitRevert ,) , # [codec (index = 3)] Fatal (runtime_types :: evm_core :: error :: ExitFatal ,) , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum ExitRevert { # [codec (index = 0)] Reverted , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum ExitSucceed { # [codec (index = 0)] Stopped , # [codec (index = 1)] Returned , # [codec (index = 2)] Suicided , } } pub mod opcode { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Opcode (pub :: core :: primitive :: u8 ,) ; } } pub mod finality_grandpa { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Equivocation < _0 , _1 , _2 > { pub round_number : :: core :: primitive :: u64 , pub identity : _0 , pub first : (_1 , _2 ,) , pub second : (_1 , _2 ,) , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Precommit < _0 , _1 > { pub target_hash : _0 , pub target_number : _1 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Prevote < _0 , _1 > { pub target_hash : _0 , pub target_number : _1 , } } pub mod fp_rpc { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct TransactionStatus { pub transaction_hash : :: subxt :: utils :: H256 , pub transaction_index : :: core :: primitive :: u32 , pub from : :: subxt :: utils :: H160 , pub to : :: core :: option :: Option < :: subxt :: utils :: H160 > , pub contract_address : :: core :: option :: Option < :: subxt :: utils :: H160 > , pub logs : :: std :: vec :: Vec < runtime_types :: ethereum :: log :: Log > , pub logs_bloom : runtime_types :: ethbloom :: Bloom , } } pub mod fp_self_contained { use super :: runtime_types ; pub mod unchecked_extrinsic { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct UncheckedExtrinsic < _0 , _1 , _2 , _3 > (pub runtime_types :: sp_runtime :: generic :: unchecked_extrinsic :: UncheckedExtrinsic < _0 , _1 , _2 , _3 > ,) ; } } pub mod frame_support { use super :: runtime_types ; pub mod dispatch { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum DispatchClass { # [codec (index = 0)] Normal , # [codec (index = 1)] Operational , # [codec (index = 2)] Mandatory , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct DispatchInfo { pub weight : runtime_types :: sp_weights :: weight_v2 :: Weight , pub class : runtime_types :: frame_support :: dispatch :: DispatchClass , pub pays_fee : runtime_types :: frame_support :: dispatch :: Pays , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum Pays { # [codec (index = 0)] Yes , # [codec (index = 1)] No , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct PerDispatchClass < _0 > { pub normal : _0 , pub operational : _0 , pub mandatory : _0 , } } pub mod traits { use super :: runtime_types ; pub mod misc { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct WrapperOpaque < _0 > (# [codec (compact)] pub :: core :: primitive :: u32 , pub _0 ,) ; } pub mod tokens { use super :: runtime_types ; pub mod misc { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum BalanceStatus { # [codec (index = 0)] Free , # [codec (index = 1)] Reserved , } } } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct PalletId (pub [:: core :: primitive :: u8 ; 8usize] ,) ; } pub mod frame_system { use super :: runtime_types ; pub mod extensions { use super :: runtime_types ; pub mod check_genesis { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct CheckGenesis ; } pub mod check_mortality { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct CheckMortality (pub runtime_types :: sp_runtime :: generic :: era :: Era ,) ; } pub mod check_nonce { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct CheckNonce (# [codec (compact)] pub :: core :: primitive :: u32 ,) ; } pub mod check_spec_version { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct CheckSpecVersion ; } pub mod check_tx_version { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct CheckTxVersion ; } pub mod check_weight { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct CheckWeight ; } } pub mod limits { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct BlockLength { pub max : runtime_types :: frame_support :: dispatch :: PerDispatchClass < :: core :: primitive :: u32 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct BlockWeights { pub base_block : runtime_types :: sp_weights :: weight_v2 :: Weight , pub max_block : runtime_types :: sp_weights :: weight_v2 :: Weight , pub per_class : runtime_types :: frame_support :: dispatch :: PerDispatchClass < runtime_types :: frame_system :: limits :: WeightsPerClass > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct WeightsPerClass { pub base_extrinsic : runtime_types :: sp_weights :: weight_v2 :: Weight , pub max_extrinsic : :: core :: option :: Option < runtime_types :: sp_weights :: weight_v2 :: Weight > , pub max_total : :: core :: option :: Option < runtime_types :: sp_weights :: weight_v2 :: Weight > , pub reserved : :: core :: option :: Option < runtime_types :: sp_weights :: weight_v2 :: Weight > , } } pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Make some on-chain remark."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)`"] remark { remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 1)] # [doc = "Set the number of pages in the WebAssembly environment's heap."] set_heap_pages { pages : :: core :: primitive :: u64 , } , # [codec (index = 2)] # [doc = "Set the new runtime code."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`"] set_code { code : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 3)] # [doc = "Set the new runtime code without doing any checks of the given `code`."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(C)` where `C` length of `code`"] set_code_without_checks { code : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 4)] # [doc = "Set some items of storage."] set_storage { items : :: std :: vec :: Vec < (:: std :: vec :: Vec < :: core :: primitive :: u8 > , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) > , } , # [codec (index = 5)] # [doc = "Kill some items from storage."] kill_storage { keys : :: std :: vec :: Vec < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , } , # [codec (index = 6)] # [doc = "Kill all storage items with a key that starts with the given prefix."] # [doc = ""] # [doc = "**NOTE:** We rely on the Root origin to provide us the number of subkeys under"] # [doc = "the prefix we are removing to accurately calculate the weight of this function."] kill_prefix { prefix : :: std :: vec :: Vec < :: core :: primitive :: u8 > , subkeys : :: core :: primitive :: u32 , } , # [codec (index = 7)] # [doc = "Make some on-chain remark and emit event."] remark_with_event { remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Error for the System pallet"] pub enum Error { # [codec (index = 0)] # [doc = "The name of specification does not match between the current runtime"] # [doc = "and the new runtime."] InvalidSpecName , # [codec (index = 1)] # [doc = "The specification version is not allowed to decrease between the current runtime"] # [doc = "and the new runtime."] SpecVersionNeedsToIncrease , # [codec (index = 2)] # [doc = "Failed to extract the runtime version from the new runtime."] # [doc = ""] # [doc = "Either calling `Core_version` or decoding `RuntimeVersion` failed."] FailedToExtractRuntimeVersion , # [codec (index = 3)] # [doc = "Suicide called when the account has non-default composite data."] NonDefaultComposite , # [codec (index = 4)] # [doc = "There is a non-zero reference count preventing the account from being purged."] NonZeroRefCount , # [codec (index = 5)] # [doc = "The origin filter prevent the call to be dispatched."] CallFiltered , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Event for the System pallet."] pub enum Event { # [codec (index = 0)] # [doc = "An extrinsic completed successfully."] ExtrinsicSuccess { dispatch_info : runtime_types :: frame_support :: dispatch :: DispatchInfo , } , # [codec (index = 1)] # [doc = "An extrinsic failed."] ExtrinsicFailed { dispatch_error : runtime_types :: sp_runtime :: DispatchError , dispatch_info : runtime_types :: frame_support :: dispatch :: DispatchInfo , } , # [codec (index = 2)] # [doc = "`:code` was updated."] CodeUpdated , # [codec (index = 3)] # [doc = "A new account was created."] NewAccount { account : :: subxt :: utils :: AccountId32 , } , # [codec (index = 4)] # [doc = "An account was reaped."] KilledAccount { account : :: subxt :: utils :: AccountId32 , } , # [codec (index = 5)] # [doc = "On on-chain remark happened."] Remarked { sender : :: subxt :: utils :: AccountId32 , hash : :: subxt :: utils :: H256 , } , } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct AccountInfo < _0 , _1 > { pub nonce : _0 , pub consumers : _0 , pub providers : _0 , pub sufficients : _0 , pub data : _1 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct EventRecord < _0 , _1 > { pub phase : runtime_types :: frame_system :: Phase , pub event : _0 , pub topics : :: std :: vec :: Vec < _1 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct LastRuntimeUpgradeInfo { # [codec (compact)] pub spec_version : :: core :: primitive :: u32 , pub spec_name : :: std :: string :: String , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum Phase { # [codec (index = 0)] ApplyExtrinsic (:: core :: primitive :: u32 ,) , # [codec (index = 1)] Finalization , # [codec (index = 2)] Initialization , } } pub mod golden_gate_runtime_testnet { use super :: runtime_types ; pub mod opaque { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct SessionKeys { pub aura : runtime_types :: sp_consensus_aura :: sr25519 :: app_sr25519 :: Public , pub grandpa : runtime_types :: sp_finality_grandpa :: app :: Public , pub im_online : runtime_types :: pallet_im_online :: sr25519 :: app_sr25519 :: Public , } } pub mod poa { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum ProxyType { # [codec (index = 0)] Any , # [codec (index = 1)] NonTransfer , # [codec (index = 2)] Governance , # [codec (index = 3)] Staking , # [codec (index = 4)] Identity , # [codec (index = 5)] Cancel , } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Runtime ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum RuntimeCall { # [codec (index = 0)] System (runtime_types :: frame_system :: pallet :: Call ,) , # [codec (index = 1)] Timestamp (runtime_types :: pallet_timestamp :: pallet :: Call ,) , # [codec (index = 3)] Balances (runtime_types :: pallet_balances :: pallet :: Call ,) , # [codec (index = 5)] ImOnline (runtime_types :: pallet_im_online :: pallet :: Call ,) , # [codec (index = 9)] Session (runtime_types :: pallet_session :: pallet :: Call ,) , # [codec (index = 10)] Grandpa (runtime_types :: pallet_grandpa :: pallet :: Call ,) , # [codec (index = 11)] Treasury (runtime_types :: pallet_treasury :: pallet :: Call ,) , # [codec (index = 12)] Bounties (runtime_types :: pallet_bounties :: pallet :: Call ,) , # [codec (index = 13)] Vesting (runtime_types :: pallet_vesting :: pallet :: Call ,) , # [codec (index = 14)] Indices (runtime_types :: pallet_indices :: pallet :: Call ,) , # [codec (index = 15)] Proxy (runtime_types :: pallet_proxy :: pallet :: Call ,) , # [codec (index = 16)] Multisig (runtime_types :: pallet_multisig :: pallet :: Call ,) , # [codec (index = 17)] Identity (runtime_types :: pallet_identity :: pallet :: Call ,) , # [codec (index = 18)] Sudo (runtime_types :: pallet_sudo :: pallet :: Call ,) , # [codec (index = 21)] ValidatorManager (runtime_types :: runtime_common :: validator_manager :: pallet :: Call ,) , # [codec (index = 22)] Ethereum (runtime_types :: pallet_ethereum :: pallet :: Call ,) , # [codec (index = 23)] EVM (runtime_types :: pallet_evm :: pallet :: Call ,) , # [codec (index = 25)] DynamicFee (runtime_types :: pallet_dynamic_fee :: pallet :: Call ,) , # [codec (index = 26)] BaseFee (runtime_types :: pallet_base_fee :: pallet :: Call ,) , # [codec (index = 27)] HotfixSufficients (runtime_types :: pallet_hotfix_sufficients :: pallet :: Call ,) , # [codec (index = 28)] AccountFilter (runtime_types :: substrate_account_filter :: pallet :: Call ,) , # [codec (index = 29)] Contracts (runtime_types :: pallet_contracts :: pallet :: Call ,) , # [codec (index = 30)] Xvm (runtime_types :: pallet_xvm :: pallet :: pallet :: Call ,) , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum RuntimeEvent { # [codec (index = 0)] System (runtime_types :: frame_system :: pallet :: Event ,) , # [codec (index = 3)] Balances (runtime_types :: pallet_balances :: pallet :: Event ,) , # [codec (index = 5)] ImOnline (runtime_types :: pallet_im_online :: pallet :: Event ,) , # [codec (index = 6)] TransactionPayment (runtime_types :: pallet_transaction_payment :: pallet :: Event ,) , # [codec (index = 8)] Offences (runtime_types :: pallet_offences :: pallet :: Event ,) , # [codec (index = 9)] Session (runtime_types :: pallet_session :: pallet :: Event ,) , # [codec (index = 10)] Grandpa (runtime_types :: pallet_grandpa :: pallet :: Event ,) , # [codec (index = 11)] Treasury (runtime_types :: pallet_treasury :: pallet :: Event ,) , # [codec (index = 12)] Bounties (runtime_types :: pallet_bounties :: pallet :: Event ,) , # [codec (index = 13)] Vesting (runtime_types :: pallet_vesting :: pallet :: Event ,) , # [codec (index = 14)] Indices (runtime_types :: pallet_indices :: pallet :: Event ,) , # [codec (index = 15)] Proxy (runtime_types :: pallet_proxy :: pallet :: Event ,) , # [codec (index = 16)] Multisig (runtime_types :: pallet_multisig :: pallet :: Event ,) , # [codec (index = 17)] Identity (runtime_types :: pallet_identity :: pallet :: Event ,) , # [codec (index = 18)] Sudo (runtime_types :: pallet_sudo :: pallet :: Event ,) , # [codec (index = 21)] ValidatorManager (runtime_types :: runtime_common :: validator_manager :: pallet :: Event ,) , # [codec (index = 22)] Ethereum (runtime_types :: pallet_ethereum :: pallet :: Event ,) , # [codec (index = 23)] EVM (runtime_types :: pallet_evm :: pallet :: Event ,) , # [codec (index = 26)] BaseFee (runtime_types :: pallet_base_fee :: pallet :: Event ,) , # [codec (index = 28)] AccountFilter (runtime_types :: substrate_account_filter :: pallet :: Event ,) , # [codec (index = 29)] Contracts (runtime_types :: pallet_contracts :: pallet :: Event ,) , # [codec (index = 30)] Xvm (runtime_types :: pallet_xvm :: pallet :: pallet :: Event ,) , } } pub mod pallet_balances { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Transfer some liquid free balance to another account."] # [doc = ""] # [doc = "`transfer` will set the `FreeBalance` of the sender and receiver."] # [doc = "If the sender's account is below the existential deposit as a result"] # [doc = "of the transfer, the account will be reaped."] # [doc = ""] # [doc = "The dispatch origin for this call must be `Signed` by the transactor."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- Dependent on arguments but not critical, given proper implementations for input config"] # [doc = "  types. See related functions below."] # [doc = "- It contains a limited number of reads and writes internally and no complex"] # [doc = "  computation."] # [doc = ""] # [doc = "Related functions:"] # [doc = ""] # [doc = "  - `ensure_can_withdraw` is always called internally but has a bounded complexity."] # [doc = "  - Transferring balances to accounts that did not exist before will cause"] # [doc = "    `T::OnNewAccount::on_new_account` to be called."] # [doc = "  - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`."] # [doc = "  - `transfer_keep_alive` works the same way as `transfer`, but has an additional check"] # [doc = "    that the transfer will not kill the origin account."] transfer { dest : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] value : :: core :: primitive :: u128 , } , # [codec (index = 1)] # [doc = "Set the balances of a given account."] # [doc = ""] # [doc = "This will alter `FreeBalance` and `ReservedBalance` in storage. it will"] # [doc = "also alter the total issuance of the system (`TotalIssuance`) appropriately."] # [doc = "If the new free or reserved balance is below the existential deposit,"] # [doc = "it will reset the account nonce (`frame_system::AccountNonce`)."] # [doc = ""] # [doc = "The dispatch origin for this call is `root`."] set_balance { who : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] new_free : :: core :: primitive :: u128 , # [codec (compact)] new_reserved : :: core :: primitive :: u128 , } , # [codec (index = 2)] # [doc = "Exactly as `transfer`, except the origin must be root and the source account may be"] # [doc = "specified."] # [doc = "## Complexity"] # [doc = "- Same as transfer, but additional read and write because the source account is not"] # [doc = "  assumed to be in the overlay."] force_transfer { source : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , dest : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] value : :: core :: primitive :: u128 , } , # [codec (index = 3)] # [doc = "Same as the [`transfer`] call, but with a check that the transfer will not kill the"] # [doc = "origin account."] # [doc = ""] # [doc = "99% of the time you want [`transfer`] instead."] # [doc = ""] # [doc = "[`transfer`]: struct.Pallet.html#method.transfer"] transfer_keep_alive { dest : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] value : :: core :: primitive :: u128 , } , # [codec (index = 4)] # [doc = "Transfer the entire transferable balance from the caller account."] # [doc = ""] # [doc = "NOTE: This function only attempts to transfer _transferable_ balances. This means that"] # [doc = "any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be"] # [doc = "transferred by this function. To ensure that this function results in a killed account,"] # [doc = "you might need to prepare the account by removing any reference counters, storage"] # [doc = "deposits, etc..."] # [doc = ""] # [doc = "The dispatch origin of this call must be Signed."] # [doc = ""] # [doc = "- `dest`: The recipient of the transfer."] # [doc = "- `keep_alive`: A boolean to determine if the `transfer_all` operation should send all"] # [doc = "  of the funds the account has, causing the sender account to be killed (false), or"] # [doc = "  transfer everything except at least the existential deposit, which will guarantee to"] # [doc = "  keep the sender account alive (true). ## Complexity"] # [doc = "- O(1). Just like transfer, but reading the user's transferable balance first."] transfer_all { dest : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , keep_alive : :: core :: primitive :: bool , } , # [codec (index = 5)] # [doc = "Unreserve some balance from a user by force."] # [doc = ""] # [doc = "Can only be called by ROOT."] force_unreserve { who : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , amount : :: core :: primitive :: u128 , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "Vesting balance too high to send value"] VestingBalance , # [codec (index = 1)] # [doc = "Account liquidity restrictions prevent withdrawal"] LiquidityRestrictions , # [codec (index = 2)] # [doc = "Balance too low to send value."] InsufficientBalance , # [codec (index = 3)] # [doc = "Value too low to create account due to existential deposit"] ExistentialDeposit , # [codec (index = 4)] # [doc = "Transfer/payment would kill account"] KeepAlive , # [codec (index = 5)] # [doc = "A vesting schedule already exists for this account"] ExistingVestingSchedule , # [codec (index = 6)] # [doc = "Beneficiary account must pre-exist"] DeadAccount , # [codec (index = 7)] # [doc = "Number of named reserves exceed MaxReserves"] TooManyReserves , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "An account was created with some free balance."] Endowed { account : :: subxt :: utils :: AccountId32 , free_balance : :: core :: primitive :: u128 , } , # [codec (index = 1)] # [doc = "An account was removed whose balance was non-zero but below ExistentialDeposit,"] # [doc = "resulting in an outright loss."] DustLost { account : :: subxt :: utils :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 2)] # [doc = "Transfer succeeded."] Transfer { from : :: subxt :: utils :: AccountId32 , to : :: subxt :: utils :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 3)] # [doc = "A balance was set by root."] BalanceSet { who : :: subxt :: utils :: AccountId32 , free : :: core :: primitive :: u128 , reserved : :: core :: primitive :: u128 , } , # [codec (index = 4)] # [doc = "Some balance was reserved (moved from free to reserved)."] Reserved { who : :: subxt :: utils :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 5)] # [doc = "Some balance was unreserved (moved from reserved to free)."] Unreserved { who : :: subxt :: utils :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 6)] # [doc = "Some balance was moved from the reserve of the first account to the second account."] # [doc = "Final argument indicates the destination balance type."] ReserveRepatriated { from : :: subxt :: utils :: AccountId32 , to : :: subxt :: utils :: AccountId32 , amount : :: core :: primitive :: u128 , destination_status : runtime_types :: frame_support :: traits :: tokens :: misc :: BalanceStatus , } , # [codec (index = 7)] # [doc = "Some amount was deposited (e.g. for transaction fees)."] Deposit { who : :: subxt :: utils :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 8)] # [doc = "Some amount was withdrawn from the account (e.g. for transaction fees)."] Withdraw { who : :: subxt :: utils :: AccountId32 , amount : :: core :: primitive :: u128 , } , # [codec (index = 9)] # [doc = "Some amount was removed from the account (e.g. for misbehavior)."] Slashed { who : :: subxt :: utils :: AccountId32 , amount : :: core :: primitive :: u128 , } , } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct AccountData < _0 > { pub free : _0 , pub reserved : _0 , pub misc_frozen : _0 , pub fee_frozen : _0 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct BalanceLock < _0 > { pub id : [:: core :: primitive :: u8 ; 8usize] , pub amount : _0 , pub reasons : runtime_types :: pallet_balances :: Reasons , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum Reasons { # [codec (index = 0)] Fee , # [codec (index = 1)] Misc , # [codec (index = 2)] All , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct ReserveData < _0 , _1 > { pub id : _0 , pub amount : _1 , } } pub mod pallet_base_fee { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] set_base_fee_per_gas { fee : runtime_types :: primitive_types :: U256 , } , # [codec (index = 1)] set_elasticity { elasticity : runtime_types :: sp_arithmetic :: per_things :: Permill , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] NewBaseFeePerGas { fee : runtime_types :: primitive_types :: U256 , } , # [codec (index = 1)] BaseFeeOverflow , # [codec (index = 2)] NewElasticity { elasticity : runtime_types :: sp_arithmetic :: per_things :: Permill , } , } } } pub mod pallet_bounties { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Propose a new bounty."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Payment: `TipReportDepositBase` will be reserved from the origin account, as well as"] # [doc = "`DataDepositPerByte` for each byte in `reason`. It will be unreserved upon approval,"] # [doc = "or slashed when rejected."] # [doc = ""] # [doc = "- `curator`: The curator account whom will manage this bounty."] # [doc = "- `fee`: The curator fee."] # [doc = "- `value`: The total payment amount of this bounty, curator fee included."] # [doc = "- `description`: The description of this bounty."] propose_bounty { # [codec (compact)] value : :: core :: primitive :: u128 , description : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 1)] # [doc = "Approve a bounty proposal. At a later time, the bounty will be funded and become active"] # [doc = "and the original deposit will be returned."] # [doc = ""] # [doc = "May only be called from `T::SpendOrigin`."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] approve_bounty { # [codec (compact)] bounty_id : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "Assign a curator to a funded bounty."] # [doc = ""] # [doc = "May only be called from `T::SpendOrigin`."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] propose_curator { # [codec (compact)] bounty_id : :: core :: primitive :: u32 , curator : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] fee : :: core :: primitive :: u128 , } , # [codec (index = 3)] # [doc = "Unassign curator from a bounty."] # [doc = ""] # [doc = "This function can only be called by the `RejectOrigin` a signed origin."] # [doc = ""] # [doc = "If this function is called by the `RejectOrigin`, we assume that the curator is"] # [doc = "malicious or inactive. As a result, we will slash the curator when possible."] # [doc = ""] # [doc = "If the origin is the curator, we take this as a sign they are unable to do their job and"] # [doc = "they willingly give up. We could slash them, but for now we allow them to recover their"] # [doc = "deposit and exit without issue. (We may want to change this if it is abused.)"] # [doc = ""] # [doc = "Finally, the origin can be anyone if and only if the curator is \"inactive\". This allows"] # [doc = "anyone in the community to call out that a curator is not doing their due diligence, and"] # [doc = "we should pick a new curator. In this case the curator should also be slashed."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] unassign_curator { # [codec (compact)] bounty_id : :: core :: primitive :: u32 , } , # [codec (index = 4)] # [doc = "Accept the curator role for a bounty."] # [doc = "A deposit will be reserved from curator and refund upon successful payout."] # [doc = ""] # [doc = "May only be called from the curator."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] accept_curator { # [codec (compact)] bounty_id : :: core :: primitive :: u32 , } , # [codec (index = 5)] # [doc = "Award bounty to a beneficiary account. The beneficiary will be able to claim the funds"] # [doc = "after a delay."] # [doc = ""] # [doc = "The dispatch origin for this call must be the curator of this bounty."] # [doc = ""] # [doc = "- `bounty_id`: Bounty ID to award."] # [doc = "- `beneficiary`: The beneficiary account whom will receive the payout."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] award_bounty { # [codec (compact)] bounty_id : :: core :: primitive :: u32 , beneficiary : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , } , # [codec (index = 6)] # [doc = "Claim the payout from an awarded bounty after payout delay."] # [doc = ""] # [doc = "The dispatch origin for this call must be the beneficiary of this bounty."] # [doc = ""] # [doc = "- `bounty_id`: Bounty ID to claim."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] claim_bounty { # [codec (compact)] bounty_id : :: core :: primitive :: u32 , } , # [codec (index = 7)] # [doc = "Cancel a proposed or active bounty. All the funds will be sent to treasury and"] # [doc = "the curator deposit will be unreserved if possible."] # [doc = ""] # [doc = "Only `T::RejectOrigin` is able to cancel a bounty."] # [doc = ""] # [doc = "- `bounty_id`: Bounty ID to cancel."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] close_bounty { # [codec (compact)] bounty_id : :: core :: primitive :: u32 , } , # [codec (index = 8)] # [doc = "Extend the expiry time of an active bounty."] # [doc = ""] # [doc = "The dispatch origin for this call must be the curator of this bounty."] # [doc = ""] # [doc = "- `bounty_id`: Bounty ID to extend."] # [doc = "- `remark`: additional information."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] extend_bounty_expiry { # [codec (compact)] bounty_id : :: core :: primitive :: u32 , remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "Proposer's balance is too low."] InsufficientProposersBalance , # [codec (index = 1)] # [doc = "No proposal or bounty at that index."] InvalidIndex , # [codec (index = 2)] # [doc = "The reason given is just too big."] ReasonTooBig , # [codec (index = 3)] # [doc = "The bounty status is unexpected."] UnexpectedStatus , # [codec (index = 4)] # [doc = "Require bounty curator."] RequireCurator , # [codec (index = 5)] # [doc = "Invalid bounty value."] InvalidValue , # [codec (index = 6)] # [doc = "Invalid bounty fee."] InvalidFee , # [codec (index = 7)] # [doc = "A bounty payout is pending."] # [doc = "To cancel the bounty, you must unassign and slash the curator."] PendingPayout , # [codec (index = 8)] # [doc = "The bounties cannot be claimed/closed because it's still in the countdown period."] Premature , # [codec (index = 9)] # [doc = "The bounty cannot be closed because it has active child bounties."] HasActiveChildBounty , # [codec (index = 10)] # [doc = "Too many approvals are already queued."] TooManyQueued , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "New bounty proposal."] BountyProposed { index : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "A bounty proposal was rejected; funds were slashed."] BountyRejected { index : :: core :: primitive :: u32 , bond : :: core :: primitive :: u128 , } , # [codec (index = 2)] # [doc = "A bounty proposal is funded and became active."] BountyBecameActive { index : :: core :: primitive :: u32 , } , # [codec (index = 3)] # [doc = "A bounty is awarded to a beneficiary."] BountyAwarded { index : :: core :: primitive :: u32 , beneficiary : :: subxt :: utils :: AccountId32 , } , # [codec (index = 4)] # [doc = "A bounty is claimed by beneficiary."] BountyClaimed { index : :: core :: primitive :: u32 , payout : :: core :: primitive :: u128 , beneficiary : :: subxt :: utils :: AccountId32 , } , # [codec (index = 5)] # [doc = "A bounty is cancelled."] BountyCanceled { index : :: core :: primitive :: u32 , } , # [codec (index = 6)] # [doc = "A bounty expiry is extended."] BountyExtended { index : :: core :: primitive :: u32 , } , } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Bounty < _0 , _1 , _2 > { pub proposer : _0 , pub value : _1 , pub fee : _1 , pub curator_deposit : _1 , pub bond : _1 , pub status : runtime_types :: pallet_bounties :: BountyStatus < _0 , _2 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum BountyStatus < _0 , _1 > { # [codec (index = 0)] Proposed , # [codec (index = 1)] Approved , # [codec (index = 2)] Funded , # [codec (index = 3)] CuratorProposed { curator : _0 , } , # [codec (index = 4)] Active { curator : _0 , update_due : _1 , } , # [codec (index = 5)] PendingPayout { curator : _0 , beneficiary : _0 , unlock_at : _1 , } , } } pub mod pallet_contracts { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Deprecated version if [`Self::call`] for use in an in-storage `Call`."] call_old_weight { dest : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] value : :: core :: primitive :: u128 , # [codec (compact)] gas_limit : runtime_types :: sp_weights :: OldWeight , storage_deposit_limit : :: core :: option :: Option < :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u128 > > , data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 1)] # [doc = "Deprecated version if [`Self::instantiate_with_code`] for use in an in-storage `Call`."] instantiate_with_code_old_weight { # [codec (compact)] value : :: core :: primitive :: u128 , # [codec (compact)] gas_limit : runtime_types :: sp_weights :: OldWeight , storage_deposit_limit : :: core :: option :: Option < :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u128 > > , code : :: std :: vec :: Vec < :: core :: primitive :: u8 > , data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , salt : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 2)] # [doc = "Deprecated version if [`Self::instantiate`] for use in an in-storage `Call`."] instantiate_old_weight { # [codec (compact)] value : :: core :: primitive :: u128 , # [codec (compact)] gas_limit : runtime_types :: sp_weights :: OldWeight , storage_deposit_limit : :: core :: option :: Option < :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u128 > > , code_hash : :: subxt :: utils :: H256 , data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , salt : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 3)] # [doc = "Upload new `code` without instantiating a contract from it."] # [doc = ""] # [doc = "If the code does not already exist a deposit is reserved from the caller"] # [doc = "and unreserved only when [`Self::remove_code`] is called. The size of the reserve"] # [doc = "depends on the instrumented size of the the supplied `code`."] # [doc = ""] # [doc = "If the code already exists in storage it will still return `Ok` and upgrades"] # [doc = "the in storage version to the current"] # [doc = "[`InstructionWeights::version`](InstructionWeights)."] # [doc = ""] # [doc = "- `determinism`: If this is set to any other value but [`Determinism::Deterministic`]"] # [doc = "  then the only way to use this code is to delegate call into it from an offchain"] # [doc = "  execution. Set to [`Determinism::Deterministic`] if in doubt."] # [doc = ""] # [doc = "# Note"] # [doc = ""] # [doc = "Anyone can instantiate a contract from any uploaded code and thus prevent its removal."] # [doc = "To avoid this situation a constructor could employ access control so that it can"] # [doc = "only be instantiated by permissioned entities. The same is true when uploading"] # [doc = "through [`Self::instantiate_with_code`]."] upload_code { code : :: std :: vec :: Vec < :: core :: primitive :: u8 > , storage_deposit_limit : :: core :: option :: Option < :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u128 > > , determinism : runtime_types :: pallet_contracts :: wasm :: Determinism , } , # [codec (index = 4)] # [doc = "Remove the code stored under `code_hash` and refund the deposit to its owner."] # [doc = ""] # [doc = "A code can only be removed by its original uploader (its owner) and only if it is"] # [doc = "not used by any contract."] remove_code { code_hash : :: subxt :: utils :: H256 , } , # [codec (index = 5)] # [doc = "Privileged function that changes the code of an existing contract."] # [doc = ""] # [doc = "This takes care of updating refcounts and all other necessary operations. Returns"] # [doc = "an error if either the `code_hash` or `dest` do not exist."] # [doc = ""] # [doc = "# Note"] # [doc = ""] # [doc = "This does **not** change the address of the contract in question. This means"] # [doc = "that the contract address is no longer derived from its code hash after calling"] # [doc = "this dispatchable."] set_code { dest : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , code_hash : :: subxt :: utils :: H256 , } , # [codec (index = 6)] # [doc = "Makes a call to an account, optionally transferring some balance."] # [doc = ""] # [doc = "# Parameters"] # [doc = ""] # [doc = "* `dest`: Address of the contract to call."] # [doc = "* `value`: The balance to transfer from the `origin` to `dest`."] # [doc = "* `gas_limit`: The gas limit enforced when executing the constructor."] # [doc = "* `storage_deposit_limit`: The maximum amount of balance that can be charged from the"] # [doc = "  caller to pay for the storage consumed."] # [doc = "* `data`: The input data to pass to the contract."] # [doc = ""] # [doc = "* If the account is a smart-contract account, the associated code will be"] # [doc = "executed and any value will be transferred."] # [doc = "* If the account is a regular account, any value will be transferred."] # [doc = "* If no account exists and the call value is not less than `existential_deposit`,"] # [doc = "a regular account will be created and any value will be transferred."] call { dest : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] value : :: core :: primitive :: u128 , gas_limit : runtime_types :: sp_weights :: weight_v2 :: Weight , storage_deposit_limit : :: core :: option :: Option < :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u128 > > , data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 7)] # [doc = "Instantiates a new contract from the supplied `code` optionally transferring"] # [doc = "some balance."] # [doc = ""] # [doc = "This dispatchable has the same effect as calling [`Self::upload_code`] +"] # [doc = "[`Self::instantiate`]. Bundling them together provides efficiency gains. Please"] # [doc = "also check the documentation of [`Self::upload_code`]."] # [doc = ""] # [doc = "# Parameters"] # [doc = ""] # [doc = "* `value`: The balance to transfer from the `origin` to the newly created contract."] # [doc = "* `gas_limit`: The gas limit enforced when executing the constructor."] # [doc = "* `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved"] # [doc = "  from the caller to pay for the storage consumed."] # [doc = "* `code`: The contract code to deploy in raw bytes."] # [doc = "* `data`: The input data to pass to the contract constructor."] # [doc = "* `salt`: Used for the address derivation. See [`Pallet::contract_address`]."] # [doc = ""] # [doc = "Instantiation is executed as follows:"] # [doc = ""] # [doc = "- The supplied `code` is instrumented, deployed, and a `code_hash` is created for that"] # [doc = "  code."] # [doc = "- If the `code_hash` already exists on the chain the underlying `code` will be shared."] # [doc = "- The destination address is computed based on the sender, code_hash and the salt."] # [doc = "- The smart-contract account is created at the computed address."] # [doc = "- The `value` is transferred to the new account."] # [doc = "- The `deploy` function is executed in the context of the newly-created account."] instantiate_with_code { # [codec (compact)] value : :: core :: primitive :: u128 , gas_limit : runtime_types :: sp_weights :: weight_v2 :: Weight , storage_deposit_limit : :: core :: option :: Option < :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u128 > > , code : :: std :: vec :: Vec < :: core :: primitive :: u8 > , data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , salt : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 8)] # [doc = "Instantiates a contract from a previously deployed wasm binary."] # [doc = ""] # [doc = "This function is identical to [`Self::instantiate_with_code`] but without the"] # [doc = "code deployment step. Instead, the `code_hash` of an on-chain deployed wasm binary"] # [doc = "must be supplied."] instantiate { # [codec (compact)] value : :: core :: primitive :: u128 , gas_limit : runtime_types :: sp_weights :: weight_v2 :: Weight , storage_deposit_limit : :: core :: option :: Option < :: subxt :: ext :: codec :: Compact < :: core :: primitive :: u128 > > , code_hash : :: subxt :: utils :: H256 , data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , salt : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "A new schedule must have a greater version than the current one."] InvalidScheduleVersion , # [codec (index = 1)] # [doc = "Invalid combination of flags supplied to `seal_call` or `seal_delegate_call`."] InvalidCallFlags , # [codec (index = 2)] # [doc = "The executed contract exhausted its gas limit."] OutOfGas , # [codec (index = 3)] # [doc = "The output buffer supplied to a contract API call was too small."] OutputBufferTooSmall , # [codec (index = 4)] # [doc = "Performing the requested transfer failed. Probably because there isn't enough"] # [doc = "free balance in the sender's account."] TransferFailed , # [codec (index = 5)] # [doc = "Performing a call was denied because the calling depth reached the limit"] # [doc = "of what is specified in the schedule."] MaxCallDepthReached , # [codec (index = 6)] # [doc = "No contract was found at the specified address."] ContractNotFound , # [codec (index = 7)] # [doc = "The code supplied to `instantiate_with_code` exceeds the limit specified in the"] # [doc = "current schedule."] CodeTooLarge , # [codec (index = 8)] # [doc = "No code could be found at the supplied code hash."] CodeNotFound , # [codec (index = 9)] # [doc = "A buffer outside of sandbox memory was passed to a contract API function."] OutOfBounds , # [codec (index = 10)] # [doc = "Input passed to a contract API function failed to decode as expected type."] DecodingFailed , # [codec (index = 11)] # [doc = "Contract trapped during execution."] ContractTrapped , # [codec (index = 12)] # [doc = "The size defined in `T::MaxValueSize` was exceeded."] ValueTooLarge , # [codec (index = 13)] # [doc = "Termination of a contract is not allowed while the contract is already"] # [doc = "on the call stack. Can be triggered by `seal_terminate`."] TerminatedWhileReentrant , # [codec (index = 14)] # [doc = "`seal_call` forwarded this contracts input. It therefore is no longer available."] InputForwarded , # [codec (index = 15)] # [doc = "The subject passed to `seal_random` exceeds the limit."] RandomSubjectTooLong , # [codec (index = 16)] # [doc = "The amount of topics passed to `seal_deposit_events` exceeds the limit."] TooManyTopics , # [codec (index = 17)] # [doc = "The chain does not provide a chain extension. Calling the chain extension results"] # [doc = "in this error. Note that this usually  shouldn't happen as deploying such contracts"] # [doc = "is rejected."] NoChainExtension , # [codec (index = 18)] # [doc = "Removal of a contract failed because the deletion queue is full."] # [doc = ""] # [doc = "This can happen when calling `seal_terminate`."] # [doc = "The queue is filled by deleting contracts and emptied by a fixed amount each block."] # [doc = "Trying again during another block is the only way to resolve this issue."] DeletionQueueFull , # [codec (index = 19)] # [doc = "A contract with the same AccountId already exists."] DuplicateContract , # [codec (index = 20)] # [doc = "A contract self destructed in its constructor."] # [doc = ""] # [doc = "This can be triggered by a call to `seal_terminate`."] TerminatedInConstructor , # [codec (index = 21)] # [doc = "A call tried to invoke a contract that is flagged as non-reentrant."] ReentranceDenied , # [codec (index = 22)] # [doc = "Origin doesn't have enough balance to pay the required storage deposits."] StorageDepositNotEnoughFunds , # [codec (index = 23)] # [doc = "More storage was created than allowed by the storage deposit limit."] StorageDepositLimitExhausted , # [codec (index = 24)] # [doc = "Code removal was denied because the code is still in use by at least one contract."] CodeInUse , # [codec (index = 25)] # [doc = "The contract ran to completion but decided to revert its storage changes."] # [doc = "Please note that this error is only returned from extrinsics. When called directly"] # [doc = "or via RPC an `Ok` will be returned. In this case the caller needs to inspect the flags"] # [doc = "to determine whether a reversion has taken place."] ContractReverted , # [codec (index = 26)] # [doc = "The contract's code was found to be invalid during validation or instrumentation."] # [doc = ""] # [doc = "The most likely cause of this is that an API was used which is not supported by the"] # [doc = "node. This hapens if an older node is used with a new version of ink!. Try updating"] # [doc = "your node to the newest available version."] # [doc = ""] # [doc = "A more detailed error can be found on the node console if debug messages are enabled"] # [doc = "by supplying `-lruntime::contracts=debug`."] CodeRejected , # [codec (index = 27)] # [doc = "An indetermistic code was used in a context where this is not permitted."] Indeterministic , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "Contract deployed by address at the specified address."] Instantiated { deployer : :: subxt :: utils :: AccountId32 , contract : :: subxt :: utils :: AccountId32 , } , # [codec (index = 1)] # [doc = "Contract has been removed."] # [doc = ""] # [doc = "# Note"] # [doc = ""] # [doc = "The only way for a contract to be removed and emitting this event is by calling"] # [doc = "`seal_terminate`."] Terminated { contract : :: subxt :: utils :: AccountId32 , beneficiary : :: subxt :: utils :: AccountId32 , } , # [codec (index = 2)] # [doc = "Code with the specified hash has been stored."] CodeStored { code_hash : :: subxt :: utils :: H256 , } , # [codec (index = 3)] # [doc = "A custom event emitted by the contract."] ContractEmitted { contract : :: subxt :: utils :: AccountId32 , data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 4)] # [doc = "A code with the specified hash was removed."] CodeRemoved { code_hash : :: subxt :: utils :: H256 , } , # [codec (index = 5)] # [doc = "A contract's code was updated."] ContractCodeUpdated { contract : :: subxt :: utils :: AccountId32 , new_code_hash : :: subxt :: utils :: H256 , old_code_hash : :: subxt :: utils :: H256 , } , # [codec (index = 6)] # [doc = "A contract was called either by a plain account or another contract."] # [doc = ""] # [doc = "# Note"] # [doc = ""] # [doc = "Please keep in mind that like all events this is only emitted for successful"] # [doc = "calls. This is because on failure all storage changes including events are"] # [doc = "rolled back."] Called { caller : :: subxt :: utils :: AccountId32 , contract : :: subxt :: utils :: AccountId32 , } , # [codec (index = 7)] # [doc = "A contract delegate called a code hash."] # [doc = ""] # [doc = "# Note"] # [doc = ""] # [doc = "Please keep in mind that like all events this is only emitted for successful"] # [doc = "calls. This is because on failure all storage changes including events are"] # [doc = "rolled back."] DelegateCalled { contract : :: subxt :: utils :: AccountId32 , code_hash : :: subxt :: utils :: H256 , } , } } pub mod schedule { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct HostFnWeights { pub caller : runtime_types :: sp_weights :: weight_v2 :: Weight , pub is_contract : runtime_types :: sp_weights :: weight_v2 :: Weight , pub code_hash : runtime_types :: sp_weights :: weight_v2 :: Weight , pub own_code_hash : runtime_types :: sp_weights :: weight_v2 :: Weight , pub caller_is_origin : runtime_types :: sp_weights :: weight_v2 :: Weight , pub address : runtime_types :: sp_weights :: weight_v2 :: Weight , pub gas_left : runtime_types :: sp_weights :: weight_v2 :: Weight , pub balance : runtime_types :: sp_weights :: weight_v2 :: Weight , pub value_transferred : runtime_types :: sp_weights :: weight_v2 :: Weight , pub minimum_balance : runtime_types :: sp_weights :: weight_v2 :: Weight , pub block_number : runtime_types :: sp_weights :: weight_v2 :: Weight , pub now : runtime_types :: sp_weights :: weight_v2 :: Weight , pub weight_to_fee : runtime_types :: sp_weights :: weight_v2 :: Weight , pub gas : runtime_types :: sp_weights :: weight_v2 :: Weight , pub input : runtime_types :: sp_weights :: weight_v2 :: Weight , pub input_per_byte : runtime_types :: sp_weights :: weight_v2 :: Weight , pub r#return : runtime_types :: sp_weights :: weight_v2 :: Weight , pub return_per_byte : runtime_types :: sp_weights :: weight_v2 :: Weight , pub terminate : runtime_types :: sp_weights :: weight_v2 :: Weight , pub random : runtime_types :: sp_weights :: weight_v2 :: Weight , pub deposit_event : runtime_types :: sp_weights :: weight_v2 :: Weight , pub deposit_event_per_topic : runtime_types :: sp_weights :: weight_v2 :: Weight , pub deposit_event_per_byte : runtime_types :: sp_weights :: weight_v2 :: Weight , pub debug_message : runtime_types :: sp_weights :: weight_v2 :: Weight , pub debug_message_per_byte : runtime_types :: sp_weights :: weight_v2 :: Weight , pub set_storage : runtime_types :: sp_weights :: weight_v2 :: Weight , pub set_storage_per_new_byte : runtime_types :: sp_weights :: weight_v2 :: Weight , pub set_storage_per_old_byte : runtime_types :: sp_weights :: weight_v2 :: Weight , pub set_code_hash : runtime_types :: sp_weights :: weight_v2 :: Weight , pub clear_storage : runtime_types :: sp_weights :: weight_v2 :: Weight , pub clear_storage_per_byte : runtime_types :: sp_weights :: weight_v2 :: Weight , pub contains_storage : runtime_types :: sp_weights :: weight_v2 :: Weight , pub contains_storage_per_byte : runtime_types :: sp_weights :: weight_v2 :: Weight , pub get_storage : runtime_types :: sp_weights :: weight_v2 :: Weight , pub get_storage_per_byte : runtime_types :: sp_weights :: weight_v2 :: Weight , pub take_storage : runtime_types :: sp_weights :: weight_v2 :: Weight , pub take_storage_per_byte : runtime_types :: sp_weights :: weight_v2 :: Weight , pub transfer : runtime_types :: sp_weights :: weight_v2 :: Weight , pub call : runtime_types :: sp_weights :: weight_v2 :: Weight , pub delegate_call : runtime_types :: sp_weights :: weight_v2 :: Weight , pub call_transfer_surcharge : runtime_types :: sp_weights :: weight_v2 :: Weight , pub call_per_cloned_byte : runtime_types :: sp_weights :: weight_v2 :: Weight , pub instantiate : runtime_types :: sp_weights :: weight_v2 :: Weight , pub instantiate_transfer_surcharge : runtime_types :: sp_weights :: weight_v2 :: Weight , pub instantiate_per_input_byte : runtime_types :: sp_weights :: weight_v2 :: Weight , pub instantiate_per_salt_byte : runtime_types :: sp_weights :: weight_v2 :: Weight , pub hash_sha2_256 : runtime_types :: sp_weights :: weight_v2 :: Weight , pub hash_sha2_256_per_byte : runtime_types :: sp_weights :: weight_v2 :: Weight , pub hash_keccak_256 : runtime_types :: sp_weights :: weight_v2 :: Weight , pub hash_keccak_256_per_byte : runtime_types :: sp_weights :: weight_v2 :: Weight , pub hash_blake2_256 : runtime_types :: sp_weights :: weight_v2 :: Weight , pub hash_blake2_256_per_byte : runtime_types :: sp_weights :: weight_v2 :: Weight , pub hash_blake2_128 : runtime_types :: sp_weights :: weight_v2 :: Weight , pub hash_blake2_128_per_byte : runtime_types :: sp_weights :: weight_v2 :: Weight , pub ecdsa_recover : runtime_types :: sp_weights :: weight_v2 :: Weight , pub ecdsa_to_eth_address : runtime_types :: sp_weights :: weight_v2 :: Weight , pub reentrance_count : runtime_types :: sp_weights :: weight_v2 :: Weight , pub account_reentrance_count : runtime_types :: sp_weights :: weight_v2 :: Weight , pub instantiation_nonce : runtime_types :: sp_weights :: weight_v2 :: Weight , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct InstructionWeights { pub version : :: core :: primitive :: u32 , pub fallback : :: core :: primitive :: u32 , pub i64const : :: core :: primitive :: u32 , pub i64load : :: core :: primitive :: u32 , pub i64store : :: core :: primitive :: u32 , pub select : :: core :: primitive :: u32 , pub r#if : :: core :: primitive :: u32 , pub br : :: core :: primitive :: u32 , pub br_if : :: core :: primitive :: u32 , pub br_table : :: core :: primitive :: u32 , pub br_table_per_entry : :: core :: primitive :: u32 , pub call : :: core :: primitive :: u32 , pub call_indirect : :: core :: primitive :: u32 , pub call_indirect_per_param : :: core :: primitive :: u32 , pub call_per_local : :: core :: primitive :: u32 , pub local_get : :: core :: primitive :: u32 , pub local_set : :: core :: primitive :: u32 , pub local_tee : :: core :: primitive :: u32 , pub global_get : :: core :: primitive :: u32 , pub global_set : :: core :: primitive :: u32 , pub memory_current : :: core :: primitive :: u32 , pub memory_grow : :: core :: primitive :: u32 , pub i64clz : :: core :: primitive :: u32 , pub i64ctz : :: core :: primitive :: u32 , pub i64popcnt : :: core :: primitive :: u32 , pub i64eqz : :: core :: primitive :: u32 , pub i64extendsi32 : :: core :: primitive :: u32 , pub i64extendui32 : :: core :: primitive :: u32 , pub i32wrapi64 : :: core :: primitive :: u32 , pub i64eq : :: core :: primitive :: u32 , pub i64ne : :: core :: primitive :: u32 , pub i64lts : :: core :: primitive :: u32 , pub i64ltu : :: core :: primitive :: u32 , pub i64gts : :: core :: primitive :: u32 , pub i64gtu : :: core :: primitive :: u32 , pub i64les : :: core :: primitive :: u32 , pub i64leu : :: core :: primitive :: u32 , pub i64ges : :: core :: primitive :: u32 , pub i64geu : :: core :: primitive :: u32 , pub i64add : :: core :: primitive :: u32 , pub i64sub : :: core :: primitive :: u32 , pub i64mul : :: core :: primitive :: u32 , pub i64divs : :: core :: primitive :: u32 , pub i64divu : :: core :: primitive :: u32 , pub i64rems : :: core :: primitive :: u32 , pub i64remu : :: core :: primitive :: u32 , pub i64and : :: core :: primitive :: u32 , pub i64or : :: core :: primitive :: u32 , pub i64xor : :: core :: primitive :: u32 , pub i64shl : :: core :: primitive :: u32 , pub i64shrs : :: core :: primitive :: u32 , pub i64shru : :: core :: primitive :: u32 , pub i64rotl : :: core :: primitive :: u32 , pub i64rotr : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Limits { pub event_topics : :: core :: primitive :: u32 , pub globals : :: core :: primitive :: u32 , pub locals : :: core :: primitive :: u32 , pub parameters : :: core :: primitive :: u32 , pub memory_pages : :: core :: primitive :: u32 , pub table_size : :: core :: primitive :: u32 , pub br_table_size : :: core :: primitive :: u32 , pub subject_len : :: core :: primitive :: u32 , pub payload_len : :: core :: primitive :: u32 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Schedule { pub limits : runtime_types :: pallet_contracts :: schedule :: Limits , pub instruction_weights : runtime_types :: pallet_contracts :: schedule :: InstructionWeights , pub host_fn_weights : runtime_types :: pallet_contracts :: schedule :: HostFnWeights , } } pub mod storage { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct ContractInfo { pub trie_id : runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , pub deposit_account : runtime_types :: pallet_contracts :: storage :: DepositAccount , pub code_hash : :: subxt :: utils :: H256 , pub storage_bytes : :: core :: primitive :: u32 , pub storage_items : :: core :: primitive :: u32 , pub storage_byte_deposit : :: core :: primitive :: u128 , pub storage_item_deposit : :: core :: primitive :: u128 , pub storage_base_deposit : :: core :: primitive :: u128 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct DeletedContract { pub trie_id : runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < :: core :: primitive :: u8 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct DepositAccount (pub :: subxt :: utils :: AccountId32 ,) ; } pub mod wasm { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum Determinism { # [codec (index = 0)] Deterministic , # [codec (index = 1)] AllowIndeterminism , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct OwnerInfo { pub owner : :: subxt :: utils :: AccountId32 , # [codec (compact)] pub deposit : :: core :: primitive :: u128 , # [codec (compact)] pub refcount : :: core :: primitive :: u64 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct PrefabWasmModule { # [codec (compact)] pub instruction_weights_version : :: core :: primitive :: u32 , # [codec (compact)] pub initial : :: core :: primitive :: u32 , # [codec (compact)] pub maximum : :: core :: primitive :: u32 , pub code : runtime_types :: bounded_collections :: weak_bounded_vec :: WeakBoundedVec < :: core :: primitive :: u8 > , pub determinism : runtime_types :: pallet_contracts :: wasm :: Determinism , } } } pub mod pallet_dynamic_fee { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] note_min_gas_price_target { target : runtime_types :: primitive_types :: U256 , } , } } } pub mod pallet_ethereum { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Transact an Ethereum transaction."] transact { transaction : runtime_types :: ethereum :: transaction :: TransactionV2 , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "Signature is invalid."] InvalidSignature , # [codec (index = 1)] # [doc = "Pre-log is present, therefore transact is not allowed."] PreLogExists , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "An ethereum transaction was successfully executed."] Executed { from : :: subxt :: utils :: H160 , to : :: subxt :: utils :: H160 , transaction_hash : :: subxt :: utils :: H256 , exit_reason : runtime_types :: evm_core :: error :: ExitReason , } , } } } pub mod pallet_evm { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Withdraw balance from EVM into currency/balances pallet."] withdraw { address : :: subxt :: utils :: H160 , value : :: core :: primitive :: u128 , } , # [codec (index = 1)] # [doc = "Issue an EVM call operation. This is similar to a message call transaction in Ethereum."] call { source : :: subxt :: utils :: H160 , target : :: subxt :: utils :: H160 , input : :: std :: vec :: Vec < :: core :: primitive :: u8 > , value : runtime_types :: primitive_types :: U256 , gas_limit : :: core :: primitive :: u64 , max_fee_per_gas : runtime_types :: primitive_types :: U256 , max_priority_fee_per_gas : :: core :: option :: Option < runtime_types :: primitive_types :: U256 > , nonce : :: core :: option :: Option < runtime_types :: primitive_types :: U256 > , access_list : :: std :: vec :: Vec < (:: subxt :: utils :: H160 , :: std :: vec :: Vec < :: subxt :: utils :: H256 > ,) > , } , # [codec (index = 2)] # [doc = "Issue an EVM create operation. This is similar to a contract creation transaction in"] # [doc = "Ethereum."] create { source : :: subxt :: utils :: H160 , init : :: std :: vec :: Vec < :: core :: primitive :: u8 > , value : runtime_types :: primitive_types :: U256 , gas_limit : :: core :: primitive :: u64 , max_fee_per_gas : runtime_types :: primitive_types :: U256 , max_priority_fee_per_gas : :: core :: option :: Option < runtime_types :: primitive_types :: U256 > , nonce : :: core :: option :: Option < runtime_types :: primitive_types :: U256 > , access_list : :: std :: vec :: Vec < (:: subxt :: utils :: H160 , :: std :: vec :: Vec < :: subxt :: utils :: H256 > ,) > , } , # [codec (index = 3)] # [doc = "Issue an EVM create2 operation."] create2 { source : :: subxt :: utils :: H160 , init : :: std :: vec :: Vec < :: core :: primitive :: u8 > , salt : :: subxt :: utils :: H256 , value : runtime_types :: primitive_types :: U256 , gas_limit : :: core :: primitive :: u64 , max_fee_per_gas : runtime_types :: primitive_types :: U256 , max_priority_fee_per_gas : :: core :: option :: Option < runtime_types :: primitive_types :: U256 > , nonce : :: core :: option :: Option < runtime_types :: primitive_types :: U256 > , access_list : :: std :: vec :: Vec < (:: subxt :: utils :: H160 , :: std :: vec :: Vec < :: subxt :: utils :: H256 > ,) > , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "Not enough balance to perform action"] BalanceLow , # [codec (index = 1)] # [doc = "Calculating total fee overflowed"] FeeOverflow , # [codec (index = 2)] # [doc = "Calculating total payment overflowed"] PaymentOverflow , # [codec (index = 3)] # [doc = "Withdraw fee failed"] WithdrawFailed , # [codec (index = 4)] # [doc = "Gas price is too low."] GasPriceTooLow , # [codec (index = 5)] # [doc = "Nonce is invalid"] InvalidNonce , # [codec (index = 6)] # [doc = "Gas limit is too low."] GasLimitTooLow , # [codec (index = 7)] # [doc = "Gas limit is too high."] GasLimitTooHigh , # [codec (index = 8)] # [doc = "Undefined error."] Undefined , # [codec (index = 9)] # [doc = "EVM reentrancy"] Reentrancy , # [codec (index = 10)] # [doc = "EIP-3607,"] TransactionMustComeFromEOA , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "Ethereum events from contracts."] Log { log : runtime_types :: ethereum :: log :: Log , } , # [codec (index = 1)] # [doc = "A contract has been created at given address."] Created { address : :: subxt :: utils :: H160 , } , # [codec (index = 2)] # [doc = "A contract was attempted to be created, but the execution failed."] CreatedFailed { address : :: subxt :: utils :: H160 , } , # [codec (index = 3)] # [doc = "A contract has been executed successfully with states applied."] Executed { address : :: subxt :: utils :: H160 , } , # [codec (index = 4)] # [doc = "A contract has been executed with errors. States are reverted with only gas fees applied."] ExecutedFailed { address : :: subxt :: utils :: H160 , } , } } } pub mod pallet_grandpa { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Report voter equivocation/misbehavior. This method will verify the"] # [doc = "equivocation proof and validate the given key ownership proof"] # [doc = "against the extracted offender. If both are valid, the offence"] # [doc = "will be reported."] report_equivocation { equivocation_proof : :: std :: boxed :: Box < runtime_types :: sp_finality_grandpa :: EquivocationProof < :: subxt :: utils :: H256 , :: core :: primitive :: u32 > > , key_owner_proof : runtime_types :: sp_session :: MembershipProof , } , # [codec (index = 1)] # [doc = "Report voter equivocation/misbehavior. This method will verify the"] # [doc = "equivocation proof and validate the given key ownership proof"] # [doc = "against the extracted offender. If both are valid, the offence"] # [doc = "will be reported."] # [doc = ""] # [doc = "This extrinsic must be called unsigned and it is expected that only"] # [doc = "block authors will call it (validated in `ValidateUnsigned`), as such"] # [doc = "if the block author is defined it will be defined as the equivocation"] # [doc = "reporter."] report_equivocation_unsigned { equivocation_proof : :: std :: boxed :: Box < runtime_types :: sp_finality_grandpa :: EquivocationProof < :: subxt :: utils :: H256 , :: core :: primitive :: u32 > > , key_owner_proof : runtime_types :: sp_session :: MembershipProof , } , # [codec (index = 2)] # [doc = "Note that the current authority set of the GRANDPA finality gadget has stalled."] # [doc = ""] # [doc = "This will trigger a forced authority set change at the beginning of the next session, to"] # [doc = "be enacted `delay` blocks after that. The `delay` should be high enough to safely assume"] # [doc = "that the block signalling the forced change will not be re-orged e.g. 1000 blocks."] # [doc = "The block production rate (which may be slowed down because of finality lagging) should"] # [doc = "be taken into account when choosing the `delay`. The GRANDPA voters based on the new"] # [doc = "authority will start voting on top of `best_finalized_block_number` for new finalized"] # [doc = "blocks. `best_finalized_block_number` should be the highest of the latest finalized"] # [doc = "block of all validators of the new authority set."] # [doc = ""] # [doc = "Only callable by root."] note_stalled { delay : :: core :: primitive :: u32 , best_finalized_block_number : :: core :: primitive :: u32 , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "Attempt to signal GRANDPA pause when the authority set isn't live"] # [doc = "(either paused or already pending pause)."] PauseFailed , # [codec (index = 1)] # [doc = "Attempt to signal GRANDPA resume when the authority set isn't paused"] # [doc = "(either live or already pending resume)."] ResumeFailed , # [codec (index = 2)] # [doc = "Attempt to signal GRANDPA change with one already pending."] ChangePending , # [codec (index = 3)] # [doc = "Cannot signal forced change so soon after last."] TooSoon , # [codec (index = 4)] # [doc = "A key ownership proof provided as part of an equivocation report is invalid."] InvalidKeyOwnershipProof , # [codec (index = 5)] # [doc = "An equivocation proof provided as part of an equivocation report is invalid."] InvalidEquivocationProof , # [codec (index = 6)] # [doc = "A given equivocation report is valid but already previously reported."] DuplicateOffenceReport , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "New authority set has been applied."] NewAuthorities { authority_set : :: std :: vec :: Vec < (runtime_types :: sp_finality_grandpa :: app :: Public , :: core :: primitive :: u64 ,) > , } , # [codec (index = 1)] # [doc = "Current authority set has been paused."] Paused , # [codec (index = 2)] # [doc = "Current authority set has been resumed."] Resumed , } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct StoredPendingChange < _0 > { pub scheduled_at : _0 , pub delay : _0 , pub next_authorities : runtime_types :: bounded_collections :: weak_bounded_vec :: WeakBoundedVec < (runtime_types :: sp_finality_grandpa :: app :: Public , :: core :: primitive :: u64 ,) > , pub forced : :: core :: option :: Option < _0 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum StoredState < _0 > { # [codec (index = 0)] Live , # [codec (index = 1)] PendingPause { scheduled_at : _0 , delay : _0 , } , # [codec (index = 2)] Paused , # [codec (index = 3)] PendingResume { scheduled_at : _0 , delay : _0 , } , } } pub mod pallet_hotfix_sufficients { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Increment `sufficients` for existing accounts having a nonzero `nonce` but zero `sufficients`, `consumers` and `providers` value."] # [doc = "This state was caused by a previous bug in EVM create account dispatchable."] # [doc = ""] # [doc = "Any accounts in the input list not satisfying the above condition will remain unaffected."] hotfix_inc_account_sufficients { addresses : :: std :: vec :: Vec < :: subxt :: utils :: H160 > , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "Maximum address count exceeded"] MaxAddressCountExceeded , } } } pub mod pallet_identity { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Identity pallet declaration."] pub enum Call { # [codec (index = 0)] # [doc = "Add a registrar to the system."] # [doc = ""] # [doc = "The dispatch origin for this call must be `T::RegistrarOrigin`."] # [doc = ""] # [doc = "- `account`: the account of the registrar."] # [doc = ""] # [doc = "Emits `RegistrarAdded` if successful."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(R)` where `R` registrar-count (governance-bounded and code-bounded)."] add_registrar { account : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , } , # [codec (index = 1)] # [doc = "Set an account's identity information and reserve the appropriate deposit."] # [doc = ""] # [doc = "If the account already has identity information, the deposit is taken as part payment"] # [doc = "for the new deposit."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `info`: The identity information."] # [doc = ""] # [doc = "Emits `IdentitySet` if successful."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(X + X' + R)`"] # [doc = "  - where `X` additional-field-count (deposit-bounded and code-bounded)"] # [doc = "  - where `R` judgements-count (registrar-count-bounded)"] set_identity { info : :: std :: boxed :: Box < runtime_types :: pallet_identity :: types :: IdentityInfo > , } , # [codec (index = 2)] # [doc = "Set the sub-accounts of the sender."] # [doc = ""] # [doc = "Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned"] # [doc = "and an amount `SubAccountDeposit` will be reserved for each item in `subs`."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a registered"] # [doc = "identity."] # [doc = ""] # [doc = "- `subs`: The identity's (new) sub-accounts."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(P + S)`"] # [doc = "  - where `P` old-subs-count (hard- and deposit-bounded)."] # [doc = "  - where `S` subs-count (hard- and deposit-bounded)."] set_subs { subs : :: std :: vec :: Vec < (:: subxt :: utils :: AccountId32 , runtime_types :: pallet_identity :: types :: Data ,) > , } , # [codec (index = 3)] # [doc = "Clear an account's identity info and all sub-accounts and return all deposits."] # [doc = ""] # [doc = "Payment: All reserved balances on the account are returned."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a registered"] # [doc = "identity."] # [doc = ""] # [doc = "Emits `IdentityCleared` if successful."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(R + S + X)`"] # [doc = "  - where `R` registrar-count (governance-bounded)."] # [doc = "  - where `S` subs-count (hard- and deposit-bounded)."] # [doc = "  - where `X` additional-field-count (deposit-bounded and code-bounded)."] clear_identity , # [codec (index = 4)] # [doc = "Request a judgement from a registrar."] # [doc = ""] # [doc = "Payment: At most `max_fee` will be reserved for payment to the registrar if judgement"] # [doc = "given."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a"] # [doc = "registered identity."] # [doc = ""] # [doc = "- `reg_index`: The index of the registrar whose judgement is requested."] # [doc = "- `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:"] # [doc = ""] # [doc = "```nocompile"] # [doc = "Self::registrars().get(reg_index).unwrap().fee"] # [doc = "```"] # [doc = ""] # [doc = "Emits `JudgementRequested` if successful."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(R + X)`."] # [doc = "  - where `R` registrar-count (governance-bounded)."] # [doc = "  - where `X` additional-field-count (deposit-bounded and code-bounded)."] request_judgement { # [codec (compact)] reg_index : :: core :: primitive :: u32 , # [codec (compact)] max_fee : :: core :: primitive :: u128 , } , # [codec (index = 5)] # [doc = "Cancel a previous request."] # [doc = ""] # [doc = "Payment: A previously reserved deposit is returned on success."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a"] # [doc = "registered identity."] # [doc = ""] # [doc = "- `reg_index`: The index of the registrar whose judgement is no longer requested."] # [doc = ""] # [doc = "Emits `JudgementUnrequested` if successful."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(R + X)`."] # [doc = "  - where `R` registrar-count (governance-bounded)."] # [doc = "  - where `X` additional-field-count (deposit-bounded and code-bounded)."] cancel_request { reg_index : :: core :: primitive :: u32 , } , # [codec (index = 6)] # [doc = "Set the fee required for a judgement to be requested from a registrar."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must be the account"] # [doc = "of the registrar whose index is `index`."] # [doc = ""] # [doc = "- `index`: the index of the registrar whose fee is to be set."] # [doc = "- `fee`: the new fee."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(R)`."] # [doc = "  - where `R` registrar-count (governance-bounded)."] set_fee { # [codec (compact)] index : :: core :: primitive :: u32 , # [codec (compact)] fee : :: core :: primitive :: u128 , } , # [codec (index = 7)] # [doc = "Change the account associated with a registrar."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must be the account"] # [doc = "of the registrar whose index is `index`."] # [doc = ""] # [doc = "- `index`: the index of the registrar whose fee is to be set."] # [doc = "- `new`: the new account ID."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(R)`."] # [doc = "  - where `R` registrar-count (governance-bounded)."] set_account_id { # [codec (compact)] index : :: core :: primitive :: u32 , new : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , } , # [codec (index = 8)] # [doc = "Set the field information for a registrar."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must be the account"] # [doc = "of the registrar whose index is `index`."] # [doc = ""] # [doc = "- `index`: the index of the registrar whose fee is to be set."] # [doc = "- `fields`: the fields that the registrar concerns themselves with."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(R)`."] # [doc = "  - where `R` registrar-count (governance-bounded)."] set_fields { # [codec (compact)] index : :: core :: primitive :: u32 , fields : runtime_types :: pallet_identity :: types :: BitFlags < runtime_types :: pallet_identity :: types :: IdentityField > , } , # [codec (index = 9)] # [doc = "Provide a judgement for an account's identity."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must be the account"] # [doc = "of the registrar whose index is `reg_index`."] # [doc = ""] # [doc = "- `reg_index`: the index of the registrar whose judgement is being made."] # [doc = "- `target`: the account whose identity the judgement is upon. This must be an account"] # [doc = "  with a registered identity."] # [doc = "- `judgement`: the judgement of the registrar of index `reg_index` about `target`."] # [doc = "- `identity`: The hash of the [`IdentityInfo`] for that the judgement is provided."] # [doc = ""] # [doc = "Emits `JudgementGiven` if successful."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(R + X)`."] # [doc = "  - where `R` registrar-count (governance-bounded)."] # [doc = "  - where `X` additional-field-count (deposit-bounded and code-bounded)."] provide_judgement { # [codec (compact)] reg_index : :: core :: primitive :: u32 , target : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , judgement : runtime_types :: pallet_identity :: types :: Judgement < :: core :: primitive :: u128 > , identity : :: subxt :: utils :: H256 , } , # [codec (index = 10)] # [doc = "Remove an account's identity and sub-account information and slash the deposits."] # [doc = ""] # [doc = "Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by"] # [doc = "`Slash`. Verification request deposits are not returned; they should be cancelled"] # [doc = "manually using `cancel_request`."] # [doc = ""] # [doc = "The dispatch origin for this call must match `T::ForceOrigin`."] # [doc = ""] # [doc = "- `target`: the account whose identity the judgement is upon. This must be an account"] # [doc = "  with a registered identity."] # [doc = ""] # [doc = "Emits `IdentityKilled` if successful."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(R + S + X)`"] # [doc = "  - where `R` registrar-count (governance-bounded)."] # [doc = "  - where `S` subs-count (hard- and deposit-bounded)."] # [doc = "  - where `X` additional-field-count (deposit-bounded and code-bounded)."] kill_identity { target : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , } , # [codec (index = 11)] # [doc = "Add the given account to the sender's subs."] # [doc = ""] # [doc = "Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated"] # [doc = "to the sender."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a registered"] # [doc = "sub identity of `sub`."] add_sub { sub : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , data : runtime_types :: pallet_identity :: types :: Data , } , # [codec (index = 12)] # [doc = "Alter the associated name of the given sub-account."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a registered"] # [doc = "sub identity of `sub`."] rename_sub { sub : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , data : runtime_types :: pallet_identity :: types :: Data , } , # [codec (index = 13)] # [doc = "Remove the given account from the sender's subs."] # [doc = ""] # [doc = "Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated"] # [doc = "to the sender."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a registered"] # [doc = "sub identity of `sub`."] remove_sub { sub : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , } , # [codec (index = 14)] # [doc = "Remove the sender as a sub-account."] # [doc = ""] # [doc = "Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated"] # [doc = "to the sender (*not* the original depositor)."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have a registered"] # [doc = "super-identity."] # [doc = ""] # [doc = "NOTE: This should not normally be used, but is provided in the case that the non-"] # [doc = "controller of an account is maliciously registered as a sub-account."] quit_sub , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "Too many subs-accounts."] TooManySubAccounts , # [codec (index = 1)] # [doc = "Account isn't found."] NotFound , # [codec (index = 2)] # [doc = "Account isn't named."] NotNamed , # [codec (index = 3)] # [doc = "Empty index."] EmptyIndex , # [codec (index = 4)] # [doc = "Fee is changed."] FeeChanged , # [codec (index = 5)] # [doc = "No identity found."] NoIdentity , # [codec (index = 6)] # [doc = "Sticky judgement."] StickyJudgement , # [codec (index = 7)] # [doc = "Judgement given."] JudgementGiven , # [codec (index = 8)] # [doc = "Invalid judgement."] InvalidJudgement , # [codec (index = 9)] # [doc = "The index is invalid."] InvalidIndex , # [codec (index = 10)] # [doc = "The target is invalid."] InvalidTarget , # [codec (index = 11)] # [doc = "Too many additional fields."] TooManyFields , # [codec (index = 12)] # [doc = "Maximum amount of registrars reached. Cannot add any more."] TooManyRegistrars , # [codec (index = 13)] # [doc = "Account ID is already named."] AlreadyClaimed , # [codec (index = 14)] # [doc = "Sender is not a sub-account."] NotSub , # [codec (index = 15)] # [doc = "Sub-account isn't owned by sender."] NotOwned , # [codec (index = 16)] # [doc = "The provided judgement was for a different identity."] JudgementForDifferentIdentity , # [codec (index = 17)] # [doc = "Error that occurs when there is an issue paying for judgement."] JudgementPaymentFailed , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "A name was set or reset (which will remove all judgements)."] IdentitySet { who : :: subxt :: utils :: AccountId32 , } , # [codec (index = 1)] # [doc = "A name was cleared, and the given balance returned."] IdentityCleared { who : :: subxt :: utils :: AccountId32 , deposit : :: core :: primitive :: u128 , } , # [codec (index = 2)] # [doc = "A name was removed and the given balance slashed."] IdentityKilled { who : :: subxt :: utils :: AccountId32 , deposit : :: core :: primitive :: u128 , } , # [codec (index = 3)] # [doc = "A judgement was asked from a registrar."] JudgementRequested { who : :: subxt :: utils :: AccountId32 , registrar_index : :: core :: primitive :: u32 , } , # [codec (index = 4)] # [doc = "A judgement request was retracted."] JudgementUnrequested { who : :: subxt :: utils :: AccountId32 , registrar_index : :: core :: primitive :: u32 , } , # [codec (index = 5)] # [doc = "A judgement was given by a registrar."] JudgementGiven { target : :: subxt :: utils :: AccountId32 , registrar_index : :: core :: primitive :: u32 , } , # [codec (index = 6)] # [doc = "A registrar was added."] RegistrarAdded { registrar_index : :: core :: primitive :: u32 , } , # [codec (index = 7)] # [doc = "A sub-identity was added to an identity and the deposit paid."] SubIdentityAdded { sub : :: subxt :: utils :: AccountId32 , main : :: subxt :: utils :: AccountId32 , deposit : :: core :: primitive :: u128 , } , # [codec (index = 8)] # [doc = "A sub-identity was removed from an identity and the deposit freed."] SubIdentityRemoved { sub : :: subxt :: utils :: AccountId32 , main : :: subxt :: utils :: AccountId32 , deposit : :: core :: primitive :: u128 , } , # [codec (index = 9)] # [doc = "A sub-identity was cleared, and the given deposit repatriated from the"] # [doc = "main identity account to the sub-identity account."] SubIdentityRevoked { sub : :: subxt :: utils :: AccountId32 , main : :: subxt :: utils :: AccountId32 , deposit : :: core :: primitive :: u128 , } , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct BitFlags < _0 > (pub :: core :: primitive :: u64 , # [codec (skip)] pub :: core :: marker :: PhantomData < _0 >) ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum Data { # [codec (index = 0)] None , # [codec (index = 1)] Raw0 ([:: core :: primitive :: u8 ; 0usize] ,) , # [codec (index = 2)] Raw1 ([:: core :: primitive :: u8 ; 1usize] ,) , # [codec (index = 3)] Raw2 ([:: core :: primitive :: u8 ; 2usize] ,) , # [codec (index = 4)] Raw3 ([:: core :: primitive :: u8 ; 3usize] ,) , # [codec (index = 5)] Raw4 ([:: core :: primitive :: u8 ; 4usize] ,) , # [codec (index = 6)] Raw5 ([:: core :: primitive :: u8 ; 5usize] ,) , # [codec (index = 7)] Raw6 ([:: core :: primitive :: u8 ; 6usize] ,) , # [codec (index = 8)] Raw7 ([:: core :: primitive :: u8 ; 7usize] ,) , # [codec (index = 9)] Raw8 ([:: core :: primitive :: u8 ; 8usize] ,) , # [codec (index = 10)] Raw9 ([:: core :: primitive :: u8 ; 9usize] ,) , # [codec (index = 11)] Raw10 ([:: core :: primitive :: u8 ; 10usize] ,) , # [codec (index = 12)] Raw11 ([:: core :: primitive :: u8 ; 11usize] ,) , # [codec (index = 13)] Raw12 ([:: core :: primitive :: u8 ; 12usize] ,) , # [codec (index = 14)] Raw13 ([:: core :: primitive :: u8 ; 13usize] ,) , # [codec (index = 15)] Raw14 ([:: core :: primitive :: u8 ; 14usize] ,) , # [codec (index = 16)] Raw15 ([:: core :: primitive :: u8 ; 15usize] ,) , # [codec (index = 17)] Raw16 ([:: core :: primitive :: u8 ; 16usize] ,) , # [codec (index = 18)] Raw17 ([:: core :: primitive :: u8 ; 17usize] ,) , # [codec (index = 19)] Raw18 ([:: core :: primitive :: u8 ; 18usize] ,) , # [codec (index = 20)] Raw19 ([:: core :: primitive :: u8 ; 19usize] ,) , # [codec (index = 21)] Raw20 ([:: core :: primitive :: u8 ; 20usize] ,) , # [codec (index = 22)] Raw21 ([:: core :: primitive :: u8 ; 21usize] ,) , # [codec (index = 23)] Raw22 ([:: core :: primitive :: u8 ; 22usize] ,) , # [codec (index = 24)] Raw23 ([:: core :: primitive :: u8 ; 23usize] ,) , # [codec (index = 25)] Raw24 ([:: core :: primitive :: u8 ; 24usize] ,) , # [codec (index = 26)] Raw25 ([:: core :: primitive :: u8 ; 25usize] ,) , # [codec (index = 27)] Raw26 ([:: core :: primitive :: u8 ; 26usize] ,) , # [codec (index = 28)] Raw27 ([:: core :: primitive :: u8 ; 27usize] ,) , # [codec (index = 29)] Raw28 ([:: core :: primitive :: u8 ; 28usize] ,) , # [codec (index = 30)] Raw29 ([:: core :: primitive :: u8 ; 29usize] ,) , # [codec (index = 31)] Raw30 ([:: core :: primitive :: u8 ; 30usize] ,) , # [codec (index = 32)] Raw31 ([:: core :: primitive :: u8 ; 31usize] ,) , # [codec (index = 33)] Raw32 ([:: core :: primitive :: u8 ; 32usize] ,) , # [codec (index = 34)] BlakeTwo256 ([:: core :: primitive :: u8 ; 32usize] ,) , # [codec (index = 35)] Sha256 ([:: core :: primitive :: u8 ; 32usize] ,) , # [codec (index = 36)] Keccak256 ([:: core :: primitive :: u8 ; 32usize] ,) , # [codec (index = 37)] ShaThree256 ([:: core :: primitive :: u8 ; 32usize] ,) , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum IdentityField { # [codec (index = 1)] Display , # [codec (index = 2)] Legal , # [codec (index = 4)] Web , # [codec (index = 8)] Riot , # [codec (index = 16)] Email , # [codec (index = 32)] PgpFingerprint , # [codec (index = 64)] Image , # [codec (index = 128)] Twitter , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct IdentityInfo { pub additional : runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < (runtime_types :: pallet_identity :: types :: Data , runtime_types :: pallet_identity :: types :: Data ,) > , pub display : runtime_types :: pallet_identity :: types :: Data , pub legal : runtime_types :: pallet_identity :: types :: Data , pub web : runtime_types :: pallet_identity :: types :: Data , pub riot : runtime_types :: pallet_identity :: types :: Data , pub email : runtime_types :: pallet_identity :: types :: Data , pub pgp_fingerprint : :: core :: option :: Option < [:: core :: primitive :: u8 ; 20usize] > , pub image : runtime_types :: pallet_identity :: types :: Data , pub twitter : runtime_types :: pallet_identity :: types :: Data , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum Judgement < _0 > { # [codec (index = 0)] Unknown , # [codec (index = 1)] FeePaid (_0 ,) , # [codec (index = 2)] Reasonable , # [codec (index = 3)] KnownGood , # [codec (index = 4)] OutOfDate , # [codec (index = 5)] LowQuality , # [codec (index = 6)] Erroneous , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct RegistrarInfo < _0 , _1 > { pub account : _1 , pub fee : _0 , pub fields : runtime_types :: pallet_identity :: types :: BitFlags < runtime_types :: pallet_identity :: types :: IdentityField > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Registration < _0 > { pub judgements : runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < (:: core :: primitive :: u32 , runtime_types :: pallet_identity :: types :: Judgement < _0 > ,) > , pub deposit : _0 , pub info : runtime_types :: pallet_identity :: types :: IdentityInfo , } } } pub mod pallet_im_online { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "## Complexity:"] # [doc = "- `O(K + E)` where K is length of `Keys` (heartbeat.validators_len) and E is length of"] # [doc = "  `heartbeat.network_state.external_address`"] # [doc = "  - `O(K)`: decoding of length `K`"] # [doc = "  - `O(E)`: decoding/encoding of length `E`"] heartbeat { heartbeat : runtime_types :: pallet_im_online :: Heartbeat < :: core :: primitive :: u32 > , signature : runtime_types :: pallet_im_online :: sr25519 :: app_sr25519 :: Signature , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "Non existent public key."] InvalidKey , # [codec (index = 1)] # [doc = "Duplicated heartbeat."] DuplicatedHeartbeat , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "A new heartbeat was received from `AuthorityId`."] HeartbeatReceived { authority_id : runtime_types :: pallet_im_online :: sr25519 :: app_sr25519 :: Public , } , # [codec (index = 1)] # [doc = "At the end of the session, no offence was committed."] AllGood , # [codec (index = 2)] # [doc = "At the end of the session, at least one validator was found to be offline."] SomeOffline { offline : :: std :: vec :: Vec < (:: subxt :: utils :: AccountId32 , () ,) > , } , } } pub mod sr25519 { use super :: runtime_types ; pub mod app_sr25519 { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Public (pub runtime_types :: sp_core :: sr25519 :: Public ,) ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Signature (pub runtime_types :: sp_core :: sr25519 :: Signature ,) ; } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct BoundedOpaqueNetworkState { pub peer_id : runtime_types :: bounded_collections :: weak_bounded_vec :: WeakBoundedVec < :: core :: primitive :: u8 > , pub external_addresses : runtime_types :: bounded_collections :: weak_bounded_vec :: WeakBoundedVec < runtime_types :: bounded_collections :: weak_bounded_vec :: WeakBoundedVec < :: core :: primitive :: u8 > > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Heartbeat < _0 > { pub block_number : _0 , pub network_state : runtime_types :: sp_core :: offchain :: OpaqueNetworkState , pub session_index : _0 , pub authority_index : _0 , pub validators_len : _0 , } } pub mod pallet_indices { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Assign an previously unassigned index."] # [doc = ""] # [doc = "Payment: `Deposit` is reserved from the sender account."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `index`: the index to be claimed. This must not be in use."] # [doc = ""] # [doc = "Emits `IndexAssigned` if successful."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)`."] claim { index : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "Assign an index already owned by the sender to another account. The balance reservation"] # [doc = "is effectively transferred to the new account."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `index`: the index to be re-assigned. This must be owned by the sender."] # [doc = "- `new`: the new owner of the index. This function is a no-op if it is equal to sender."] # [doc = ""] # [doc = "Emits `IndexAssigned` if successful."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)`."] transfer { new : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , index : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "Free up an index owned by the sender."] # [doc = ""] # [doc = "Payment: Any previous deposit placed for the index is unreserved in the sender account."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must own the index."] # [doc = ""] # [doc = "- `index`: the index to be freed. This must be owned by the sender."] # [doc = ""] # [doc = "Emits `IndexFreed` if successful."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)`."] free { index : :: core :: primitive :: u32 , } , # [codec (index = 3)] # [doc = "Force an index to an account. This doesn't require a deposit. If the index is already"] # [doc = "held, then any deposit is reimbursed to its current owner."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Root_."] # [doc = ""] # [doc = "- `index`: the index to be (re-)assigned."] # [doc = "- `new`: the new owner of the index. This function is a no-op if it is equal to sender."] # [doc = "- `freeze`: if set to `true`, will freeze the index so it cannot be transferred."] # [doc = ""] # [doc = "Emits `IndexAssigned` if successful."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)`."] force_transfer { new : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , index : :: core :: primitive :: u32 , freeze : :: core :: primitive :: bool , } , # [codec (index = 4)] # [doc = "Freeze an index so it will always point to the sender account. This consumes the"] # [doc = "deposit."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the signing account must have a"] # [doc = "non-frozen account `index`."] # [doc = ""] # [doc = "- `index`: the index to be frozen in place."] # [doc = ""] # [doc = "Emits `IndexFrozen` if successful."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)`."] freeze { index : :: core :: primitive :: u32 , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "The index was not already assigned."] NotAssigned , # [codec (index = 1)] # [doc = "The index is assigned to another account."] NotOwner , # [codec (index = 2)] # [doc = "The index was not available."] InUse , # [codec (index = 3)] # [doc = "The source and destination accounts are identical."] NotTransfer , # [codec (index = 4)] # [doc = "The index is permanent and may not be freed/changed."] Permanent , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "A account index was assigned."] IndexAssigned { who : :: subxt :: utils :: AccountId32 , index : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "A account index has been freed up (unassigned)."] IndexFreed { index : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "A account index has been frozen to its current account ID."] IndexFrozen { index : :: core :: primitive :: u32 , who : :: subxt :: utils :: AccountId32 , } , } } } pub mod pallet_multisig { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Immediately dispatch a multi-signature call using a single approval from the caller."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `other_signatories`: The accounts (other than the sender) who are part of the"] # [doc = "multi-signature, but do not participate in the approval process."] # [doc = "- `call`: The call to be executed."] # [doc = ""] # [doc = "Result is equivalent to the dispatched result."] # [doc = ""] # [doc = "## Complexity"] # [doc = "O(Z + C) where Z is the length of the call and C its execution weight."] as_multi_threshold_1 { other_signatories : :: std :: vec :: Vec < :: subxt :: utils :: AccountId32 > , call : :: std :: boxed :: Box < runtime_types :: golden_gate_runtime_testnet :: RuntimeCall > , } , # [codec (index = 1)] # [doc = "Register approval for a dispatch to be made from a deterministic composite account if"] # [doc = "approved by a total of `threshold - 1` of `other_signatories`."] # [doc = ""] # [doc = "If there are enough, then dispatch the call."] # [doc = ""] # [doc = "Payment: `DepositBase` will be reserved if this is the first approval, plus"] # [doc = "`threshold` times `DepositFactor`. It is returned once this dispatch happens or"] # [doc = "is cancelled."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `threshold`: The total number of approvals for this dispatch before it is executed."] # [doc = "- `other_signatories`: The accounts (other than the sender) who can approve this"] # [doc = "dispatch. May not be empty."] # [doc = "- `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is"] # [doc = "not the first approval, then it must be `Some`, with the timepoint (block number and"] # [doc = "transaction index) of the first approval transaction."] # [doc = "- `call`: The call to be executed."] # [doc = ""] # [doc = "NOTE: Unless this is the final approval, you will generally want to use"] # [doc = "`approve_as_multi` instead, since it only requires a hash of the call."] # [doc = ""] # [doc = "Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise"] # [doc = "on success, result is `Ok` and the result from the interior call, if it was executed,"] # [doc = "may be found in the deposited `MultisigExecuted` event."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(S + Z + Call)`."] # [doc = "- Up to one balance-reserve or unreserve operation."] # [doc = "- One passthrough operation, one insert, both `O(S)` where `S` is the number of"] # [doc = "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional."] # [doc = "- One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len."] # [doc = "- One encode & hash, both of complexity `O(S)`."] # [doc = "- Up to one binary search and insert (`O(logS + S)`)."] # [doc = "- I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove."] # [doc = "- One event."] # [doc = "- The weight of the `call`."] # [doc = "- Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit"] # [doc = "  taken for its lifetime of `DepositBase + threshold * DepositFactor`."] as_multi { threshold : :: core :: primitive :: u16 , other_signatories : :: std :: vec :: Vec < :: subxt :: utils :: AccountId32 > , maybe_timepoint : :: core :: option :: Option < runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > > , call : :: std :: boxed :: Box < runtime_types :: golden_gate_runtime_testnet :: RuntimeCall > , max_weight : runtime_types :: sp_weights :: weight_v2 :: Weight , } , # [codec (index = 2)] # [doc = "Register approval for a dispatch to be made from a deterministic composite account if"] # [doc = "approved by a total of `threshold - 1` of `other_signatories`."] # [doc = ""] # [doc = "Payment: `DepositBase` will be reserved if this is the first approval, plus"] # [doc = "`threshold` times `DepositFactor`. It is returned once this dispatch happens or"] # [doc = "is cancelled."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `threshold`: The total number of approvals for this dispatch before it is executed."] # [doc = "- `other_signatories`: The accounts (other than the sender) who can approve this"] # [doc = "dispatch. May not be empty."] # [doc = "- `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is"] # [doc = "not the first approval, then it must be `Some`, with the timepoint (block number and"] # [doc = "transaction index) of the first approval transaction."] # [doc = "- `call_hash`: The hash of the call to be executed."] # [doc = ""] # [doc = "NOTE: If this is the final approval, you will want to use `as_multi` instead."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(S)`."] # [doc = "- Up to one balance-reserve or unreserve operation."] # [doc = "- One passthrough operation, one insert, both `O(S)` where `S` is the number of"] # [doc = "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional."] # [doc = "- One encode & hash, both of complexity `O(S)`."] # [doc = "- Up to one binary search and insert (`O(logS + S)`)."] # [doc = "- I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove."] # [doc = "- One event."] # [doc = "- Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit"] # [doc = "  taken for its lifetime of `DepositBase + threshold * DepositFactor`."] approve_as_multi { threshold : :: core :: primitive :: u16 , other_signatories : :: std :: vec :: Vec < :: subxt :: utils :: AccountId32 > , maybe_timepoint : :: core :: option :: Option < runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > > , call_hash : [:: core :: primitive :: u8 ; 32usize] , max_weight : runtime_types :: sp_weights :: weight_v2 :: Weight , } , # [codec (index = 3)] # [doc = "Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously"] # [doc = "for this operation will be unreserved on success."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `threshold`: The total number of approvals for this dispatch before it is executed."] # [doc = "- `other_signatories`: The accounts (other than the sender) who can approve this"] # [doc = "dispatch. May not be empty."] # [doc = "- `timepoint`: The timepoint (block number and transaction index) of the first approval"] # [doc = "transaction for this dispatch."] # [doc = "- `call_hash`: The hash of the call to be executed."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(S)`."] # [doc = "- Up to one balance-reserve or unreserve operation."] # [doc = "- One passthrough operation, one insert, both `O(S)` where `S` is the number of"] # [doc = "  signatories. `S` is capped by `MaxSignatories`, with weight being proportional."] # [doc = "- One encode & hash, both of complexity `O(S)`."] # [doc = "- One event."] # [doc = "- I/O: 1 read `O(S)`, one remove."] # [doc = "- Storage: removes one item."] cancel_as_multi { threshold : :: core :: primitive :: u16 , other_signatories : :: std :: vec :: Vec < :: subxt :: utils :: AccountId32 > , timepoint : runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , call_hash : [:: core :: primitive :: u8 ; 32usize] , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "Threshold must be 2 or greater."] MinimumThreshold , # [codec (index = 1)] # [doc = "Call is already approved by this signatory."] AlreadyApproved , # [codec (index = 2)] # [doc = "Call doesn't need any (more) approvals."] NoApprovalsNeeded , # [codec (index = 3)] # [doc = "There are too few signatories in the list."] TooFewSignatories , # [codec (index = 4)] # [doc = "There are too many signatories in the list."] TooManySignatories , # [codec (index = 5)] # [doc = "The signatories were provided out of order; they should be ordered."] SignatoriesOutOfOrder , # [codec (index = 6)] # [doc = "The sender was contained in the other signatories; it shouldn't be."] SenderInSignatories , # [codec (index = 7)] # [doc = "Multisig operation not found when attempting to cancel."] NotFound , # [codec (index = 8)] # [doc = "Only the account that originally created the multisig is able to cancel it."] NotOwner , # [codec (index = 9)] # [doc = "No timepoint was given, yet the multisig operation is already underway."] NoTimepoint , # [codec (index = 10)] # [doc = "A different timepoint was given to the multisig operation that is underway."] WrongTimepoint , # [codec (index = 11)] # [doc = "A timepoint was given, yet no multisig operation is underway."] UnexpectedTimepoint , # [codec (index = 12)] # [doc = "The maximum weight information provided was too low."] MaxWeightTooLow , # [codec (index = 13)] # [doc = "The data to be stored is already stored."] AlreadyStored , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "A new multisig operation has begun."] NewMultisig { approving : :: subxt :: utils :: AccountId32 , multisig : :: subxt :: utils :: AccountId32 , call_hash : [:: core :: primitive :: u8 ; 32usize] , } , # [codec (index = 1)] # [doc = "A multisig operation has been approved by someone."] MultisigApproval { approving : :: subxt :: utils :: AccountId32 , timepoint : runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , multisig : :: subxt :: utils :: AccountId32 , call_hash : [:: core :: primitive :: u8 ; 32usize] , } , # [codec (index = 2)] # [doc = "A multisig operation has been executed."] MultisigExecuted { approving : :: subxt :: utils :: AccountId32 , timepoint : runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , multisig : :: subxt :: utils :: AccountId32 , call_hash : [:: core :: primitive :: u8 ; 32usize] , result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , # [codec (index = 3)] # [doc = "A multisig operation has been cancelled."] MultisigCancelled { cancelling : :: subxt :: utils :: AccountId32 , timepoint : runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , multisig : :: subxt :: utils :: AccountId32 , call_hash : [:: core :: primitive :: u8 ; 32usize] , } , } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Multisig < _0 , _1 , _2 > { pub when : runtime_types :: pallet_multisig :: Timepoint < _0 > , pub deposit : _1 , pub depositor : _2 , pub approvals : runtime_types :: bounded_collections :: bounded_vec :: BoundedVec < _2 > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Timepoint < _0 > { pub height : _0 , pub index : _0 , } } pub mod pallet_offences { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Events type."] pub enum Event { # [codec (index = 0)] # [doc = "There is an offence reported of the given `kind` happened at the `session_index` and"] # [doc = "(kind-specific) time slot. This event is not deposited for duplicate slashes."] # [doc = "\\[kind, timeslot\\]."] Offence { kind : [:: core :: primitive :: u8 ; 16usize] , timeslot : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , } } } pub mod pallet_proxy { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Dispatch the given `call` from an account that the sender is authorised for through"] # [doc = "`add_proxy`."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `real`: The account that the proxy will make a call on behalf of."] # [doc = "- `force_proxy_type`: Specify the exact proxy type to be used and checked for this call."] # [doc = "- `call`: The call to be made by the `real` account."] proxy { real : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , force_proxy_type : :: core :: option :: Option < runtime_types :: golden_gate_runtime_testnet :: poa :: ProxyType > , call : :: std :: boxed :: Box < runtime_types :: golden_gate_runtime_testnet :: RuntimeCall > , } , # [codec (index = 1)] # [doc = "Register a proxy account for the sender that is able to make calls on its behalf."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `proxy`: The account that the `caller` would like to make a proxy."] # [doc = "- `proxy_type`: The permissions allowed for this proxy account."] # [doc = "- `delay`: The announcement period required of the initial proxy. Will generally be"] # [doc = "zero."] add_proxy { delegate : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , proxy_type : runtime_types :: golden_gate_runtime_testnet :: poa :: ProxyType , delay : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "Unregister a proxy account for the sender."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `proxy`: The account that the `caller` would like to remove as a proxy."] # [doc = "- `proxy_type`: The permissions currently enabled for the removed proxy account."] remove_proxy { delegate : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , proxy_type : runtime_types :: golden_gate_runtime_testnet :: poa :: ProxyType , delay : :: core :: primitive :: u32 , } , # [codec (index = 3)] # [doc = "Unregister all proxy accounts for the sender."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "WARNING: This may be called on accounts created by `pure`, however if done, then"] # [doc = "the unreserved fees will be inaccessible. **All access to this account will be lost.**"] remove_proxies , # [codec (index = 4)] # [doc = "Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and"] # [doc = "initialize it with a proxy of `proxy_type` for `origin` sender."] # [doc = ""] # [doc = "Requires a `Signed` origin."] # [doc = ""] # [doc = "- `proxy_type`: The type of the proxy that the sender will be registered as over the"] # [doc = "new account. This will almost always be the most permissive `ProxyType` possible to"] # [doc = "allow for maximum flexibility."] # [doc = "- `index`: A disambiguation index, in case this is called multiple times in the same"] # [doc = "transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just"] # [doc = "want to use `0`."] # [doc = "- `delay`: The announcement period required of the initial proxy. Will generally be"] # [doc = "zero."] # [doc = ""] # [doc = "Fails with `Duplicate` if this has already been called in this transaction, from the"] # [doc = "same sender, with the same parameters."] # [doc = ""] # [doc = "Fails if there are insufficient funds to pay for deposit."] create_pure { proxy_type : runtime_types :: golden_gate_runtime_testnet :: poa :: ProxyType , delay : :: core :: primitive :: u32 , index : :: core :: primitive :: u16 , } , # [codec (index = 5)] # [doc = "Removes a previously spawned pure proxy."] # [doc = ""] # [doc = "WARNING: **All access to this account will be lost.** Any funds held in it will be"] # [doc = "inaccessible."] # [doc = ""] # [doc = "Requires a `Signed` origin, and the sender account must have been created by a call to"] # [doc = "`pure` with corresponding parameters."] # [doc = ""] # [doc = "- `spawner`: The account that originally called `pure` to create this account."] # [doc = "- `index`: The disambiguation index originally passed to `pure`. Probably `0`."] # [doc = "- `proxy_type`: The proxy type originally passed to `pure`."] # [doc = "- `height`: The height of the chain when the call to `pure` was processed."] # [doc = "- `ext_index`: The extrinsic index in which the call to `pure` was processed."] # [doc = ""] # [doc = "Fails with `NoPermission` in case the caller is not a previously created pure"] # [doc = "account whose `pure` call has corresponding parameters."] kill_pure { spawner : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , proxy_type : runtime_types :: golden_gate_runtime_testnet :: poa :: ProxyType , index : :: core :: primitive :: u16 , # [codec (compact)] height : :: core :: primitive :: u32 , # [codec (compact)] ext_index : :: core :: primitive :: u32 , } , # [codec (index = 6)] # [doc = "Publish the hash of a proxy-call that will be made in the future."] # [doc = ""] # [doc = "This must be called some number of blocks before the corresponding `proxy` is attempted"] # [doc = "if the delay associated with the proxy relationship is greater than zero."] # [doc = ""] # [doc = "No more than `MaxPending` announcements may be made at any one time."] # [doc = ""] # [doc = "This will take a deposit of `AnnouncementDepositFactor` as well as"] # [doc = "`AnnouncementDepositBase` if there are no other pending announcements."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and a proxy of `real`."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `real`: The account that the proxy will make a call on behalf of."] # [doc = "- `call_hash`: The hash of the call to be made by the `real` account."] announce { real : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , call_hash : :: subxt :: utils :: H256 , } , # [codec (index = 7)] # [doc = "Remove a given announcement."] # [doc = ""] # [doc = "May be called by a proxy account to remove a call they previously announced and return"] # [doc = "the deposit."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `real`: The account that the proxy will make a call on behalf of."] # [doc = "- `call_hash`: The hash of the call to be made by the `real` account."] remove_announcement { real : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , call_hash : :: subxt :: utils :: H256 , } , # [codec (index = 8)] # [doc = "Remove the given announcement of a delegate."] # [doc = ""] # [doc = "May be called by a target (proxied) account to remove a call that one of their delegates"] # [doc = "(`delegate`) has announced they want to execute. The deposit is returned."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `delegate`: The account that previously announced the call."] # [doc = "- `call_hash`: The hash of the call to be made."] reject_announcement { delegate : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , call_hash : :: subxt :: utils :: H256 , } , # [codec (index = 9)] # [doc = "Dispatch the given `call` from an account that the sender is authorized for through"] # [doc = "`add_proxy`."] # [doc = ""] # [doc = "Removes any corresponding announcement(s)."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "Parameters:"] # [doc = "- `real`: The account that the proxy will make a call on behalf of."] # [doc = "- `force_proxy_type`: Specify the exact proxy type to be used and checked for this call."] # [doc = "- `call`: The call to be made by the `real` account."] proxy_announced { delegate : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , real : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , force_proxy_type : :: core :: option :: Option < runtime_types :: golden_gate_runtime_testnet :: poa :: ProxyType > , call : :: std :: boxed :: Box < runtime_types :: golden_gate_runtime_testnet :: RuntimeCall > , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] # [doc = "There are too many proxies registered or too many announcements pending."] TooMany , # [codec (index = 1)] # [doc = "Proxy registration not found."] NotFound , # [codec (index = 2)] # [doc = "Sender is not a proxy of the account to be proxied."] NotProxy , # [codec (index = 3)] # [doc = "A call which is incompatible with the proxy type's filter was attempted."] Unproxyable , # [codec (index = 4)] # [doc = "Account is already a proxy."] Duplicate , # [codec (index = 5)] # [doc = "Call may not be made by proxy because it may escalate its privileges."] NoPermission , # [codec (index = 6)] # [doc = "Announcement, if made at all, was made too recently."] Unannounced , # [codec (index = 7)] # [doc = "Cannot add self as proxy."] NoSelfProxy , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "A proxy was executed correctly, with the given."] ProxyExecuted { result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , # [codec (index = 1)] # [doc = "A pure account has been created by new proxy with given"] # [doc = "disambiguation index and proxy type."] PureCreated { pure : :: subxt :: utils :: AccountId32 , who : :: subxt :: utils :: AccountId32 , proxy_type : runtime_types :: golden_gate_runtime_testnet :: poa :: ProxyType , disambiguation_index : :: core :: primitive :: u16 , } , # [codec (index = 2)] # [doc = "An announcement was placed to make a call in the future."] Announced { real : :: subxt :: utils :: AccountId32 , proxy : :: subxt :: utils :: AccountId32 , call_hash : :: subxt :: utils :: H256 , } , # [codec (index = 3)] # [doc = "A proxy was added."] ProxyAdded { delegator : :: subxt :: utils :: AccountId32 , delegatee : :: subxt :: utils :: AccountId32 , proxy_type : runtime_types :: golden_gate_runtime_testnet :: poa :: ProxyType , delay : :: core :: primitive :: u32 , } , # [codec (index = 4)] # [doc = "A proxy was removed."] ProxyRemoved { delegator : :: subxt :: utils :: AccountId32 , delegatee : :: subxt :: utils :: AccountId32 , proxy_type : runtime_types :: golden_gate_runtime_testnet :: poa :: ProxyType , delay : :: core :: primitive :: u32 , } , } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Announcement < _0 , _1 , _2 > { pub real : _0 , pub call_hash : _1 , pub height : _2 , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct ProxyDefinition < _0 , _1 , _2 > { pub delegate : _0 , pub proxy_type : _1 , pub delay : _2 , } } pub mod pallet_session { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Sets the session key(s) of the function caller to `keys`."] # [doc = "Allows an account to set its session key prior to becoming a validator."] # [doc = "This doesn't take effect until the next session."] # [doc = ""] # [doc = "The dispatch origin of this function must be signed."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is"] # [doc = "  fixed."] set_keys { keys : runtime_types :: golden_gate_runtime_testnet :: opaque :: SessionKeys , proof : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 1)] # [doc = "Removes any session key(s) of the function caller."] # [doc = ""] # [doc = "This doesn't take effect until the next session."] # [doc = ""] # [doc = "The dispatch origin of this function must be Signed and the account must be either be"] # [doc = "convertible to a validator ID using the chain's typical addressing system (this usually"] # [doc = "means being a controller account) or directly convertible into a validator ID (which"] # [doc = "usually means being a stash account)."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)` in number of key types. Actual cost depends on the number of length of"] # [doc = "  `T::Keys::key_ids()` which is fixed."] purge_keys , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Error for the session pallet."] pub enum Error { # [codec (index = 0)] # [doc = "Invalid ownership proof."] InvalidProof , # [codec (index = 1)] # [doc = "No associated validator ID for account."] NoAssociatedValidatorId , # [codec (index = 2)] # [doc = "Registered duplicate key."] DuplicatedKey , # [codec (index = 3)] # [doc = "No keys are associated with this account."] NoKeys , # [codec (index = 4)] # [doc = "Key setting account is not live, so it's impossible to associate keys."] NoAccount , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "New session has happened. Note that the argument is the session index, not the"] # [doc = "block number as the type might suggest."] NewSession { session_index : :: core :: primitive :: u32 , } , } } } pub mod pallet_sudo { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] sudo { call : :: std :: boxed :: Box < runtime_types :: golden_gate_runtime_testnet :: RuntimeCall > , } , # [codec (index = 1)] # [doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."] # [doc = "This function does not check the weight of the call, and instead allows the"] # [doc = "Sudo user to specify the weight of the call."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] sudo_unchecked_weight { call : :: std :: boxed :: Box < runtime_types :: golden_gate_runtime_testnet :: RuntimeCall > , weight : runtime_types :: sp_weights :: weight_v2 :: Weight , } , # [codec (index = 2)] # [doc = "Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo"] # [doc = "key."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] set_key { new : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , } , # [codec (index = 3)] # [doc = "Authenticates the sudo key and dispatches a function call with `Signed` origin from"] # [doc = "a given account."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)."] sudo_as { who : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , call : :: std :: boxed :: Box < runtime_types :: golden_gate_runtime_testnet :: RuntimeCall > , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Error for the Sudo pallet"] pub enum Error { # [codec (index = 0)] # [doc = "Sender must be the Sudo account"] RequireSudo , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "A sudo just took place. \\[result\\]"] Sudid { sudo_result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , # [codec (index = 1)] # [doc = "The \\[sudoer\\] just switched identity; the old key is supplied if one existed."] KeyChanged { old_sudoer : :: core :: option :: Option < :: subxt :: utils :: AccountId32 > , } , # [codec (index = 2)] # [doc = "A sudo just took place. \\[result\\]"] SudoAsDone { sudo_result : :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > , } , } } } pub mod pallet_timestamp { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Set the current time."] # [doc = ""] # [doc = "This call should be invoked exactly once per block. It will panic at the finalization"] # [doc = "phase, if this call hasn't been invoked by that time."] # [doc = ""] # [doc = "The timestamp should be greater than the previous one by the amount specified by"] # [doc = "`MinimumPeriod`."] # [doc = ""] # [doc = "The dispatch origin for this call must be `Inherent`."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)"] # [doc = "- 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in"] # [doc = "  `on_finalize`)"] # [doc = "- 1 event handler `on_timestamp_set`. Must be `O(1)`."] set { # [codec (compact)] now : :: core :: primitive :: u64 , } , } } } pub mod pallet_transaction_payment { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,"] # [doc = "has been paid by `who`."] TransactionFeePaid { who : :: subxt :: utils :: AccountId32 , actual_fee : :: core :: primitive :: u128 , tip : :: core :: primitive :: u128 , } , } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct ChargeTransactionPayment (# [codec (compact)] pub :: core :: primitive :: u128 ,) ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum Releases { # [codec (index = 0)] V1Ancient , # [codec (index = 1)] V2 , } } pub mod pallet_treasury { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Put forward a suggestion for spending. A deposit proportional to the value"] # [doc = "is reserved and slashed if the proposal is rejected. It is returned once the"] # [doc = "proposal is awarded."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)"] propose_spend { # [codec (compact)] value : :: core :: primitive :: u128 , beneficiary : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , } , # [codec (index = 1)] # [doc = "Reject a proposed spend. The original deposit will be slashed."] # [doc = ""] # [doc = "May only be called from `T::RejectOrigin`."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(1)"] reject_proposal { # [codec (compact)] proposal_id : :: core :: primitive :: u32 , } , # [codec (index = 2)] # [doc = "Approve a proposal. At a later time, the proposal will be allocated to the beneficiary"] # [doc = "and the original deposit will be returned."] # [doc = ""] # [doc = "May only be called from `T::ApproveOrigin`."] # [doc = ""] # [doc = "## Complexity"] # [doc = " - O(1)."] approve_proposal { # [codec (compact)] proposal_id : :: core :: primitive :: u32 , } , # [codec (index = 3)] # [doc = "Propose and approve a spend of treasury funds."] # [doc = ""] # [doc = "- `origin`: Must be `SpendOrigin` with the `Success` value being at least `amount`."] # [doc = "- `amount`: The amount to be transferred from the treasury to the `beneficiary`."] # [doc = "- `beneficiary`: The destination account for the transfer."] # [doc = ""] # [doc = "NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the"] # [doc = "beneficiary."] spend { # [codec (compact)] amount : :: core :: primitive :: u128 , beneficiary : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , } , # [codec (index = 4)] # [doc = "Force a previously approved proposal to be removed from the approval queue."] # [doc = "The original deposit will no longer be returned."] # [doc = ""] # [doc = "May only be called from `T::RejectOrigin`."] # [doc = "- `proposal_id`: The index of a proposal"] # [doc = ""] # [doc = "## Complexity"] # [doc = "- O(A) where `A` is the number of approvals"] # [doc = ""] # [doc = "Errors:"] # [doc = "- `ProposalNotApproved`: The `proposal_id` supplied was not found in the approval queue,"] # [doc = "i.e., the proposal has not been approved. This could also mean the proposal does not"] # [doc = "exist altogether, thus there is no way it would have been approved in the first place."] remove_approval { # [codec (compact)] proposal_id : :: core :: primitive :: u32 , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Error for the treasury pallet."] pub enum Error { # [codec (index = 0)] # [doc = "Proposer's balance is too low."] InsufficientProposersBalance , # [codec (index = 1)] # [doc = "No proposal or bounty at that index."] InvalidIndex , # [codec (index = 2)] # [doc = "Too many approvals in the queue."] TooManyApprovals , # [codec (index = 3)] # [doc = "The spend origin is valid but the amount it is allowed to spend is lower than the"] # [doc = "amount to be spent."] InsufficientPermission , # [codec (index = 4)] # [doc = "Proposal has not been approved."] ProposalNotApproved , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "New proposal."] Proposed { proposal_index : :: core :: primitive :: u32 , } , # [codec (index = 1)] # [doc = "We have ended a spend period and will now allocate funds."] Spending { budget_remaining : :: core :: primitive :: u128 , } , # [codec (index = 2)] # [doc = "Some funds have been allocated."] Awarded { proposal_index : :: core :: primitive :: u32 , award : :: core :: primitive :: u128 , account : :: subxt :: utils :: AccountId32 , } , # [codec (index = 3)] # [doc = "A proposal was rejected; funds were slashed."] Rejected { proposal_index : :: core :: primitive :: u32 , slashed : :: core :: primitive :: u128 , } , # [codec (index = 4)] # [doc = "Some of our funds have been burnt."] Burnt { burnt_funds : :: core :: primitive :: u128 , } , # [codec (index = 5)] # [doc = "Spending has finished; this is the amount that rolls over until next spend."] Rollover { rollover_balance : :: core :: primitive :: u128 , } , # [codec (index = 6)] # [doc = "Some funds have been deposited."] Deposit { value : :: core :: primitive :: u128 , } , # [codec (index = 7)] # [doc = "A new spend proposal has been approved."] SpendApproved { proposal_index : :: core :: primitive :: u32 , amount : :: core :: primitive :: u128 , beneficiary : :: subxt :: utils :: AccountId32 , } , # [codec (index = 8)] # [doc = "The inactive funds of the pallet have been updated."] UpdatedInactive { reactivated : :: core :: primitive :: u128 , deactivated : :: core :: primitive :: u128 , } , } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Proposal < _0 , _1 > { pub proposer : _0 , pub value : _1 , pub beneficiary : _0 , pub bond : _1 , } } pub mod pallet_vesting { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Unlock any vested funds of the sender account."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_ and the sender must have funds still"] # [doc = "locked under this pallet."] # [doc = ""] # [doc = "Emits either `VestingCompleted` or `VestingUpdated`."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)`."] vest , # [codec (index = 1)] # [doc = "Unlock any vested funds of a `target` account."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `target`: The account whose vested funds should be unlocked. Must have funds still"] # [doc = "locked under this pallet."] # [doc = ""] # [doc = "Emits either `VestingCompleted` or `VestingUpdated`."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)`."] vest_other { target : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , } , # [codec (index = 2)] # [doc = "Create a vested transfer."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `target`: The account receiving the vested funds."] # [doc = "- `schedule`: The vesting schedule attached to the transfer."] # [doc = ""] # [doc = "Emits `VestingCreated`."] # [doc = ""] # [doc = "NOTE: This will unlock all schedules through the current block."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)`."] vested_transfer { target : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , schedule : runtime_types :: pallet_vesting :: vesting_info :: VestingInfo < :: core :: primitive :: u128 , :: core :: primitive :: u32 > , } , # [codec (index = 3)] # [doc = "Force a vested transfer."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Root_."] # [doc = ""] # [doc = "- `source`: The account whose funds should be transferred."] # [doc = "- `target`: The account that should be transferred the vested funds."] # [doc = "- `schedule`: The vesting schedule attached to the transfer."] # [doc = ""] # [doc = "Emits `VestingCreated`."] # [doc = ""] # [doc = "NOTE: This will unlock all schedules through the current block."] # [doc = ""] # [doc = "## Complexity"] # [doc = "- `O(1)`."] force_vested_transfer { source : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , target : :: subxt :: utils :: MultiAddress < :: subxt :: utils :: AccountId32 , :: core :: primitive :: u32 > , schedule : runtime_types :: pallet_vesting :: vesting_info :: VestingInfo < :: core :: primitive :: u128 , :: core :: primitive :: u32 > , } , # [codec (index = 4)] # [doc = "Merge two vesting schedules together, creating a new vesting schedule that unlocks over"] # [doc = "the highest possible start and end blocks. If both schedules have already started the"] # [doc = "current block will be used as the schedule start; with the caveat that if one schedule"] # [doc = "is finished by the current block, the other will be treated as the new merged schedule,"] # [doc = "unmodified."] # [doc = ""] # [doc = "NOTE: If `schedule1_index == schedule2_index` this is a no-op."] # [doc = "NOTE: This will unlock all schedules through the current block prior to merging."] # [doc = "NOTE: If both schedules have ended by the current block, no new schedule will be created"] # [doc = "and both will be removed."] # [doc = ""] # [doc = "Merged schedule attributes:"] # [doc = "- `starting_block`: `MAX(schedule1.starting_block, scheduled2.starting_block,"] # [doc = "  current_block)`."] # [doc = "- `ending_block`: `MAX(schedule1.ending_block, schedule2.ending_block)`."] # [doc = "- `locked`: `schedule1.locked_at(current_block) + schedule2.locked_at(current_block)`."] # [doc = ""] # [doc = "The dispatch origin for this call must be _Signed_."] # [doc = ""] # [doc = "- `schedule1_index`: index of the first schedule to merge."] # [doc = "- `schedule2_index`: index of the second schedule to merge."] merge_schedules { schedule1_index : :: core :: primitive :: u32 , schedule2_index : :: core :: primitive :: u32 , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Error for the vesting pallet."] pub enum Error { # [codec (index = 0)] # [doc = "The account given is not vesting."] NotVesting , # [codec (index = 1)] # [doc = "The account already has `MaxVestingSchedules` count of schedules and thus"] # [doc = "cannot add another one. Consider merging existing schedules in order to add another."] AtMaxVestingSchedules , # [codec (index = 2)] # [doc = "Amount being transferred is too low to create a vesting schedule."] AmountLow , # [codec (index = 3)] # [doc = "An index was out of bounds of the vesting schedules."] ScheduleIndexOutOfBounds , # [codec (index = 4)] # [doc = "Failed to create a new schedule because some parameter was invalid."] InvalidScheduleParams , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "The amount vested has been updated. This could indicate a change in funds available."] # [doc = "The balance given is the amount which is left unvested (and thus locked)."] VestingUpdated { account : :: subxt :: utils :: AccountId32 , unvested : :: core :: primitive :: u128 , } , # [codec (index = 1)] # [doc = "An \\[account\\] has become fully vested."] VestingCompleted { account : :: subxt :: utils :: AccountId32 , } , } } pub mod vesting_info { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct VestingInfo < _0 , _1 > { pub locked : _0 , pub per_block : _0 , pub starting_block : _1 , } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum Releases { # [codec (index = 0)] V0 , # [codec (index = 1)] V1 , } } pub mod pallet_xvm { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] xvm_call { context : runtime_types :: pallet_xvm :: XvmContext , to : :: std :: vec :: Vec < :: core :: primitive :: u8 > , input : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 1)] xvm_send { context : runtime_types :: pallet_xvm :: XvmContext , to : :: std :: vec :: Vec < :: core :: primitive :: u8 > , message : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 2)] xvm_query { context : runtime_types :: pallet_xvm :: XvmContext , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] XvmCall { result : :: core :: result :: Result < :: std :: vec :: Vec < :: core :: primitive :: u8 > , runtime_types :: pallet_xvm :: XvmError > , } , # [codec (index = 1)] XvmSend { result : :: core :: result :: Result < :: std :: vec :: Vec < :: core :: primitive :: u8 > , runtime_types :: pallet_xvm :: XvmError > , } , # [codec (index = 2)] XvmQuery { result : :: core :: result :: Result < :: std :: vec :: Vec < :: core :: primitive :: u8 > , runtime_types :: pallet_xvm :: XvmError > , } , } } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct XvmContext { pub id : :: core :: primitive :: u8 , pub max_weight : runtime_types :: sp_weights :: weight_v2 :: Weight , pub env : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum XvmError { # [codec (index = 0)] VmNotRecognized , # [codec (index = 1)] EncodingFailure , # [codec (index = 2)] ContextConversionFailed , # [codec (index = 3)] OutOfGas , # [codec (index = 4)] ExecutionError (:: std :: vec :: Vec < :: core :: primitive :: u8 > ,) , } } pub mod primitive_types { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct U256 (pub [:: core :: primitive :: u64 ; 4usize] ,) ; } pub mod runtime_common { use super :: runtime_types ; pub mod chain_spec { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct RuntimeConfig { pub block_time_in_millis : :: core :: primitive :: u64 , pub session_time_in_seconds : :: core :: primitive :: u64 , } } pub mod validator_manager { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Add new validators to the set."] # [doc = ""] # [doc = "The new validators will be active from current session + 2."] register_validators { validators : :: std :: vec :: Vec < :: subxt :: utils :: AccountId32 > , } , # [codec (index = 1)] # [doc = "Remove validators from the set."] # [doc = ""] # [doc = "The removed validators will be deactivated from current session + 2."] deregister_validators { validators : :: std :: vec :: Vec < :: subxt :: utils :: AccountId32 > , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] # [doc = "New validators were added to the set."] ValidatorsRegistered (:: std :: vec :: Vec < :: subxt :: utils :: AccountId32 > ,) , # [codec (index = 1)] # [doc = "Validators were removed from the set."] ValidatorsDeregistered (:: std :: vec :: Vec < :: subxt :: utils :: AccountId32 > ,) , } } } } pub mod sp_arithmetic { use super :: runtime_types ; pub mod fixed_point { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct FixedU128 (pub :: core :: primitive :: u128 ,) ; } pub mod per_things { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Permill (pub :: core :: primitive :: u32 ,) ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum ArithmeticError { # [codec (index = 0)] Underflow , # [codec (index = 1)] Overflow , # [codec (index = 2)] DivisionByZero , } } pub mod sp_consensus_aura { use super :: runtime_types ; pub mod sr25519 { use super :: runtime_types ; pub mod app_sr25519 { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Public (pub runtime_types :: sp_core :: sr25519 :: Public ,) ; } } } pub mod sp_consensus_slots { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Slot (pub :: core :: primitive :: u64 ,) ; } pub mod sp_core { use super :: runtime_types ; pub mod crypto { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct KeyTypeId (pub [:: core :: primitive :: u8 ; 4usize] ,) ; } pub mod ecdsa { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Signature (pub [:: core :: primitive :: u8 ; 65usize] ,) ; } pub mod ed25519 { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Public (pub [:: core :: primitive :: u8 ; 32usize] ,) ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Signature (pub [:: core :: primitive :: u8 ; 64usize] ,) ; } pub mod offchain { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct OpaqueMultiaddr (pub :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct OpaqueNetworkState { pub peer_id : runtime_types :: sp_core :: OpaquePeerId , pub external_addresses : :: std :: vec :: Vec < runtime_types :: sp_core :: offchain :: OpaqueMultiaddr > , } } pub mod sr25519 { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Public (pub [:: core :: primitive :: u8 ; 32usize] ,) ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Signature (pub [:: core :: primitive :: u8 ; 64usize] ,) ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct OpaquePeerId (pub :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) ; } pub mod sp_finality_grandpa { use super :: runtime_types ; pub mod app { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Public (pub runtime_types :: sp_core :: ed25519 :: Public ,) ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Signature (pub runtime_types :: sp_core :: ed25519 :: Signature ,) ; } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum Equivocation < _0 , _1 > { # [codec (index = 0)] Prevote (runtime_types :: finality_grandpa :: Equivocation < runtime_types :: sp_finality_grandpa :: app :: Public , runtime_types :: finality_grandpa :: Prevote < _0 , _1 > , runtime_types :: sp_finality_grandpa :: app :: Signature > ,) , # [codec (index = 1)] Precommit (runtime_types :: finality_grandpa :: Equivocation < runtime_types :: sp_finality_grandpa :: app :: Public , runtime_types :: finality_grandpa :: Precommit < _0 , _1 > , runtime_types :: sp_finality_grandpa :: app :: Signature > ,) , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct EquivocationProof < _0 , _1 > { pub set_id : :: core :: primitive :: u64 , pub equivocation : runtime_types :: sp_finality_grandpa :: Equivocation < _0 , _1 > , } } pub mod sp_runtime { use super :: runtime_types ; pub mod generic { use super :: runtime_types ; pub mod digest { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Digest { pub logs : :: std :: vec :: Vec < runtime_types :: sp_runtime :: generic :: digest :: DigestItem > , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum DigestItem { # [codec (index = 6)] PreRuntime ([:: core :: primitive :: u8 ; 4usize] , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) , # [codec (index = 4)] Consensus ([:: core :: primitive :: u8 ; 4usize] , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) , # [codec (index = 5)] Seal ([:: core :: primitive :: u8 ; 4usize] , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) , # [codec (index = 0)] Other (:: std :: vec :: Vec < :: core :: primitive :: u8 > ,) , # [codec (index = 8)] RuntimeEnvironmentUpdated , } } pub mod era { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum Era { # [codec (index = 0)] Immortal , # [codec (index = 1)] Mortal1 (:: core :: primitive :: u8 ,) , # [codec (index = 2)] Mortal2 (:: core :: primitive :: u8 ,) , # [codec (index = 3)] Mortal3 (:: core :: primitive :: u8 ,) , # [codec (index = 4)] Mortal4 (:: core :: primitive :: u8 ,) , # [codec (index = 5)] Mortal5 (:: core :: primitive :: u8 ,) , # [codec (index = 6)] Mortal6 (:: core :: primitive :: u8 ,) , # [codec (index = 7)] Mortal7 (:: core :: primitive :: u8 ,) , # [codec (index = 8)] Mortal8 (:: core :: primitive :: u8 ,) , # [codec (index = 9)] Mortal9 (:: core :: primitive :: u8 ,) , # [codec (index = 10)] Mortal10 (:: core :: primitive :: u8 ,) , # [codec (index = 11)] Mortal11 (:: core :: primitive :: u8 ,) , # [codec (index = 12)] Mortal12 (:: core :: primitive :: u8 ,) , # [codec (index = 13)] Mortal13 (:: core :: primitive :: u8 ,) , # [codec (index = 14)] Mortal14 (:: core :: primitive :: u8 ,) , # [codec (index = 15)] Mortal15 (:: core :: primitive :: u8 ,) , # [codec (index = 16)] Mortal16 (:: core :: primitive :: u8 ,) , # [codec (index = 17)] Mortal17 (:: core :: primitive :: u8 ,) , # [codec (index = 18)] Mortal18 (:: core :: primitive :: u8 ,) , # [codec (index = 19)] Mortal19 (:: core :: primitive :: u8 ,) , # [codec (index = 20)] Mortal20 (:: core :: primitive :: u8 ,) , # [codec (index = 21)] Mortal21 (:: core :: primitive :: u8 ,) , # [codec (index = 22)] Mortal22 (:: core :: primitive :: u8 ,) , # [codec (index = 23)] Mortal23 (:: core :: primitive :: u8 ,) , # [codec (index = 24)] Mortal24 (:: core :: primitive :: u8 ,) , # [codec (index = 25)] Mortal25 (:: core :: primitive :: u8 ,) , # [codec (index = 26)] Mortal26 (:: core :: primitive :: u8 ,) , # [codec (index = 27)] Mortal27 (:: core :: primitive :: u8 ,) , # [codec (index = 28)] Mortal28 (:: core :: primitive :: u8 ,) , # [codec (index = 29)] Mortal29 (:: core :: primitive :: u8 ,) , # [codec (index = 30)] Mortal30 (:: core :: primitive :: u8 ,) , # [codec (index = 31)] Mortal31 (:: core :: primitive :: u8 ,) , # [codec (index = 32)] Mortal32 (:: core :: primitive :: u8 ,) , # [codec (index = 33)] Mortal33 (:: core :: primitive :: u8 ,) , # [codec (index = 34)] Mortal34 (:: core :: primitive :: u8 ,) , # [codec (index = 35)] Mortal35 (:: core :: primitive :: u8 ,) , # [codec (index = 36)] Mortal36 (:: core :: primitive :: u8 ,) , # [codec (index = 37)] Mortal37 (:: core :: primitive :: u8 ,) , # [codec (index = 38)] Mortal38 (:: core :: primitive :: u8 ,) , # [codec (index = 39)] Mortal39 (:: core :: primitive :: u8 ,) , # [codec (index = 40)] Mortal40 (:: core :: primitive :: u8 ,) , # [codec (index = 41)] Mortal41 (:: core :: primitive :: u8 ,) , # [codec (index = 42)] Mortal42 (:: core :: primitive :: u8 ,) , # [codec (index = 43)] Mortal43 (:: core :: primitive :: u8 ,) , # [codec (index = 44)] Mortal44 (:: core :: primitive :: u8 ,) , # [codec (index = 45)] Mortal45 (:: core :: primitive :: u8 ,) , # [codec (index = 46)] Mortal46 (:: core :: primitive :: u8 ,) , # [codec (index = 47)] Mortal47 (:: core :: primitive :: u8 ,) , # [codec (index = 48)] Mortal48 (:: core :: primitive :: u8 ,) , # [codec (index = 49)] Mortal49 (:: core :: primitive :: u8 ,) , # [codec (index = 50)] Mortal50 (:: core :: primitive :: u8 ,) , # [codec (index = 51)] Mortal51 (:: core :: primitive :: u8 ,) , # [codec (index = 52)] Mortal52 (:: core :: primitive :: u8 ,) , # [codec (index = 53)] Mortal53 (:: core :: primitive :: u8 ,) , # [codec (index = 54)] Mortal54 (:: core :: primitive :: u8 ,) , # [codec (index = 55)] Mortal55 (:: core :: primitive :: u8 ,) , # [codec (index = 56)] Mortal56 (:: core :: primitive :: u8 ,) , # [codec (index = 57)] Mortal57 (:: core :: primitive :: u8 ,) , # [codec (index = 58)] Mortal58 (:: core :: primitive :: u8 ,) , # [codec (index = 59)] Mortal59 (:: core :: primitive :: u8 ,) , # [codec (index = 60)] Mortal60 (:: core :: primitive :: u8 ,) , # [codec (index = 61)] Mortal61 (:: core :: primitive :: u8 ,) , # [codec (index = 62)] Mortal62 (:: core :: primitive :: u8 ,) , # [codec (index = 63)] Mortal63 (:: core :: primitive :: u8 ,) , # [codec (index = 64)] Mortal64 (:: core :: primitive :: u8 ,) , # [codec (index = 65)] Mortal65 (:: core :: primitive :: u8 ,) , # [codec (index = 66)] Mortal66 (:: core :: primitive :: u8 ,) , # [codec (index = 67)] Mortal67 (:: core :: primitive :: u8 ,) , # [codec (index = 68)] Mortal68 (:: core :: primitive :: u8 ,) , # [codec (index = 69)] Mortal69 (:: core :: primitive :: u8 ,) , # [codec (index = 70)] Mortal70 (:: core :: primitive :: u8 ,) , # [codec (index = 71)] Mortal71 (:: core :: primitive :: u8 ,) , # [codec (index = 72)] Mortal72 (:: core :: primitive :: u8 ,) , # [codec (index = 73)] Mortal73 (:: core :: primitive :: u8 ,) , # [codec (index = 74)] Mortal74 (:: core :: primitive :: u8 ,) , # [codec (index = 75)] Mortal75 (:: core :: primitive :: u8 ,) , # [codec (index = 76)] Mortal76 (:: core :: primitive :: u8 ,) , # [codec (index = 77)] Mortal77 (:: core :: primitive :: u8 ,) , # [codec (index = 78)] Mortal78 (:: core :: primitive :: u8 ,) , # [codec (index = 79)] Mortal79 (:: core :: primitive :: u8 ,) , # [codec (index = 80)] Mortal80 (:: core :: primitive :: u8 ,) , # [codec (index = 81)] Mortal81 (:: core :: primitive :: u8 ,) , # [codec (index = 82)] Mortal82 (:: core :: primitive :: u8 ,) , # [codec (index = 83)] Mortal83 (:: core :: primitive :: u8 ,) , # [codec (index = 84)] Mortal84 (:: core :: primitive :: u8 ,) , # [codec (index = 85)] Mortal85 (:: core :: primitive :: u8 ,) , # [codec (index = 86)] Mortal86 (:: core :: primitive :: u8 ,) , # [codec (index = 87)] Mortal87 (:: core :: primitive :: u8 ,) , # [codec (index = 88)] Mortal88 (:: core :: primitive :: u8 ,) , # [codec (index = 89)] Mortal89 (:: core :: primitive :: u8 ,) , # [codec (index = 90)] Mortal90 (:: core :: primitive :: u8 ,) , # [codec (index = 91)] Mortal91 (:: core :: primitive :: u8 ,) , # [codec (index = 92)] Mortal92 (:: core :: primitive :: u8 ,) , # [codec (index = 93)] Mortal93 (:: core :: primitive :: u8 ,) , # [codec (index = 94)] Mortal94 (:: core :: primitive :: u8 ,) , # [codec (index = 95)] Mortal95 (:: core :: primitive :: u8 ,) , # [codec (index = 96)] Mortal96 (:: core :: primitive :: u8 ,) , # [codec (index = 97)] Mortal97 (:: core :: primitive :: u8 ,) , # [codec (index = 98)] Mortal98 (:: core :: primitive :: u8 ,) , # [codec (index = 99)] Mortal99 (:: core :: primitive :: u8 ,) , # [codec (index = 100)] Mortal100 (:: core :: primitive :: u8 ,) , # [codec (index = 101)] Mortal101 (:: core :: primitive :: u8 ,) , # [codec (index = 102)] Mortal102 (:: core :: primitive :: u8 ,) , # [codec (index = 103)] Mortal103 (:: core :: primitive :: u8 ,) , # [codec (index = 104)] Mortal104 (:: core :: primitive :: u8 ,) , # [codec (index = 105)] Mortal105 (:: core :: primitive :: u8 ,) , # [codec (index = 106)] Mortal106 (:: core :: primitive :: u8 ,) , # [codec (index = 107)] Mortal107 (:: core :: primitive :: u8 ,) , # [codec (index = 108)] Mortal108 (:: core :: primitive :: u8 ,) , # [codec (index = 109)] Mortal109 (:: core :: primitive :: u8 ,) , # [codec (index = 110)] Mortal110 (:: core :: primitive :: u8 ,) , # [codec (index = 111)] Mortal111 (:: core :: primitive :: u8 ,) , # [codec (index = 112)] Mortal112 (:: core :: primitive :: u8 ,) , # [codec (index = 113)] Mortal113 (:: core :: primitive :: u8 ,) , # [codec (index = 114)] Mortal114 (:: core :: primitive :: u8 ,) , # [codec (index = 115)] Mortal115 (:: core :: primitive :: u8 ,) , # [codec (index = 116)] Mortal116 (:: core :: primitive :: u8 ,) , # [codec (index = 117)] Mortal117 (:: core :: primitive :: u8 ,) , # [codec (index = 118)] Mortal118 (:: core :: primitive :: u8 ,) , # [codec (index = 119)] Mortal119 (:: core :: primitive :: u8 ,) , # [codec (index = 120)] Mortal120 (:: core :: primitive :: u8 ,) , # [codec (index = 121)] Mortal121 (:: core :: primitive :: u8 ,) , # [codec (index = 122)] Mortal122 (:: core :: primitive :: u8 ,) , # [codec (index = 123)] Mortal123 (:: core :: primitive :: u8 ,) , # [codec (index = 124)] Mortal124 (:: core :: primitive :: u8 ,) , # [codec (index = 125)] Mortal125 (:: core :: primitive :: u8 ,) , # [codec (index = 126)] Mortal126 (:: core :: primitive :: u8 ,) , # [codec (index = 127)] Mortal127 (:: core :: primitive :: u8 ,) , # [codec (index = 128)] Mortal128 (:: core :: primitive :: u8 ,) , # [codec (index = 129)] Mortal129 (:: core :: primitive :: u8 ,) , # [codec (index = 130)] Mortal130 (:: core :: primitive :: u8 ,) , # [codec (index = 131)] Mortal131 (:: core :: primitive :: u8 ,) , # [codec (index = 132)] Mortal132 (:: core :: primitive :: u8 ,) , # [codec (index = 133)] Mortal133 (:: core :: primitive :: u8 ,) , # [codec (index = 134)] Mortal134 (:: core :: primitive :: u8 ,) , # [codec (index = 135)] Mortal135 (:: core :: primitive :: u8 ,) , # [codec (index = 136)] Mortal136 (:: core :: primitive :: u8 ,) , # [codec (index = 137)] Mortal137 (:: core :: primitive :: u8 ,) , # [codec (index = 138)] Mortal138 (:: core :: primitive :: u8 ,) , # [codec (index = 139)] Mortal139 (:: core :: primitive :: u8 ,) , # [codec (index = 140)] Mortal140 (:: core :: primitive :: u8 ,) , # [codec (index = 141)] Mortal141 (:: core :: primitive :: u8 ,) , # [codec (index = 142)] Mortal142 (:: core :: primitive :: u8 ,) , # [codec (index = 143)] Mortal143 (:: core :: primitive :: u8 ,) , # [codec (index = 144)] Mortal144 (:: core :: primitive :: u8 ,) , # [codec (index = 145)] Mortal145 (:: core :: primitive :: u8 ,) , # [codec (index = 146)] Mortal146 (:: core :: primitive :: u8 ,) , # [codec (index = 147)] Mortal147 (:: core :: primitive :: u8 ,) , # [codec (index = 148)] Mortal148 (:: core :: primitive :: u8 ,) , # [codec (index = 149)] Mortal149 (:: core :: primitive :: u8 ,) , # [codec (index = 150)] Mortal150 (:: core :: primitive :: u8 ,) , # [codec (index = 151)] Mortal151 (:: core :: primitive :: u8 ,) , # [codec (index = 152)] Mortal152 (:: core :: primitive :: u8 ,) , # [codec (index = 153)] Mortal153 (:: core :: primitive :: u8 ,) , # [codec (index = 154)] Mortal154 (:: core :: primitive :: u8 ,) , # [codec (index = 155)] Mortal155 (:: core :: primitive :: u8 ,) , # [codec (index = 156)] Mortal156 (:: core :: primitive :: u8 ,) , # [codec (index = 157)] Mortal157 (:: core :: primitive :: u8 ,) , # [codec (index = 158)] Mortal158 (:: core :: primitive :: u8 ,) , # [codec (index = 159)] Mortal159 (:: core :: primitive :: u8 ,) , # [codec (index = 160)] Mortal160 (:: core :: primitive :: u8 ,) , # [codec (index = 161)] Mortal161 (:: core :: primitive :: u8 ,) , # [codec (index = 162)] Mortal162 (:: core :: primitive :: u8 ,) , # [codec (index = 163)] Mortal163 (:: core :: primitive :: u8 ,) , # [codec (index = 164)] Mortal164 (:: core :: primitive :: u8 ,) , # [codec (index = 165)] Mortal165 (:: core :: primitive :: u8 ,) , # [codec (index = 166)] Mortal166 (:: core :: primitive :: u8 ,) , # [codec (index = 167)] Mortal167 (:: core :: primitive :: u8 ,) , # [codec (index = 168)] Mortal168 (:: core :: primitive :: u8 ,) , # [codec (index = 169)] Mortal169 (:: core :: primitive :: u8 ,) , # [codec (index = 170)] Mortal170 (:: core :: primitive :: u8 ,) , # [codec (index = 171)] Mortal171 (:: core :: primitive :: u8 ,) , # [codec (index = 172)] Mortal172 (:: core :: primitive :: u8 ,) , # [codec (index = 173)] Mortal173 (:: core :: primitive :: u8 ,) , # [codec (index = 174)] Mortal174 (:: core :: primitive :: u8 ,) , # [codec (index = 175)] Mortal175 (:: core :: primitive :: u8 ,) , # [codec (index = 176)] Mortal176 (:: core :: primitive :: u8 ,) , # [codec (index = 177)] Mortal177 (:: core :: primitive :: u8 ,) , # [codec (index = 178)] Mortal178 (:: core :: primitive :: u8 ,) , # [codec (index = 179)] Mortal179 (:: core :: primitive :: u8 ,) , # [codec (index = 180)] Mortal180 (:: core :: primitive :: u8 ,) , # [codec (index = 181)] Mortal181 (:: core :: primitive :: u8 ,) , # [codec (index = 182)] Mortal182 (:: core :: primitive :: u8 ,) , # [codec (index = 183)] Mortal183 (:: core :: primitive :: u8 ,) , # [codec (index = 184)] Mortal184 (:: core :: primitive :: u8 ,) , # [codec (index = 185)] Mortal185 (:: core :: primitive :: u8 ,) , # [codec (index = 186)] Mortal186 (:: core :: primitive :: u8 ,) , # [codec (index = 187)] Mortal187 (:: core :: primitive :: u8 ,) , # [codec (index = 188)] Mortal188 (:: core :: primitive :: u8 ,) , # [codec (index = 189)] Mortal189 (:: core :: primitive :: u8 ,) , # [codec (index = 190)] Mortal190 (:: core :: primitive :: u8 ,) , # [codec (index = 191)] Mortal191 (:: core :: primitive :: u8 ,) , # [codec (index = 192)] Mortal192 (:: core :: primitive :: u8 ,) , # [codec (index = 193)] Mortal193 (:: core :: primitive :: u8 ,) , # [codec (index = 194)] Mortal194 (:: core :: primitive :: u8 ,) , # [codec (index = 195)] Mortal195 (:: core :: primitive :: u8 ,) , # [codec (index = 196)] Mortal196 (:: core :: primitive :: u8 ,) , # [codec (index = 197)] Mortal197 (:: core :: primitive :: u8 ,) , # [codec (index = 198)] Mortal198 (:: core :: primitive :: u8 ,) , # [codec (index = 199)] Mortal199 (:: core :: primitive :: u8 ,) , # [codec (index = 200)] Mortal200 (:: core :: primitive :: u8 ,) , # [codec (index = 201)] Mortal201 (:: core :: primitive :: u8 ,) , # [codec (index = 202)] Mortal202 (:: core :: primitive :: u8 ,) , # [codec (index = 203)] Mortal203 (:: core :: primitive :: u8 ,) , # [codec (index = 204)] Mortal204 (:: core :: primitive :: u8 ,) , # [codec (index = 205)] Mortal205 (:: core :: primitive :: u8 ,) , # [codec (index = 206)] Mortal206 (:: core :: primitive :: u8 ,) , # [codec (index = 207)] Mortal207 (:: core :: primitive :: u8 ,) , # [codec (index = 208)] Mortal208 (:: core :: primitive :: u8 ,) , # [codec (index = 209)] Mortal209 (:: core :: primitive :: u8 ,) , # [codec (index = 210)] Mortal210 (:: core :: primitive :: u8 ,) , # [codec (index = 211)] Mortal211 (:: core :: primitive :: u8 ,) , # [codec (index = 212)] Mortal212 (:: core :: primitive :: u8 ,) , # [codec (index = 213)] Mortal213 (:: core :: primitive :: u8 ,) , # [codec (index = 214)] Mortal214 (:: core :: primitive :: u8 ,) , # [codec (index = 215)] Mortal215 (:: core :: primitive :: u8 ,) , # [codec (index = 216)] Mortal216 (:: core :: primitive :: u8 ,) , # [codec (index = 217)] Mortal217 (:: core :: primitive :: u8 ,) , # [codec (index = 218)] Mortal218 (:: core :: primitive :: u8 ,) , # [codec (index = 219)] Mortal219 (:: core :: primitive :: u8 ,) , # [codec (index = 220)] Mortal220 (:: core :: primitive :: u8 ,) , # [codec (index = 221)] Mortal221 (:: core :: primitive :: u8 ,) , # [codec (index = 222)] Mortal222 (:: core :: primitive :: u8 ,) , # [codec (index = 223)] Mortal223 (:: core :: primitive :: u8 ,) , # [codec (index = 224)] Mortal224 (:: core :: primitive :: u8 ,) , # [codec (index = 225)] Mortal225 (:: core :: primitive :: u8 ,) , # [codec (index = 226)] Mortal226 (:: core :: primitive :: u8 ,) , # [codec (index = 227)] Mortal227 (:: core :: primitive :: u8 ,) , # [codec (index = 228)] Mortal228 (:: core :: primitive :: u8 ,) , # [codec (index = 229)] Mortal229 (:: core :: primitive :: u8 ,) , # [codec (index = 230)] Mortal230 (:: core :: primitive :: u8 ,) , # [codec (index = 231)] Mortal231 (:: core :: primitive :: u8 ,) , # [codec (index = 232)] Mortal232 (:: core :: primitive :: u8 ,) , # [codec (index = 233)] Mortal233 (:: core :: primitive :: u8 ,) , # [codec (index = 234)] Mortal234 (:: core :: primitive :: u8 ,) , # [codec (index = 235)] Mortal235 (:: core :: primitive :: u8 ,) , # [codec (index = 236)] Mortal236 (:: core :: primitive :: u8 ,) , # [codec (index = 237)] Mortal237 (:: core :: primitive :: u8 ,) , # [codec (index = 238)] Mortal238 (:: core :: primitive :: u8 ,) , # [codec (index = 239)] Mortal239 (:: core :: primitive :: u8 ,) , # [codec (index = 240)] Mortal240 (:: core :: primitive :: u8 ,) , # [codec (index = 241)] Mortal241 (:: core :: primitive :: u8 ,) , # [codec (index = 242)] Mortal242 (:: core :: primitive :: u8 ,) , # [codec (index = 243)] Mortal243 (:: core :: primitive :: u8 ,) , # [codec (index = 244)] Mortal244 (:: core :: primitive :: u8 ,) , # [codec (index = 245)] Mortal245 (:: core :: primitive :: u8 ,) , # [codec (index = 246)] Mortal246 (:: core :: primitive :: u8 ,) , # [codec (index = 247)] Mortal247 (:: core :: primitive :: u8 ,) , # [codec (index = 248)] Mortal248 (:: core :: primitive :: u8 ,) , # [codec (index = 249)] Mortal249 (:: core :: primitive :: u8 ,) , # [codec (index = 250)] Mortal250 (:: core :: primitive :: u8 ,) , # [codec (index = 251)] Mortal251 (:: core :: primitive :: u8 ,) , # [codec (index = 252)] Mortal252 (:: core :: primitive :: u8 ,) , # [codec (index = 253)] Mortal253 (:: core :: primitive :: u8 ,) , # [codec (index = 254)] Mortal254 (:: core :: primitive :: u8 ,) , # [codec (index = 255)] Mortal255 (:: core :: primitive :: u8 ,) , } } pub mod unchecked_extrinsic { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct UncheckedExtrinsic < _0 , _1 , _2 , _3 > (pub :: std :: vec :: Vec < :: core :: primitive :: u8 > , # [codec (skip)] pub :: core :: marker :: PhantomData < (_0 , _1 , _2 , _3) >) ; } } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum DispatchError { # [codec (index = 0)] Other , # [codec (index = 1)] CannotLookup , # [codec (index = 2)] BadOrigin , # [codec (index = 3)] Module (runtime_types :: sp_runtime :: ModuleError ,) , # [codec (index = 4)] ConsumerRemaining , # [codec (index = 5)] NoProviders , # [codec (index = 6)] TooManyConsumers , # [codec (index = 7)] Token (runtime_types :: sp_runtime :: TokenError ,) , # [codec (index = 8)] Arithmetic (runtime_types :: sp_arithmetic :: ArithmeticError ,) , # [codec (index = 9)] Transactional (runtime_types :: sp_runtime :: TransactionalError ,) , # [codec (index = 10)] Exhausted , # [codec (index = 11)] Corruption , # [codec (index = 12)] Unavailable , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct ModuleError { pub index : :: core :: primitive :: u8 , pub error : [:: core :: primitive :: u8 ; 4usize] , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum MultiSignature { # [codec (index = 0)] Ed25519 (runtime_types :: sp_core :: ed25519 :: Signature ,) , # [codec (index = 1)] Sr25519 (runtime_types :: sp_core :: sr25519 :: Signature ,) , # [codec (index = 2)] Ecdsa (runtime_types :: sp_core :: ecdsa :: Signature ,) , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum TokenError { # [codec (index = 0)] NoFunds , # [codec (index = 1)] WouldDie , # [codec (index = 2)] BelowMinimum , # [codec (index = 3)] CannotCreate , # [codec (index = 4)] UnknownAsset , # [codec (index = 5)] Frozen , # [codec (index = 6)] Unsupported , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub enum TransactionalError { # [codec (index = 0)] LimitReached , # [codec (index = 1)] NoLayer , } } pub mod sp_session { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct MembershipProof { pub session : :: core :: primitive :: u32 , pub trie_nodes : :: std :: vec :: Vec < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , pub validator_count : :: core :: primitive :: u32 , } } pub mod sp_staking { use super :: runtime_types ; pub mod offence { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct OffenceDetails < _0 , _1 > { pub offender : _1 , pub reporters : :: std :: vec :: Vec < _0 > , } } } pub mod sp_version { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct RuntimeVersion { pub spec_name : :: std :: string :: String , pub impl_name : :: std :: string :: String , pub authoring_version : :: core :: primitive :: u32 , pub spec_version : :: core :: primitive :: u32 , pub impl_version : :: core :: primitive :: u32 , pub apis : :: std :: vec :: Vec < ([:: core :: primitive :: u8 ; 8usize] , :: core :: primitive :: u32 ,) > , pub transaction_version : :: core :: primitive :: u32 , pub state_version : :: core :: primitive :: u8 , } } pub mod sp_weights { use super :: runtime_types ; pub mod weight_v2 { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct Weight { # [codec (compact)] pub ref_time : :: core :: primitive :: u64 , # [codec (compact)] pub proof_size : :: core :: primitive :: u64 , } } # [derive (:: subxt :: ext :: codec :: CompactAs , :: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct OldWeight (pub :: core :: primitive :: u64 ,) ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct RuntimeDbWeight { pub read : :: core :: primitive :: u64 , pub write : :: core :: primitive :: u64 , } } pub mod substrate_account_filter { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] pub struct AllowAccount < _0 > (:: core :: marker :: PhantomData < _0 >) ; # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "Contains one variant per dispatchable that can be called by an extrinsic."] pub enum Call { # [codec (index = 0)] # [doc = "Add a new account to the allow-list."] # [doc = "Can only be called by the defined origin."] add_account { new_account : :: subxt :: utils :: AccountId32 , } , # [codec (index = 1)] # [doc = "Remove an account from the allow-list."] # [doc = "Can only be called by the defined origin."] remove_account { account_to_remove : :: subxt :: utils :: AccountId32 , } , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"] pub enum Error { # [codec (index = 0)] Duplicate , # [codec (index = 1)] AccountNotAdded , } # [derive (:: subxt :: ext :: codec :: Decode , :: subxt :: ext :: codec :: Encode , :: subxt :: ext :: scale_decode :: DecodeAsType , :: subxt :: ext :: scale_encode :: EncodeAsType , Debug)] # [decode_as_type (crate_path = ":: subxt :: ext :: scale_decode")] # [encode_as_type (crate_path = ":: subxt :: ext :: scale_encode")] # [doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"] pub enum Event { # [codec (index = 0)] AccountAllowed (:: subxt :: utils :: AccountId32 ,) , # [codec (index = 1)] AccountRemoved (:: subxt :: utils :: AccountId32 ,) , } } } } }
